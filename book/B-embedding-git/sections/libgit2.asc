=== Libgit2

(((libgit2)))(((C)))
Another option at your disposal is to use Libgit2.
Libgit2 is a dependency-free implementation of Git, with a focus on having a nice API for use within other programs.
You can find it at http://libgit2.github.com[].

Μια άλλη επιλογή στη διάθεσή μας είναι να χρησιμοποιήσουμε το Libgit2.
Το Libgit2 είναι μια εφαρμογή χωρίς εξαρτήσεις του Git, με έμφαση στην κατοχή ενός ωραίου API για χρήση σε άλλα προγράμματα.
Μπορούμε να το βρούμε στο http://libgit2.github.com[].

Αρχικά, ας ρίξουμε μια ματιά σε αυτό που μοιάζει με το C API.
Εδώ είναι μια περιπέτεια ανεμοστρόβιλος:

First, let's take a look at what the C API looks like.
Here's a whirlwind tour:

[source,c]
-----
// Open a repository
git_repository *repo;
int error = git_repository_open(&repo, "/path/to/repository");

// Dereference HEAD to a commit
git_object *head_commit;
error = git_revparse_single(&head_commit, repo, "HEAD^{commit}");
git_commit *commit = (git_commit*)head_commit;

// Print some of the commit's properties
printf("%s", git_commit_message(commit));
const git_signature *author = git_commit_author(commit);
printf("%s <%s>\n", author->name, author->email);
const git_oid *tree_id = git_commit_tree_id(commit);

// Cleanup
git_commit_free(commit);
git_repository_free(repo);
-----

The first couple of lines open a Git repository.
The `git_repository` type represents a handle to a repository with a cache in memory.
This is the simplest method, for when you know the exact path to a repository's working directory or `.git` folder.
There's also the `git_repository_open_ext` which includes options for searching, `git_clone` and friends for making a local clone of a remote repository, and `git_repository_init` for creating an entirely new repository.

Τα πρώτα ζευγάρια γραμμών ανοίγουν ένα αποθετήριο Git.
Ο τύπος `git_repository` αντιπροσωπεύει μια λαβή σε ένα αποθετήριο με μια μνήμη cache στη μνήμη.
Αυτή είναι η απλούστερη μέθοδος, όταν γνωρίζουμε την ακριβή διαδρομή στον κατάλογο εργασίας του αποθετηρίου ή στο φάκελο `.git`.
Υπάρχει επίσης το `git_repository_open_ext` το οποίο περιλαμβάνει επιλογές αναζήτησης,` git_clone` και φίλους για την δημιουργία τοπικού κλώνου απομακρυσμένου αποθετηρίου και `git_repository_init` για τη δημιουργία ενός εντελώς νέου αποθετηρίου.

Το δεύτερο κομμάτι του κώδικα χρησιμοποιεί σύνταξη rev-parse (βλέπε <<_branch_references>> για περισσότερα σχετικά με αυτό) για να πάρει τη υποβολή ότι HEAD τελικά επισημαίνει.
Ο τύπος που επιστρέφεται είναι ένας δείκτης `git_object`, ο οποίος αντιπροσωπεύει κάτι που υπάρχει στη βάση δεδομένων αντικειμένων Git για ένα αποθετήριο.
Το `git_object` είναι στην πραγματικότητα ένας τύπος` `parent'' για πολλά διαφορετικά είδη αντικειμένων· η διάταξη μνήμης για καθέναν από τους τύπους ``παιδιών 'είναι ίδια με εκείνη του `git_object`, ώστε να μπορούμε να μετακινηθούμε με ασφάλεια στο σωστό.
Σε αυτή την περίπτωση, το `git_object_type (commit)` θα επέστρεφε `GIT_OBJ_COMMIT`, επομένως είναι ασφαλές να μεταφερθούμε σε έναν δείκτη` git_commit`.

The second chunk of code uses rev-parse syntax (see <<_branch_references>> for more on this) to get the commit that HEAD eventually points to.
The type returned is a `git_object` pointer, which represents something that exists in the Git object database for a repository.
`git_object` is actually a ``parent'' type for several different kinds of objects; the memory layout for each of the ``child'' types is the same as for `git_object`, so you can safely cast to the right one.
In this case, `git_object_type(commit)` would return `GIT_OBJ_COMMIT`, so it's safe to cast to a `git_commit` pointer.

The next chunk shows how to access the commit's properties.
The last line here uses a `git_oid` type; this is Libgit2's representation for a SHA-1 hash.

Το επόμενο κομμάτι δείχνει τον τρόπο πρόσβασης στις ιδιότητες της υπηρεσίας.
Η τελευταία γραμμή εδώ χρησιμοποιεί έναν τύπο `git_oid`· αυτή είναι η αναπαράσταση του Libgit2 για ένα hash SHA-1.

Από αυτό το δείγμα, έχουν αρχίσει να αναδύονται δύο μοντέλα:

From this sample, a couple of patterns have started to emerge:

* If you declare a pointer and pass a reference to it into a Libgit2 call, that call will probably return an integer error code.
  A `0` value indicates success; anything less is an error.
* If Libgit2 populates a pointer for you, you're responsible for freeing it.
* If Libgit2 returns a `const` pointer from a call, you don't have to free it, but it will become invalid when the object it belongs to is freed.
* Writing C is a bit painful.

* Αν δηλώσουμε έναν δείκτη και μεταβιβάσουμε μια αναφορά σε μια κλήση Libgit2, αυτή η κλήση θα επιστρέψει πιθανώς έναν ακέραιο κωδικό σφάλματος.
  Η τιμή `0 'υποδηλώνει επιτυχία· τίποτα λιγότερο είναι ένα λάθος.
* Αν το Libgit2 συγκεντρώσει έναν δείκτη για εσάς, είστε υπεύθυνοι για την απελευθέρωσή του.
* Αν ο Libgit2 επιστρέψει έναν δείκτη `const 'από μια κλήση, δεν χρειάζεται να τον απελευθερώσουμε, αλλά θα ακυρωθεί όταν το αντικείμενο που ανήκει στην ελευθερωθεί.
* Το γράψιμο C είναι λίγο οδυνηρό.

Αυτός ο τελευταίος σημαίνει ότι δεν είναι πολύ πιθανό ότι θα γράφουμε C όταν χρησιμοποιούμε το Libgit2.
Ευτυχώς, υπάρχει ένας αριθμός γλωσσικών δεσμών που είναι διαθέσιμοι και καθιστούν αρκετά εύκολο να δουλέψεις με αποθετήρια Git από την συγκεκριμένη γλώσσα και το περιβάλλον σου.
Ας ρίξουμε μια ματιά στο παραπάνω παράδειγμα που γράφτηκε χρησιμοποιώντας τις υποβολές Ruby για το Libgit2, οι οποίες ονομάζονται Rugged και μπορούν να βρεθούν στο https://github.com/libgit2/rugged[].

(((Ruby)))
That last one means it isn't very probable that you'll be writing C when using Libgit2.
Fortunately, there are a number of language-specific bindings available that make it fairly easy to work with Git repositories from your specific language and environment.
Let's take a look at the above example written using the Ruby bindings for Libgit2, which are named Rugged, and can be found at https://github.com/libgit2/rugged[].

[source,ruby]
----
repo = Rugged::Repository.new('path/to/repository')
commit = repo.head.target
puts commit.message
puts "#{commit.author[:name]} <#{commit.author[:email]}>"
tree = commit.tree
----

As you can see, the code is much less cluttered.
Firstly, Rugged uses exceptions; it can raise things like `ConfigError` or `ObjectError`  to signal error conditions.
Secondly, there's no explicit freeing of resources, since Ruby is garbage-collected.
Let's take a look at a slightly more complicated example: crafting a commit from scratch

[source,ruby]
----
blob_id = repo.write("Blob contents", :blob) # <1>

index = repo.index
index.read_tree(repo.head.target.tree)
index.add(:path => 'newfile.txt', :oid => blob_id) # <2>

sig = {
    :email => "bob@example.com",
    :name => "Bob User",
    :time => Time.now,
}

commit_id = Rugged::Commit.create(repo,
    :tree => index.write_tree(repo), # <3>
    :author => sig,
    :committer => sig, # <4>
    :message => "Add newfile.txt", # <5>
    :parents => repo.empty? ? [] : [ repo.head.target ].compact, # <6>
    :update_ref => 'HEAD', # <7>
)
commit = repo.lookup(commit_id) # <8>
----

<1> Create a new blob, which contains the contents of a new file.
<2> Populate the index with the head commit's tree, and add the new file at the path `newfile.txt`.
<3> This creates a new tree in the ODB, and uses it for the new commit.
<4> We use the same signature for both the author and committer fields.
<5> The commit message.
<6> When creating a commit, you have to specify the new commit's parents.
    This uses the tip of HEAD for the single parent.
<7> Rugged (and Libgit2) can optionally update a reference when making a commit.
<8> The return value is the SHA-1 hash of a new commit object, which you can then use to get a `Commit` object.

<1> Δημιουργήστε ένα νέο blob, το οποίο περιέχει τα περιεχόμενα ενός νέου αρχείου.
<2> Πληκτρολογήστε το ευρετήριο με το δέντρο της υποβολής κεφαλής και προσθέστε το νέο αρχείο στη διαδρομή `newfile.txt`.
<3> Αυτό δημιουργεί ένα νέο δέντρο στο ODB και το χρησιμοποιεί για τη νέα διεκπεραίωση.
<4> Χρησιμοποιούμε την ίδια υπογραφή τόσο για τα πεδία συγγραφέα όσο και για τους συμμετέχοντες.
<5> Το μήνυμα υποβολής.
<6> Κατά τη δημιουργία μιας υποβολής, πρέπει να καθορίσουμε τους γονείς της νέας επιτροπής.
    Αυτό χρησιμοποιεί την άκρη του HEAD για τον μόνο γονέα.
<7> Το Rugged (και το Libgit2) μπορούν προαιρετικά να ενημερώσουν μια αναφορά όταν πραγματοποιούν μια υποβολή.
<8> Η τιμή επιστροφής είναι το SHA-1 hash ενός νέου αντικειμένου commit, το οποίο μπορούμε στη συνέχεια να χρησιμοποιήσουμε για να αποκτήσουμε ένα αντικείμενο `Commit`.

Ο κώδικας Ruby είναι ωραίος και καθαρός, αλλά δεδομένου ότι ο Libgit2 κάνει τη βαριά ανύψωση, αυτός ο κώδικας θα τρέξει αρκετά γρήγορα.
Αν δεν είστε ρουμίστας, αγγίζουμε κάποιες άλλες υποβολές στην ενότητα <<_libgit2_bindings>>.

The Ruby code is nice and clean, but since Libgit2 is doing the heavy lifting, this code will run pretty fast, too.
If you're not a rubyist, we touch on some other bindings in <<_libgit2_bindings>>.


==== Προηγμένη λειτουργικότητα

Libgit2 has a couple of capabilities that are outside the scope of core Git.
One example is pluggability: Libgit2 allows you to provide custom ``backends'' for several types of operation, so you can store things in a different way than stock Git does.
Libgit2 allows custom backends for configuration, ref storage, and the object database, among other things.

Το Libgit2 έχει κάποιες δυνατότητες που δεν εμπίπτουν στο πεδίο εφαρμογής του πυρήνα Git.
Ένα παράδειγμα είναι η δυνατότητα σύνδεσης: Το Libgit2 σάς επιτρέπει να παρέχουμε προσαρμοσμένες ``backends'' για διάφορους τύπους λειτουργιών, έτσι ώστε να μπορούμε να αποθηκεύουμε τα πράγματα με διαφορετικό τρόπο από ό, τι κάνει το stock Git.
Το Libgit2 επιτρέπει προσαρμοσμένα αντίγραφα ασφαλείας για τη διαμόρφωση, την αποθήκευση αρχείων αναφοράς και τη βάση δεδομένων αντικειμένων, μεταξύ άλλων.

Ας ρίξουμε μια ματιά στο πώς λειτουργεί αυτό.
Ο παρακάτω κώδικας δανείζεται από το σύνολο των παραδειγμάτων υποστήριξης που παρέχονται από την ομάδα Libgit2 (η οποία βρίσκεται στη διεύθυνση https://github.com/libgit2/libgit2-backends[]).
Ακολουθεί ο τρόπος ρύθμισης μιας προσαρμοσμένης βάσης δεδομένων για τη βάση δεδομένων αντικειμένων:

Let's take a look at how this works.
The code below is borrowed from the set of backend examples provided by the Libgit2 team (which can be found at https://github.com/libgit2/libgit2-backends[]).
Here's how a custom backend for the object database is set up:

[source,c]
----
git_odb *odb;
int error = git_odb_new(&odb); // <1>

git_odb_backend *my_backend;
error = git_odb_backend_mine(&my_backend, /*…*/); // <2>

error = git_odb_add_backend(odb, my_backend, 1); // <3>

git_repository *repo;
error = git_repository_open(&repo, "some-path");
error = git_repository_set_odb(odb); // <4>
----

_(Note that errors are captured, but not handled. We hope your code is better than ours.)_

... (Σημειώστε ότι τα σφάλματα έχουν καταγραφεί, αλλά δεν έχουν χειριστεί. Ελπίζουμε ο κώδικας μας να είναι καλύτερος από τον δικό μας). _

<1> Αρχικοποιήστε μια βάση δεδομένων κενών αντικειμένων (ODB) ``frontend'', που θα λειτουργήσει ως κοντέινερ για τα backends που είναι αυτά που κάνουν την πραγματική δουλειά.
<2> Αρχικοποιήστε μια προσαρμοσμένη backbone ODB.
<3> Προσθέστε το backend στο front-end.
<4> Ανοίξτε ένα αποθετήριο και ρυθμίστε το για να χρησιμοποιήσουμε το ODB μας για να αναζητήσουμε αντικείμενα.

<1> Initialize an empty object database (ODB) ``frontend,'' which will act as a container for the ``backends'' which are the ones doing the real work.
<2> Initialize a custom ODB backend.
<3> Add the backend to the frontend.
<4> Open a repository, and set it to use our ODB to look up objects.

Αλλά τι είναι αυτό το "git_odb_backend_mine" πράγμα;
Λοιπόν, αυτός είναι ο κατασκευαστής για τη δική μας υλοποίηση ODB και μπορούμε να κάνουμε ό, τι θέλουμε εκεί, αρκεί να συμπληρώσουμε τη δομή `git_odb_backend` σωστά.
Ας δούμε πώς θα μπορούσε να μοιάζει με:

But what is this `git_odb_backend_mine` thing?
Well, that's the constructor for your own ODB implementation, and you can do whatever you want in there, so long as you fill in the `git_odb_backend` structure properly.
Here's what it _could_ look like:

[source,c]
----
typedef struct {
    git_odb_backend parent;

    // Some other stuff
    void *custom_context;
} my_backend_struct;

int git_odb_backend_mine(git_odb_backend **backend_out, /*…*/)
{
    my_backend_struct *backend;

    backend = calloc(1, sizeof (my_backend_struct));

    backend->custom_context = …;

    backend->parent.read = &my_backend__read;
    backend->parent.read_prefix = &my_backend__read_prefix;
    backend->parent.read_header = &my_backend__read_header;
    // …

    *backend_out = (git_odb_backend *) backend;

    return GIT_SUCCESS;
}
----

The subtlest constraint here is that `my_backend_struct`'s first member must be a `git_odb_backend` structure; this ensures that the memory layout is what the Libgit2 code expects it to be.
The rest of it is arbitrary; this structure can be as large or small as you need it to be.

Ο πιο λεπτός περιορισμός εδώ είναι ότι το πρώτο μέλος του my_backend_struct πρέπει να είναι μια δομή `git_odb_backend`· αυτό εξασφαλίζει ότι η διάταξη μνήμης είναι αυτό που ο κώδικας Libgit2 αναμένει να είναι.
Το υπόλοιπο είναι αυθαίρετο· αυτή η δομή μπορεί να είναι τόσο μεγάλη όσο και μικρή που χρειάζεστε.

Η συνάρτηση αρχικοποίησης εκχωρεί κάποια μνήμη για τη δομή, ρυθμίζει το προσαρμοσμένο πλαίσιο και στη συνέχεια συμπληρώνει τα μέλη της δομής `parent` που υποστηρίζει.
Ρίξτε μια ματιά στο αρχείο `include / git2 / sys / odb_backend.h` στην πηγή Libgit2 για ένα πλήρες σύνολο υπογραφών κλήσεων· η συγκεκριμένη περίπτωση χρήσης μας θα μας βοηθήσει να προσδιορίσουμε ποια από αυτά θα θέλουμε να υποστηρίξουμε.

The initialization function allocates some memory for the structure, sets up the custom context, and then fills in the members of the `parent` structure that it supports.
Take a look at the `include/git2/sys/odb_backend.h` file in the Libgit2 source for a complete set of call signatures; your particular use case will help determine which of these you'll want to support.

[[_libgit2_bindings]]
==== Other Bindings
==== Άλλες συνδέσεις

Το Libgit2 έχει υποβολές για πολλές γλώσσες.
Εδώ παρουσιάζουμε ένα μικρό παράδειγμα χρησιμοποιώντας μερικά από τα πιο ολοκληρωμένα πακέτα υποβολής από αυτό το γράψιμο· υπάρχουν βιβλιοθήκες για πολλές άλλες γλώσσες, συμπεριλαμβανομένων των C ++, Go, Node.js, Erlang και JVM, όλα σε διάφορα στάδια ωριμότητας.
Η επίσημη συλλογή υποβολών μπορεί να βρεθεί με την περιήγηση στα αποθετήρια στη διεύθυνση https://github.com/libgit2[].
Ο κώδικας που θα γράψουμε θα επιστρέψει το μήνυμα υποβολής από την εντολή που τελικά επισήμανε από το HEAD (είδος σαν "git log -1").

Libgit2 has bindings for many languages.
Here we show a small example using a few of the more complete bindings packages as of this writing; libraries exist for many other languages, including C++, Go, Node.js, Erlang, and the JVM, all in various stages of maturity.
The official collection of bindings can be found by browsing the repositories at https://github.com/libgit2[].
The code we'll write will return the commit message from the commit eventually pointed to by HEAD (sort of like `git log -1`).


===== LibGit2Sharp

(((.NET)))(((C#)))(((Mono)))
Αν γράφουμε μια εφαρμογή .NET ή Mono, το LibGit2Sharp (https://github.com/libgit2/libgit2sharp[]) είναι αυτό που ψάχνουμε.
Οι υποβολές είναι γραμμένες σε C # και έχει ληφθεί μεγάλη προσοχή για την αναδίπλωση των ωρών κλήσεων Libgit2 με API CLR API.
Ακολουθεί το παράδειγμά μας:

If you're writing a .NET or Mono application, LibGit2Sharp (https://github.com/libgit2/libgit2sharp[]) is what you're looking for.
The bindings are written in C#, and great care has been taken to wrap the raw Libgit2 calls with native-feeling CLR APIs.
Here's what our example program looks like:

[source,csharp]
-----
new Repository(@"C:\path\to\repo").Head.Tip.Message;
-----

Για εφαρμογές για επιτραπέζιους υπολογιστές Windows, υπάρχει ακόμα ένα πακέτο NuGet που θα μας βοηθήσει να ξεκινήσουμε γρήγορα.

For desktop Windows applications, there's even a NuGet package that will help you get started quickly.

===== objective-git

(((Apple)))(((Objective-C)))(((Cocoa)))
Εάν η εφαρμογή μας εκτελείται σε πλατφόρμα της Apple, πιθανόν να χρησιμοποιούμε τη γλώσσα στόχου C ως γλώσσα υλοποίησης.
Το Objective-Git (https://github.com/libgit2/objective-git[]) είναι το όνομα των υποβολών Libgit2 για αυτό το περιβάλλον.
Το πρόγραμμα παράδειγμα μοιάζει με αυτό:

If your application is running on an Apple platform, you're likely using Objective-C as your implementation language.
Objective-Git (https://github.com/libgit2/objective-git[]) is the name of the Libgit2 bindings for that environment.
The example program looks like this:

[source,objc]
-----
GTRepository *repo =
    [[GTRepository alloc] initWithURL:[NSURL fileURLWithPath: @"/path/to/repo"] error:NULL];
NSString *msg = [[[repo headReferenceWithError:NULL] resolvedTarget] message];
-----

Το Objective-git είναι πλήρως διαλειτουργικό με το Swift, οπότε μην φοβάστε εάν έχουμε αφήσει πίσω το Objective-C.

Objective-git is fully interoperable with Swift, so don't fear if you've left Objective-C behind.


===== pygit2

(((Python)))
Οι υποβολές για το Libgit2 στην Python ονομάζονται Pygit2 και μπορούν να βρεθούν στο http://www.pygit2.org/[].
Το παράδειγμα του προγράμματος μας:

The bindings for Libgit2 in Python are called Pygit2, and can be found at http://www.pygit2.org/[].
Our example program:

[source,python]
----
pygit2.Repository("/path/to/repo") # open repository
    .head                          # get the current branch
    .peel(pygit2.Commit)           # walk down to the commit
    .message                       # read the message
----


==== Περαιτέρω ανάγνωση

Φυσικά, η πλήρης αντιμετώπιση των δυνατοτήτων του Libgit2 είναι εκτός του πεδίου αυτού του βιβλίου.
Αν θέλουμε περισσότερες πληροφορίες σχετικά με το ίδιο το Libgit2, υπάρχει τεκμηρίωση API στη διεύθυνση https://libgit2.github.com/libgit2[] και ένα σύνολο οδηγών στη διεύθυνση https://libgit2.github.com/docs[].
Για τις άλλες υποβολές, ελέγξτε το πακέτο README και τις δοκιμές· υπάρχουν συχνά μικρά μαθήματα και δείκτες για την περαιτέρω ανάγνωση εκεί.

Of course, a full treatment of Libgit2's capabilities is outside the scope of this book.
If you want more information on Libgit2 itself, there's API documentation at https://libgit2.github.com/libgit2[], and a set of guides at https://libgit2.github.com/docs[].
For the other bindings, check the bundled README and tests; there are often small tutorials and pointers to further reading there.
