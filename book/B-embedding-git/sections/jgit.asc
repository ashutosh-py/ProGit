=== JGit

(((jgit)))(((java)))
Εάν θέλουμε να χρησιμοποιήσουμε το Git μέσα σε ένα πρόγραμμα Java, υπάρχει μια πλήρως εξοπλισμένη βιβλιοθήκη Git που ονομάζεται JGit.
Το JGit είναι μια σχετικά πλήρης εφαρμογή του Git που γράφεται εγγενώς στη Java και χρησιμοποιείται ευρέως στην κοινότητα της Java.
Το έργο JGit βρίσκεται υπό την ομπρέλα Eclipse και το σπίτι του βρίσκεται στο http://www.eclipse.org/jgit[].

If you want to use Git from within a Java program, there is a fully featured Git library called JGit.
JGit is a relatively full-featured implementation of Git written natively in Java, and is widely used in the Java community.
The JGit project is under the Eclipse umbrella, and its home can be found at http://www.eclipse.org/jgit[].

==== Getting Set Up

Υπάρχουν διάφοροι τρόποι για να συνδέσουμε το έργο μας με το JGit και να αρχίσουμε να γράφουμε κώδικα εναντίον του.
Πιθανώς το πιο εύκολο είναι να χρησιμοποιήσουμε το Maven - η ολοκλήρωση ολοκληρώνεται προσθέτοντας το ακόλουθο απόσπασμα στην ετικέτα `<dependences>` στο αρχείο pom.xml:

There are a number of ways to connect your project with JGit and start writing code against it.
Probably the easiest is to use Maven – the integration is accomplished by adding the following snippet to the `<dependencies>` tag in your pom.xml file:

[source,xml]
----
<dependency>
    <groupId>org.eclipse.jgit</groupId>
    <artifactId>org.eclipse.jgit</artifactId>
    <version>3.5.0.201409260305-r</version>
</dependency>
----

The `version` will most likely have advanced by the time you read this; check http://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit[] for updated repository information.
Once this step is done, Maven will automatically acquire and use the JGit libraries that you'll need.

Η «έκδοση» πιθανότατα θα έχει προχωρήσει από τη στιγμή που θα το διαβάσουμε· ελέγξτε http://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit[] για ενημερωμένες πληροφορίες αποθετηρίου.
Μόλις ολοκληρωθεί αυτό το βήμα, η Maven θα αποκτήσει και θα χρησιμοποιήσει αυτόματα τις βιβλιοθήκες JGit που χρειάζεστε.

Αν προτιμάτε να διαχειρίζεστε μόνοι μας τις δυαδικές εξαρτήσεις, τα προ-κατασκευασμένα δυαδικά αρχεία JGit διατίθενται από το http://www.eclipse.org/jgit/download[].
Μπορούμε να τα δημιουργήσουμε στο έργο μας, τρέχοντας μια εντολή όπως αυτή:

If you would rather manage the binary dependencies yourself, pre-built JGit binaries are available from http://www.eclipse.org/jgit/download[].
You can build them into your project by running a command like this:

[source,console]
----
javac -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App.java
java -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App
----

==== Plumbing

JGit has two basic levels of API: plumbing and porcelain.
The terminology for these comes from Git itself, and JGit is divided into roughly the same kinds of areas: porcelain APIs are a friendly front-end for common user-level actions (the sorts of things a normal user would use the Git command-line tool for), while the plumbing APIs are for interacting with low-level repository objects directly.

Το JGit έχει δύο βασικά επίπεδα API: υδραυλικά και πορσελάνη.
Η ορολογία για αυτά προέρχεται από το ίδιο το Git και το JGit χωρίζεται σε περίπου τα ίδια είδη: τα API πορσελάνης είναι ένα φιλικό front-end για κοινές ενέργειες σε επίπεδο χρήστη (τα πράγματα που ένας κανονικός χρήστης θα χρησιμοποιήσει τη γραμμή εντολών Git εργαλείο για), ενώ τα API υδραυλικών εγκαταστάσεων είναι για την άμεση αλληλεπίδραση με αντικείμενα αποθετηρίου χαμηλού επιπέδου.

Το σημείο εκκίνησης για τις περισσότερες συνεδρίες JGit είναι η κλάση `Repository` και το πρώτο πράγμα που θα θελήσουμε να κάνουμε είναι να δημιουργήσουμε μια παρουσία του.
Για ένα αποθετήριο με βάση το σύστημα αρχείων (ναι, το JGit επιτρέπει άλλα μοντέλα αποθήκευσης), αυτό επιτυγχάνεται χρησιμοποιώντας το `FileRepositoryBuilder`:

The starting point for most JGit sessions is the `Repository` class, and the first thing you'll want to do is create an instance of it.
For a filesystem-based repository (yes, JGit allows for other storage models), this is accomplished using `FileRepositoryBuilder`:

[source,java]
----
// Create a new repository
Repository newlyCreatedRepo = FileRepositoryBuilder.create(
    new File("/tmp/new_repo/.git"));
newlyCreatedRepo.create();

// Open an existing repository
Repository existingRepo = new FileRepositoryBuilder()
    .setGitDir(new File("my_repo/.git"))
    .build();
----

The builder has a fluent API for providing all the things it needs to find a Git repository, whether or not your program knows exactly where it's located.
It can use environment variables (`.readEnvironment()`), start from a place in the working directory and search (`.setWorkTree(…).findGitDir()`), or just open a known `.git` directory as above.

Ο οικοδόμος έχει ένα άπταιο API για να παρέχει όλα τα πράγματα που χρειάζεται για να βρει ένα αποθετήριο Git, ανεξάρτητα από το αν το πρόγραμμα μας γνωρίζει ακριβώς πού βρίσκεται.
Μπορεί να χρησιμοποιήσει μεταβλητές περιβάλλοντος (`.readEnvironment ()`), να ξεκινήσει από μια θέση στον κατάλογο εργασίας και να αναζητήσει (`.setWorkTree (...) .findGitDir ()`) ή απλά να ανοίξει έναν γνωστό κατάλογο `.git` όπως παραπάνω .

Μόλις έχουμε ένα παράδειγμα `Repository`, μπορούμε να κάνουμε όλα τα πράγματα με αυτό.
Ακολουθεί μια γρήγορη δειγματοληψία:

Once you have a `Repository` instance, you can do all sorts of things with it.
Here's a quick sampling:

[source,java]
----
// Get a reference
Ref master = repo.getRef("master");

// Get the object the reference points to
ObjectId masterTip = master.getObjectId();

// Rev-parse
ObjectId obj = repo.resolve("HEAD^{tree}");

// Load raw object contents
ObjectLoader loader = repo.open(masterTip);
loader.copyTo(System.out);

// Create a branch
RefUpdate createBranch1 = repo.updateRef("refs/heads/branch1");
createBranch1.setNewObjectId(masterTip);
createBranch1.update();

// Delete a branch
RefUpdate deleteBranch1 = repo.updateRef("refs/heads/branch1");
deleteBranch1.setForceUpdate(true);
deleteBranch1.delete();

// Config
Config cfg = repo.getConfig();
String name = cfg.getString("user", null, "name");
----

There's quite a bit going on here, so let's go through it one section at a time.

Κάποια στιγμή συμβαίνει εδώ, οπότε ας το περάσουμε ένα τμήμα κάθε φορά.

Η πρώτη γραμμή παίρνει έναν δείκτη στην αναφορά `master`.
Το JGit αρπάζει αυτόματα τον κύριο φάκελο _actual_ master, ο οποίος ζει στο `refs / heads / master`, και επιστρέφει ένα αντικείμενο που μας επιτρέπει να ανακτήσουμε πληροφορίες σχετικά με την αναφορά.
Μπορούμε να πάρουμε το όνομα (`.getName ()`) και είτε το αντικείμενο στόχο μιας άμεσης αναφοράς (`.getObjectId ()`) είτε την αναφορά που υποδεικνύεται από ένα συμβολικό ref (`.getTarget ()`).
Τα αντικείμενα Ref χρησιμοποιούνται επίσης για την αναπαράσταση αναφορών ετικετών και αντικειμένων, έτσι μπορούμε να ρωτήσουμε αν η ετικέτα είναι ``αποφλοιωμένη '', πράγμα που σημαίνει ότι δείχνει τον τελικό στόχο μιας (δυνητικά μακράς) συμβολοσειράς αντικειμένων tag.

The first line gets a pointer to the `master` reference.
JGit automatically grabs the _actual_ master ref, which lives at `refs/heads/master`, and returns an object that lets you fetch information about the reference.
You can get the name (`.getName()`), and either the target object of a direct reference (`.getObjectId()`) or the reference pointed to by a symbolic ref (`.getTarget()`).
Ref objects are also used to represent tag refs and objects, so you can ask if the tag is ``peeled,'' meaning that it points to the final target of a (potentially long) string of tag objects.

The second line gets the target of the `master` reference, which is returned as an ObjectId instance.
ObjectId represents the SHA-1 hash of an object, which might or might not exist in Git's object database.
The third line is similar, but shows how JGit handles the rev-parse syntax (for more on this, see <<_branch_references>>); you can pass any object specifier that Git understands, and JGit will return either a valid ObjectId for that object, or `null`.

Η δεύτερη γραμμή παίρνει το στόχο της αναφοράς `master ', το οποίο επιστρέφεται ως παράμετρος ObjectId.
Το ObjectId αντιπροσωπεύει το SHA-1 hash ενός αντικειμένου, το οποίο μπορεί να υπάρχει ή να μην υπάρχει στη βάση δεδομένων αντικειμένων του Git.
Η τρίτη γραμμή είναι παρόμοια, αλλά δείχνει πώς το JGit χειρίζεται τη συντακτική αναπαράσταση (για περισσότερες πληροφορίες, ανατρέξτε στην ενότητα <<_branch_references>>)· μπορούμε να περάσουμε οποιονδήποτε προσδιοριστή αντικειμένου που κατανοεί το Git και το JGit θα επιστρέψει είτε ένα έγκυρο ObjectId για αυτό το αντικείμενο είτε το `null`.

Οι επόμενες δύο γραμμές δείχνουν τον τρόπο φόρτωσης των ακατέργαστων περιεχομένων ενός αντικειμένου.
Σε αυτό το παράδειγμα, ονομάζουμε `ObjectLoader.copyTo ()` για να μεταφέρουμε τα περιεχόμενα του αντικειμένου απευθείας στο stdout, αλλά το ObjectLoader έχει επίσης μεθόδους για να διαβάσει τον τύπο και το μέγεθος ενός αντικειμένου, καθώς και να το επιστρέψει σαν ένα byte array.
Για τα μεγάλα αντικείμενα (όπου `.isLarge () επιστρέφει` true`), μπορούμε να καλέσουμε το `.openStream ()` για να αποκτήσουμε ένα αντικείμενο τύπου InputStream που μπορεί να διαβάσει τα δεδομένα του ακατέργαστου αντικειμένου χωρίς να το τραβήξει όλα στη μνήμη ταυτόχρονα.

The next two lines show how to load the raw contents of an object.
In this example, we call `ObjectLoader.copyTo()` to stream the contents of the object directly to stdout, but ObjectLoader also has methods to read the type and size of an object, as well as return it as a byte array.
For large objects (where `.isLarge()` returns `true`), you can call `.openStream()` to get an InputStream-like object that can read the raw object data without pulling it all into memory at once.

The next few lines show what it takes to create a new branch.
We create a RefUpdate instance, configure some parameters, and call `.update()` to trigger the change.
Directly following this is the code to delete that same branch.
Note that `.setForceUpdate(true)` is required for this to work; otherwise the `.delete()` call will return `REJECTED`, and nothing will happen.

Οι επόμενες γραμμές δείχνουν τι χρειάζεται για τη δημιουργία ενός νέου κλάδου.
Δημιουργούμε μια παράμετρο RefUpdate, διαμορφώστε κάποιες παραμέτρους και καλέστε `.update ()` για να ενεργοποιήσουμε την αλλαγή.
Αμέσως μετά από αυτό είναι ο κώδικας για να διαγράψουμε τον ίδιο κλάδο.
Σημειώστε ότι `.setForceUpdate (true)` είναι απαραίτητο για να λειτουργήσει αυτό· διαφορετικά η κλήση `.delete () 'θα επιστρέψει' ΑΠΑΓΟΡΕΥΕΤΑΙ 'και τίποτα δεν θα συμβεί.

Το τελευταίο παράδειγμα δείχνει τον τρόπο λήψης της τιμής `user.name 'από τα αρχεία ρυθμίσεων Git.
Αυτό το παράδειγμα Config χρησιμοποιεί το χώρο αποθήκευσης που ανοίξαμε νωρίτερα για την τοπική διαμόρφωση, αλλά θα ανιχνεύσει αυτόματα τα παγκόσμια αρχεία διαμόρφωσης και συστήματος και θα διαβάσει επίσης τιμές από αυτές.

The last example shows how to fetch the `user.name` value from the Git configuration files.
This Config instance uses the repository we opened earlier for local configuration, but will automatically detect the global and system configuration files and read values from them as well.

Αυτό είναι μόνο μια μικρή δειγματοληψία του πλήρους API υδραυλικών? υπάρχουν πολλές άλλες διαθέσιμες μέθοδοι και τάξεις.
Επίσης, δεν εμφανίζεται εδώ ο τρόπος με τον οποίο η JGit χειρίζεται λάθη, η οποία γίνεται με τη χρήση εξαιρέσεων.
Τα API JGit ρίχνουν μερικές φορές τυπικές εξαιρέσεις Java (όπως το «IOException»), αλλά υπάρχουν και αρκετοί ειδικοί τύποι εξαιρέσεων JGit που παρέχονται επίσης (όπως «NoRemoteRepositoryException», «CorruptObjectException» και «NoMergeBaseException»).

This is only a small sampling of the full plumbing API; there are many more methods and classes available.
Also not shown here is the way JGit handles errors, which is through the use of exceptions.
JGit APIs sometimes throw standard Java exceptions (such as `IOException`), but there are a host of JGit-specific exception types that are provided as well (such as `NoRemoteRepositoryException`, `CorruptObjectException`, and `NoMergeBaseException`).

==== Πορσελάνες

Τα API υδραυλικών εγκαταστάσεων είναι μάλλον πλήρεις, αλλά μπορεί να είναι δυσκίνητη η σύζευξη τους για την επίτευξη κοινών στόχων, όπως η προσθήκη ενός αρχείου στο ευρετήριο ή η πραγματοποίηση μιας νέας υποβολής.
Το JGit παρέχει ένα σετ υψηλότερων επιπέδων API για να βοηθήσει με αυτό, και το σημείο εισόδου σε αυτά τα API είναι η κατηγορία `Git`:

The plumbing APIs are rather complete, but it can be cumbersome to string them together to achieve common goals, like adding a file to the index, or making a new commit.
JGit provides a higher-level set of APIs to help out with this, and the entry point to these APIs is the `Git` class:

[source,java]
----
Repository repo;
// construct repo...
Git git = new Git(repo);
----

Η τάξη Git έχει ένα ωραίο σύνολο υψηλού επιπέδου _builder_-style μεθόδους που μπορούν να χρησιμοποιηθούν για την κατασκευή κάποιων πολύ περίπλοκων συμπεριφορών.
Ας ρίξουμε μια ματιά σε ένα παράδειγμα - κάνοντας κάτι σαν `git ls-remote`:

The Git class has a nice set of high-level _builder_-style methods that can be used to construct some pretty complex behavior.
Let's take a look at an example – doing something like `git ls-remote`:

[source,java]
----
CredentialsProvider cp = new UsernamePasswordCredentialsProvider("username", "p4ssw0rd");
Collection<Ref> remoteRefs = git.lsRemote()
    .setCredentialsProvider(cp)
    .setRemote("origin")
    .setTags(true)
    .setHeads(false)
    .call();
for (Ref ref : remoteRefs) {
    System.out.println(ref.getName() + " -> " + ref.getObjectId().name());
}
----

This is a common pattern with the Git class; the methods return a command object that lets you chain method calls to set parameters, which are executed when you call `.call()`.
In this case, we're asking the `origin` remote for tags, but not heads.
Also notice the use of a `CredentialsProvider` object for authentication.

Αυτό είναι ένα κοινό μοτίβο με την κλάση Git· οι μέθοδοι επιστρέφουν ένα αντικείμενο εντολής που μας επιτρέπει να κάνουμε κλήσεις μεθόδου αλυσίδας για να ορίσουμε παραμέτρους, οι οποίες εκτελούνται όταν καλούμε το `.call ()`.
Σε αυτή την περίπτωση, ζητάμε την απομακρυσμένη εντολή `προέλευσης 'για ετικέτες, αλλά όχι κεφαλές.
Σημειώστε επίσης τη χρήση ενός αντικειμένου `CredentialsProvider` για έλεγχο ταυτότητας.

Πολλές άλλες εντολές είναι διαθέσιμες μέσω της κλάσης Git, συμπεριλαμβανομένων, μεταξύ άλλων, των `add ',` blame`, `commit',` clean`, `push ',` rebase`, `revert` και` reset`.

Many other commands are available through the Git class, including but not limited to `add`, `blame`, `commit`, `clean`, `push`, `rebase`, `revert`, and `reset`.

==== Περαιτέρω ανάγνωση

This is only a small sampling of JGit's full capabilities.
If you're interested and want to learn more, here's where to look for information and inspiration:

Αυτό είναι μόνο ένα μικρό δείγμα των πλήρων δυνατοτήτων του JGit.
Εάν ενδιαφέρεστε και θέλουμε να μάθουμε περισσότερα, εδώ θα βρούμε πληροφορίες και έμπνευση:

* Η επίσημη τεκμηρίωση του JGit API διατίθεται ηλεκτρονικά στο http://download.eclipse.org/jgit/docs/latest/apidocs[].
  Αυτά είναι τα πρότυπα Javadoc, έτσι ώστε το αγαπημένο μας IDE JVM να μπορεί να τα εγκαταστήσει και σε τοπικό επίπεδο.
* Το βιβλίο μαγειρικής JGit στο https://github.com/centic9/jgit-cookbook[] έχει πολλά παραδείγματα για το πώς να κάνουμε συγκεκριμένες εργασίες με το JGit.
* Υπάρχουν αρκετοί πόροι που έχουν επισημανθεί στο http://stackoverflow.com/questions/6861881[].

* The official JGit API documentation is available online at http://download.eclipse.org/jgit/docs/latest/apidocs[].
  These are standard Javadoc, so your favorite JVM IDE will be able to install them locally, as well.
* The JGit Cookbook at https://github.com/centic9/jgit-cookbook[] has many examples of how to do specific tasks with JGit.
* There are several good resources pointed out at http://stackoverflow.com/questions/6861881[].
