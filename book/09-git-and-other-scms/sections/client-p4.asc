==== Git and Perforce

(((Διαλειτουργικότητα με άλλα VCS, Perforce)))
(((Perforce)))
Perforce is a very popular version-control system in corporate environments.
It's been around since 1995, which makes it the oldest system covered in this chapter.
As such, it's designed with the constraints of its day; it assumes you're always connected to a single central server, and only one version is kept on the local disk.
To be sure, its features and constraints are well-suited to several specific problems, but there are lots of projects using Perforce where Git would actually work better.

Το Perforce είναι ένα πολύ δημοφιλές σύστημα ελέγχου εκδόσεων σε εταιρικά περιβάλλοντα.
Έχει περάσει από το 1995, γεγονός που το καθιστά το παλαιότερο σύστημα που καλύπτεται σε αυτό το κεφάλαιο.
Ως εκ τούτου, έχει σχεδιαστεί με τους περιορισμούς της ημέρας του. υποθέτει ότι είστε πάντα συνδεδεμένοι σε έναν κεντρικό διακομιστή και ότι διατηρείται μόνο μία έκδοση στον τοπικό δίσκο.
Βεβαίως, τα χαρακτηριστικά και οι περιορισμοί του είναι κατάλληλα για αρκετά συγκεκριμένα προβλήματα, αλλά υπάρχουν πολλά έργα που χρησιμοποιούν το Perforce όπου το Git θα λειτουργούσε πραγματικά καλύτερα.

Υπάρχουν δύο επιλογές αν θέλουμε να συνδυάσουμε τη χρήση του Perforce και του Git.
Ο πρώτος που θα καλύψουμε είναι η γέφυρα `` Git Fusion '' από τους κατασκευαστές του Perforce, που μας επιτρέπει να εκθέτουμε τα subtrees της αποθήκης Perforce ως αποθετήρια Git read-write.
Το δεύτερο είναι το git-p4, μια γέφυρα από την πλευρά του πελάτη, που μας επιτρέπει να χρησιμοποιήσουμε το Git ως πελάτη Perforce, χωρίς να απαιτήσουμε επανασύνταξη του διακομιστή Perforce.

There are two options if you'd like to mix your use of Perforce and Git.
The first one we'll cover is the ``Git Fusion'' bridge from the makers of Perforce, which lets you expose subtrees of your Perforce depot as read-write Git repositories.
The second is git-p4, a client-side bridge that lets you use Git as a Perforce client, without requiring any reconfiguration of the Perforce server.

[[_p4_git_fusion]]
===== Git Fusion

(((Perforce, Git Fusion)))
Το Perforce παρέχει ένα προϊόν που ονομάζεται Git Fusion (διαθέσιμο στη http://www.perforce.com/git-fusion[]), το οποίο συγχρονίζει έναν διακομιστή Perforce με αποθετήρια Git στην πλευρά του διακομιστή.

Perforce provides a product called Git Fusion (available at http://www.perforce.com/git-fusion[]), which synchronizes a Perforce server with Git repositories on the server side.

====== Setting Up

For our examples, we'll be using the easiest installation method for Git Fusion, which is downloading a virtual machine that runs the Perforce daemon and Git Fusion.
You can get the virtual machine image from http://www.perforce.com/downloads/Perforce/20-User[], and once it's finished downloading, import it into your favorite virtualization software (we'll use VirtualBox).

Για τα παραδείγματα μας, θα χρησιμοποιήσουμε την πιο εύκολη μέθοδο εγκατάστασης για το Git Fusion, το οποίο μεταφορτώνει μια εικονική μηχανή που τρέχει το δαίμονα Perforce και το Git Fusion.
Μπορούμε να πάρουμε την εικόνα της εικονικής μηχανής από το http://www.perforce.com/downloads/Perforce/20-User[], και μόλις ολοκληρωθεί η λήψη, εισαγάγουμε το στο αγαπημένο μας λογισμικό εικονικοποίησης (θα χρησιμοποιήσουμε το VirtualBox).

Με την πρώτη εκκίνηση του μηχανήματος, μας ζητά να προσαρμόσουμε τον κωδικό πρόσβασης για τρεις χρήστες Linux (`root`,` perforce` και `git`) και να δώσουμε ένα όνομα στιγμιότυπου, το οποίο μπορεί να χρησιμοποιηθεί για να διακρίνει αυτή την εγκατάσταση από άλλους στο ίδιο δίκτυο.
Όταν όλα αυτά ολοκληρωθούν, θα δούμε τα εξής:

Upon first starting the machine, it asks you to customize the password for three Linux users (`root`, `perforce`, and `git`), and provide an instance name, which can be used to distinguish this installation from others on the same network.
When that has all completed, you'll see this:

.Η οθόνη εκκίνησης εικονικής μηχανής Git Fusion.
image::images/git-fusion-boot.png[Η οθόνη εκκίνησης εικονικής μηχανής Git Fusion.]

Θα πρέπει να λάβουμε υπόψη τη διεύθυνση IP που εμφανίζεται εδώ, θα τη χρησιμοποιήσουμε αργότερα.
Στη συνέχεια, θα δημιουργήσουμε έναν χρήστη Perforce.
Επιλέξτε την επιλογή `` Login '' στο κάτω μέρος και πατήστε enter (ή SSH στο μηχάνημα) και συνδεθούμε ως `root '.
Στη συνέχεια, χρησιμοποιήστε αυτές τις εντολές για να δημιουργήσουμε έναν χρήστη:

You should take note of the IP address that's shown here, we'll be using it later on.
Next, we'll create a Perforce user.
Select the ``Login'' option at the bottom and press enter (or SSH to the machine), and log in as `root`.
Then use these commands to create a user:

[source,console]
----
$ p4 -p localhost:1666 -u super user -f john
$ p4 -p localhost:1666 -u john passwd
$ exit
----

The first one will open a VI editor to customize the user, but you can accept the defaults by typing `:wq` and hitting enter.
The second one will prompt you to enter a password twice.
That's all we need to do with a shell prompt, so exit out of the session.

Ο πρώτος θα ανοίξει έναν επεξεργαστή VI για να προσαρμόσει τον χρήστη, αλλά μπορούμε να αποδεχτούμε τις προεπιλογές πληκτρολογώντας `: wq` και πατώντας enter.
Η δεύτερη θα μας ζητήσει να εισαγάγουμε έναν κωδικό πρόσβασης δύο φορές.
Αυτό είναι όλο που πρέπει να κάνουμε με μια προτροπή κελύφους, οπότε βγούμε από τη συνεδρία.

Το επόμενο πράγμα που πρέπει να κάνουμε για να ακολουθήσουμε είναι να πούμε στο Git να μην επαληθεύει τα πιστοποιητικά SSL.
Η εικόνα Git Fusion έρχεται με ένα πιστοποιητικό, αλλά είναι για έναν τομέα που δεν ταιριάζει με τη διεύθυνση IP της εικονικής μηχανής μας, οπότε ο Git θα απορρίψει τη σύνδεση HTTPS.
Εάν πρόκειται να γίνει μόνιμη εγκατάσταση, συμβουλευτούμε το εγχειρίδιο Perforce Git Fusion για να εγκαταστήσουμε ένα διαφορετικό πιστοποιητικό. για τους σκοπούς των παραδειγμάτων μας, αυτό αρκεί:

The next thing you'll need to do to follow along is to tell Git not to verify SSL certificates.
The Git Fusion image comes with a certificate, but it's for a domain that won't match your virtual machine's IP address, so Git will reject the HTTPS connection.
If this is going to be a permanent installation, consult the Perforce Git Fusion manual to install a different certificate; for our example purposes, this will suffice:

[source,console]
----
$ export GIT_SSL_NO_VERIFY=true
----

Τώρα μπορούμε να δοκιμάσουμε ότι όλα λειτουργούν.

[source,console]
----
$ git clone https://10.0.1.254/Talkhouse
Cloning into 'Talkhouse'...
Username for 'https://10.0.1.254': john
Password for 'https://john@10.0.1.254':
remote: Counting objects: 630, done.
remote: Compressing objects: 100% (581/581), done.
remote: Total 630 (delta 172), reused 0 (delta 0)
Receiving objects: 100% (630/630), 1.22 MiB | 0 bytes/s, done.
Resolving deltas: 100% (172/172), done.
Checking connectivity... done.
----

Η εικόνα εικονικής μηχανής έρχεται εξοπλισμένη με ένα δείγμα έργου που μπορούμε να κλωνοποιήσουμε.
Εδώ κλωνοποιούμε το HTTPS, με τον χρήστη `john` που δημιουργήσαμε παραπάνω. Το Git ζητά πιστοποιήσεις για αυτήν τη σύνδεση, αλλά η μνήμη cache των διαπιστευτηρίων θα μας επιτρέψει να παραλείψουμε αυτό το βήμα για τυχόν μεταγενέστερα αιτήματα.

The virtual-machine image comes equipped with a sample project that you can clone.
Here we're cloning over HTTPS, with the `john` user that we created above; Git asks for credentials for this connection, but the credential cache will allow us to skip this step for any subsequent requests.

====== Fusion Configuration

Μόλις εγκαταστήσουμε το Git Fusion, θα χρειαστεί να τροποποιήσουμε τη διαμόρφωση.
Αυτό είναι πραγματικά αρκετά εύκολο να κάνει χρησιμοποιώντας το αγαπημένο πελάτη Perforce μας? απλά χαρτογραφήστε τον κατάλογο `// .git-fusion` στον διακομιστή Perforce στον χώρο εργασίας μας.
Η δομή του αρχείου φαίνεται έτσι:

Once you've got Git Fusion installed, you'll want to tweak the configuration.
This is actually fairly easy to do using your favorite Perforce client; just map the `//.git-fusion` directory on the Perforce server into your workspace.
The file structure looks like this:

[source,console]
----
$ tree
.
├── objects
│   ├── repos
│   │   └── [...]
│   └── trees
│       └── [...]
│
├── p4gf_config
├── repos
│   └── Talkhouse
│       └── p4gf_config
└── users
    └── p4gf_usermap

498 directories, 287 files
----

Ο κατάλογος των αντικειμένων χρησιμοποιείται εσωτερικά από το Git Fusion για να χαρτογραφήσει τα αντικείμενα Perforce στο Git και το αντίστροφο, δεν θα χρειαστεί να χάσουμε τίποτα εκεί.
Υπάρχει ένα παγκόσμιο αρχείο `p4gf_config` σε αυτόν τον κατάλογο, καθώς και ένα για κάθε αποθετήριο - αυτά είναι τα αρχεία ρυθμίσεων που καθορίζουν τον τρόπο συμπεριφοράς του Git Fusion.
Ας ρίξουμε μια ματιά στο αρχείο στη ρίζα:

The `objects` directory is used internally by Git Fusion to map Perforce objects to Git and vice versa, you won't have to mess with anything in there.
There's a global `p4gf_config` file in this directory, as well as one for each repository – these are the configuration files that determine how Git Fusion behaves.
Let's take a look at the file in the root:

[source,ini]
----
[repo-creation]
charset = utf8

[git-to-perforce]
change-owner = author
enable-git-branch-creation = yes
enable-swarm-reviews = yes
enable-git-merge-commits = yes
enable-git-submodules = yes
preflight-commit = none
ignore-author-permissions = no
read-permission-check = none
git-merge-avoidance-after-change-num = 12107

[perforce-to-git]
http-url = none
ssh-url = none

[@features]
imports = False
chunked-push = False
matrix2 = False
parallel-push = False

[authentication]
email-case-sensitivity = no
----

Δεν θα πάμε εδώ στις σημασίες αυτών των σημαιών, αλλά σημειώστε ότι αυτό είναι μόνο ένα αρχείο κειμένου μορφοποιημένο σε μορφή INI, όπως ακριβώς χρησιμοποιεί η Git για τη διαμόρφωση.
Αυτό το αρχείο καθορίζει τις γενικές επιλογές, οι οποίες μπορούν στη συνέχεια να αντικατασταθούν από συγκεκριμένα αρχεία ρυθμίσεων αποθετηρίου, όπως `repos / Talkhouse / p4gf_config`.
Εάν ανοίξουμε αυτό το αρχείο, θα δούμε μια ενότητα `[@repo]` με ορισμένες ρυθμίσεις που διαφέρουν από τις καθολικές προεπιλογές.
Θα δούμε επίσης τμήματα που μοιάζουν με αυτά:

We won't go into the meanings of these flags here, but note that this is just an INI-formatted text file, much like Git uses for configuration.
This file specifies the global options, which can then be overridden by repository-specific configuration files, like `repos/Talkhouse/p4gf_config`.
If you open this file, you'll see a `[@repo]` section with some settings that are different from the global defaults.
You'll also see sections that look like this:

[source,ini]
----
[Talkhouse-master]
git-branch-name = master
view = //depot/Talkhouse/main-dev/... ...
----

Πρόκειται για χαρτογράφηση μεταξύ υποκαταστήματος Perforce και υποκαταστήματος Git.
Η ενότητα μπορεί να ονομαστεί ό, τι θέλουμε, αρκεί το όνομα να είναι μοναδικό.
`git-branch-name` μας επιτρέπει να μετατρέψουμε μια διαδρομή αποθήκης που θα ήταν περίπλοκη κάτω από το Git σε ένα πιο φιλικό όνομα.
Η ρύθμιση "προβολή" ελέγχει τον τρόπο χαρτογράφησης των αρχείων Perforce στο αποθετήριο Git χρησιμοποιώντας τη σύνταξη χαρτογράφησης τυπικής προβολής.
Μπορούν να καθοριστούν περισσότερες από μία χαρτογραφήσεις, όπως σε αυτό το παράδειγμα:

This is a mapping between a Perforce branch and a Git branch.
The section can be named whatever you like, so long as the name is unique.
`git-branch-name` lets you convert a depot path that would be cumbersome under Git to a more friendly name.
The `view` setting controls how Perforce files are mapped into the Git repository, using the standard view mapping syntax.
More than one mapping can be specified, like in this example:

[source,ini]
----
[multi-project-mapping]
git-branch-name = master
view = //depot/project1/main/... project1/...
       //depot/project2/mainline/... project2/...
----

Με αυτόν τον τρόπο, εάν η κανονική αντιστοίχιση του χώρου εργασίας μας περιλαμβάνει αλλαγές στη δομή των καταλόγων, μπορούμε να τις αναπαράγουμε με ένα αποθετήριο Git.

Το τελευταίο αρχείο που θα συζητήσουμε είναι `users / p4gf_usermap`, το οποίο χαρτώνει τους χρήστες Perforce στους χρήστες του Git και ίσως δεν χρειάζεται καν.
Κατά τη μετατροπή από μια σειρά αλλαγών Perforce σε μια υποβολή Git, η προεπιλεγμένη συμπεριφορά του Git Fusion είναι να αναζητήσει τον χρήστη Perforce και να χρησιμοποιήσει τη διεύθυνση ηλεκτρονικού ταχυδρομείου και το πλήρες όνομα που έχει αποθηκευτεί εκεί για το πεδίο συγγραφέα / εντολέα στο Git.
Κατά τη μετατροπή του άλλου τρόπου, η προεπιλογή είναι να αναζητήσουμε τον χρήστη Perforce με τη διεύθυνση ηλεκτρονικού ταχυδρομείου που είναι αποθηκευμένη στο πεδίο συγγραφέα της υποβολής Git και να υποβάλουμε το set changeset ως αυτόν τον χρήστη (με την εφαρμογή των δικαιωμάτων).
Στις περισσότερες περιπτώσεις, αυτή η συμπεριφορά θα κάνει μια χαρά, αλλά εξετάστε το ακόλουθο αρχείο χαρτογράφησης:

The last file we'll discuss is `users/p4gf_usermap`, which maps Perforce users to Git users, and which you may not even need.
When converting from a Perforce changeset to a Git commit, Git Fusion's default behavior is to look up the Perforce user, and use the email address and full name stored there for the author/committer field in Git.
When converting the other way, the default is to look up the Perforce user with the email address stored in the Git commit's author field, and submit the changeset as that user (with permissions applying).
In most cases, this behavior will do just fine, but consider the following mapping file:

[source]
----
john john@example.com "John Doe"
john johnny@appleseed.net "John Doe"
bob employeeX@example.com "Anon X. Mouse"
joe employeeY@example.com "Anon Y. Mouse"
----

Each line is of the format `<user> <email> "<full name>"`, and creates a single user mapping.
The first two lines map two distinct email addresses to the same Perforce user account.
This is useful if you've created Git commits under several different email addresses (or change email addresses), but want them to be mapped to the same Perforce user.
When creating a Git commit from a Perforce changeset, the first line matching the Perforce user is used for Git authorship information.

Κάθε γραμμή έχει τη μορφή `<user> <email>" <full name> "και δημιουργεί μία μόνο χαρτογράφηση χρήστη.
Οι δύο πρώτες γραμμές αντιστοιχούν δύο διαφορετικές διευθύνσεις ηλεκτρονικού ταχυδρομείου στον ίδιο λογαριασμό χρήστη Perforce.
Αυτό είναι χρήσιμο αν έχουμε δημιουργήσει υποβολές Git κάτω από πολλές διαφορετικές διευθύνσεις ηλεκτρονικού ταχυδρομείου (ή να αλλάξουμε διευθύνσεις ηλεκτρονικού ταχυδρομείου), αλλά θέλουμε να αντιστοιχιστούν στον ίδιο χρήστη Perforce.
Κατά τη δημιουργία μιας υποβολής Git από ένα σύνολο αλλαγών Perforce, η πρώτη γραμμή που ταιριάζει με τον χρήστη Perforce χρησιμοποιείται για τις πληροφορίες συγγραφέων Git.

Οι τελευταίες δύο γραμμές καλύπτουν τα πραγματικά ονόματα και τις διευθύνσεις ηλεκτρονικού ταχυδρομείου του Bob και του Joe από τις υποβολές του Git που δημιουργούνται.
Αυτό είναι ωραίο αν θέλουμε να ανοίξουμε ένα εσωτερικό έργο, αλλά δεν θέλουμε να δημοσιεύσουμε τον κατάλογο των υπαλλήλων μας σε ολόκληρο τον κόσμο.
Σημειώστε ότι οι διευθύνσεις ηλεκτρονικού ταχυδρομείου και τα πλήρη ονόματα θα πρέπει να είναι μοναδικά, εκτός αν θέλουμε όλες οι υποβολές του Git να αποδοθούν σε ένα μόνο φανταστικό συγγραφέα.

The last two lines mask Bob and Joe's actual names and email addresses from the Git commits that are created.
This is nice if you want to open-source an internal project, but don't want to publish your employee directory to the entire world.
Note that the email addresses and full names should be unique, unless you want all the Git commits to be attributed to a single fictional author.

====== Ροή εργασιών

Το Perforce Git Fusion είναι μια αμφίδρομη γέφυρα μεταξύ του ελέγχου της έκδοσης Perforce και Git.
Ας ρίξουμε μια ματιά στο πώς αισθάνεται να εργάζεται από την πλευρά του Git.
Υποθέτουμε ότι έχουμε χαρτογραφήσει το έργο `` Jam '' χρησιμοποιώντας ένα αρχείο διαμόρφωσης όπως φαίνεται παραπάνω, τον οποίο μπορούμε να κλωνοποιήσουμε ως εξής:

Perforce Git Fusion is a two-way bridge between Perforce and Git version control.
Let's have a look at how it feels to work from the Git side.
We'll assume we've mapped in the ``Jam'' project using a configuration file as shown above, which we can clone like this:

[source,console]
----
$ git clone https://10.0.1.254/Jam
Cloning into 'Jam'...
Username for 'https://10.0.1.254': john
Password for 'https://ben@10.0.1.254':
remote: Counting objects: 2070, done.
remote: Compressing objects: 100% (1704/1704), done.
Receiving objects: 100% (2070/2070), 1.21 MiB | 0 bytes/s, done.
remote: Total 2070 (delta 1242), reused 0 (delta 0)
Resolving deltas: 100% (1242/1242), done.
Checking connectivity... done.
$ git branch -a
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/master
  remotes/origin/rel2.1
$ git log --oneline --decorate --graph --all
* 0a38c33 (origin/rel2.1) Create Jam 2.1 release branch.
| * d254865 (HEAD, origin/master, origin/HEAD, master) Upgrade to latest metrowerks on Beos -- the Intel one.
| * bd2f54a Put in fix for jam's NT handle leak.
| * c0f29e7 Fix URL in a jam doc
| * cc644ac Radstone's lynx port.
[...]
----

Την πρώτη φορά που το κάνουμε αυτό, ίσως χρειαστεί λίγος χρόνος.
Αυτό που συμβαίνει είναι ότι το Git Fusion μετατρέπει όλες τις εφαρμοστέες αλλαγές στο ιστορικό Perforce σε Git υποβολές.
Αυτό συμβαίνει τοπικά στο διακομιστή, επομένως είναι σχετικά γρήγορο, αλλά αν έχουμε πολλή ιστορία, μπορεί να χρειαστεί λίγος χρόνος.
Οι μεταγενέστερες προσθήκες πραγματοποιούν αυξημένη μετατροπή, έτσι θα αισθανθούμε σαν τη μητρική ταχύτητα του Git.

The first time you do this, it may take some time.
What's happening is that Git Fusion is converting all the applicable changesets in the Perforce history into Git commits.
This happens locally on the server, so it's relatively fast, but if you have a lot of history, it can still take some time.
Subsequent fetches do incremental conversion, so it'll feel more like Git's native speed.

Όπως μπορούμε να δούμε, το αποθετήριό μας μοιάζει ακριβώς όπως οποιοδήποτε άλλο αποθετήριο Git με το οποίο μπορούμε να εργαστούμε.
Υπάρχουν τρία υποκαταστήματα και ο Git δημιούργησε ένα τοπικό υποκατάστημα «master» που εντοπίζει «προέλευση / κύριο».
Ας κάνουμε λίγο δουλειά και δημιουργούμε μερικές νέες υποβολές:

As you can see, our repository looks exactly like any other Git repository you might work with.
There are three branches, and Git has helpfully created a local `master` branch that tracks `origin/master`.
Let's do a bit of work, and create a couple of new commits:

[source,console]
----
# ...
$ git log --oneline --decorate --graph --all
* cfd46ab (HEAD, master) Add documentation for new feature
* a730d77 Whitespace
* d254865 (origin/master, origin/HEAD) Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]
----

Έχουμε δύο νέες υποβολές.
Τώρα ας ελέγξουμε αν κάποιος άλλος έχει δουλεψει:

[source,console]
----
$ git fetch
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 2), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://10.0.1.254/Jam
   d254865..6afeb15  master     -> origin/master
$ git log --oneline --decorate --graph --all
* 6afeb15 (origin/master, origin/HEAD) Update copyright
| * cfd46ab (HEAD, master) Add documentation for new feature
| * a730d77 Whitespace
|/
* d254865 Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]
----

Μοιάζει με κάποιον!
Δεν θα το γνωρίζατε από αυτήν την άποψη, αλλά η υποβολή `6afeb15` δημιουργήθηκε στην πραγματικότητα χρησιμοποιώντας έναν πελάτη Perforce.
Απλώς μοιάζει με μια άλλη υποβολή από την άποψη του Git, που είναι ακριβώς το σημείο.
Ας δούμε πώς αντιμετωπίζει ο διακομιστής Perforce μια υποβολή συγχώνευσης:

It looks like someone was!
You wouldn't know it from this view, but the `6afeb15` commit was actually created using a Perforce client.
It just looks like another commit from Git's point of view, which is exactly the point.
Let's see how the Perforce server deals with a merge commit:

[source,console]
----
$ git merge origin/master
Auto-merging README
Merge made by the 'recursive' strategy.
 README | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
$ git push
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (9/9), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 6), reused 0 (delta 0)
remote: Perforce: 100% (3/3) Loading commit tree into memory...
remote: Perforce: 100% (5/5) Finding child commits...
remote: Perforce: Running git fast-export...
remote: Perforce: 100% (3/3) Checking commits...
remote: Processing will continue even if connection is closed.
remote: Perforce: 100% (3/3) Copying changelists...
remote: Perforce: Submitting new Git commit objects to Perforce: 4
To https://10.0.1.254/Jam
   6afeb15..89cba2b  master -> master
----

Το Git νομίζει ότι λειτούργησε.
Ας ρίξουμε μια ματιά στο ιστορικό του αρχείου `README` από την άποψη της Perforce, χρησιμοποιώντας το χαρακτηριστικό γράφου αναθεώρησης του` p4v`:

Git thinks it worked.
Let's take a look at the history of the `README` file from Perforce's point of view, using the revision graph feature of `p4v`:

.Γράφημα αναθεώρησης Perforce που προκύπτει από ώθηση Git.
image::images/git-fusion-perforce-graph.png[Γράφημα αναθεώρησης Perforce που προκύπτει από ώθηση Git.]

Εάν δεν έχουμε δει ποτέ αυτήν την άποψη πριν, μπορεί να φαίνεται συγκεχυμένη, αλλά δείχνει τις ίδιες έννοιες με έναν γραφικό θεατή για την ιστορία του Git.
Εξετάζουμε την ιστορία του αρχείου `README`, έτσι ώστε το δέντρο καταλόγων στο πάνω αριστερό μέρος δείχνει μόνο αυτό το αρχείο καθώς επιτίθεται σε διάφορους κλάδους.
Στην επάνω δεξιά στήλη, έχουμε ένα οπτικό γράφημα για το πώς σχετίζονται οι διαφορετικές αναθεωρήσεις του αρχείου και η προβολή μεγάλης εικόνας αυτού του γραφήματος βρίσκεται στο κάτω δεξιά μέρος.
Η υπόλοιπη προβολή δίνεται στην προβολή λεπτομερειών για την επιλεγμένη αναθεώρηση ("2" σε αυτή την περίπτωση).

If you've never seen this view before, it may seem confusing, but it shows the same concepts as a graphical viewer for Git history.
We're looking at the history of the `README` file, so the directory tree at top left only shows that file as it surfaces in various branches.
At top right, we have a visual graph of how different revisions of the file are related, and the big-picture view of this graph is at bottom right.
The rest of the view is given to the details view for the selected revision (`2` in this case).

One thing to notice is that the graph looks exactly like the one in Git's history.
Perforce didn't have a named branch to store the `1` and `2` commits, so it made an ``anonymous'' branch in the `.git-fusion` directory to hold it.
This will also happen for named Git branches that don't correspond to a named Perforce branch (and you can later map them to a Perforce branch using the configuration file).

Ένα πράγμα που πρέπει να παρατηρήσουμε είναι ότι το γράφημα μοιάζει ακριβώς με το ιστορικό του Git.
Η Perforce δεν είχε όνομα υποκαταστήματος για να αποθηκεύσει τις υποβολές `1` και` 2`, έτσι έκανε ένα «ανώνυμο» κατάστημα στον κατάλογο `.git-fusion` για να το κρατήσει.
Αυτό θα συμβεί επίσης για τα ονόματα θυγατρικών Git που δεν αντιστοιχούν σε ένα όνομα κλάδο Perforce (και μπορούμε αργότερα να τα αντιστοιχίσουμε σε υποκατάστημα Perforce χρησιμοποιώντας το αρχείο διαμόρφωσης).

Τα περισσότερα από αυτά συμβαίνουν πίσω από τις σκηνές, αλλά το τελικό αποτέλεσμα είναι ότι ένα άτομο σε μια ομάδα μπορεί να χρησιμοποιεί το Git, άλλο μπορεί να χρησιμοποιεί το Perforce και κανένας από αυτούς δεν θα γνωρίζει την επιλογή του άλλου.

Most of this happens behind the scenes, but the end result is that one person on a team can be using Git, another can be using Perforce, and neither of them will know about the other's choice.

====== Ανακεφαλαίωση Git-Fusion

Εάν έχουμε (ή μπορούμε να αποκτήσουμε) πρόσβαση στο διακομιστή Perforce μας, το Git Fusion είναι ένας πολύ καλός τρόπος για να κάνουμε το Git και το Perforce να μιλάνε ο ένας στον άλλο.
Υπάρχουν κάποιες ρυθμίσεις, αλλά η καμπύλη μάθησης δεν είναι πολύ απότομη.
Αυτή είναι μία από τις λίγες ενότητες αυτού του κεφαλαίου όπου δεν θα εμφανιστούν προειδοποιήσεις σχετικά με τη χρήση της πλήρους ισχύος του Git.
Αυτό δεν σημαίνει ότι η Perforce θα είναι ευχαριστημένη από όλα όσα ρίχνουμε σε αυτήν - αν προσπαθήσουμε να ξαναγράψουμε την ιστορία που έχει ήδη ωθηθεί, η Git Fusion θα την απορρίψει - αλλά η Git Fusion προσπαθεί πολύ σκληρά να νιώσει τη μητρική της.
Μπορούμε ακόμα να χρησιμοποιήσουμε τα υποσύνολα Git (αν και θα φαίνονται περίεργα στους χρήστες Perforce) και να συγχωνεύσουμε κλάδους (αυτό θα καταγραφεί ως ενσωμάτωση στην πλευρά Perforce).

If you have (or can get) access to your Perforce server, Git Fusion is a great way to make Git and Perforce talk to each other.
There's a bit of configuration involved, but the learning curve isn't very steep.
This is one of the few sections in this chapter where cautions about using Git's full power will not appear.
That's not to say that Perforce will be happy with everything you throw at it – if you try to rewrite history that's already been pushed, Git Fusion will reject it – but Git Fusion tries very hard to feel native.
You can even use Git submodules (though they'll look strange to Perforce users), and merge branches (this will be recorded as an integration on the Perforce side).

Εάν δεν μπορούμε να πείσουμε τον διαχειριστή του διακομιστή μας να ρυθμίσει το Git Fusion, υπάρχει ακόμα ένας τρόπος να χρησιμοποιήσουμε αυτά τα εργαλεία μαζί.

If you can't convince the administrator of your server to set up Git Fusion, there is still a way to use these tools together.

===== Git-p4

(((εντολές git, p4)))
Το Git-p4 είναι μια αμφίδρομη γέφυρα μεταξύ Git και Perforce.
Τρέχει εξ ολοκλήρου μέσα στο αποθετήριο Git, επομένως δεν θα χρειαστεί κανενός είδους πρόσβαση στο διακομιστή Perforce (διαφορετικά από τα διαπιστευτήρια χρήστη, φυσικά).
Το Git-p4 δεν είναι τόσο ευέλικτο ούτε ολοκληρωμένο ως λύση όπως το Git Fusion, αλλά μας επιτρέπει να κάνουμε τα περισσότερα από όσα θέλουμε να κάνουμε χωρίς να εισχωρήσουμε στο περιβάλλον διακομιστή.

Git-p4 is a two-way bridge between Git and Perforce.
It runs entirely inside your Git repository, so you won't need any kind of access to the Perforce server (other than user credentials, of course).
Git-p4 isn't as flexible or complete a solution as Git Fusion, but it does allow you to do most of what you'd want to do without being invasive to the server environment.

[ΣΗΜΕΙΩΣΗ]
======
Θα χρειαστούμε το εργαλείο `p4` κάπου στο` PATH` για να εργαστούμε με το git-p4.
Από αυτή τη γραφή, είναι ελεύθερα διαθέσιμη στη διεύθυνση http://www.perforce.com/downloads/Perforce/20-User[].

You'll need the `p4` tool somewhere in your `PATH` to work with git-p4.
As of this writing, it is freely available at http://www.perforce.com/downloads/Perforce/20-User[].
======

====== Setting Up

For example purposes, we'll be running the Perforce server from the Git Fusion OVA as shown above, but we'll bypass the Git Fusion server and go directly to the Perforce version control.

Για παράδειγμα, θα τρέχουμε τον διακομιστή Perforce από το Git Fusion OVA, όπως φαίνεται παραπάνω, αλλά θα παρακάμψουμε το διακομιστή Git Fusion και θα πάμε κατευθείαν στον έλεγχο έκδοσης Perforce.

Για να χρησιμοποιήσουμε τον πελάτη γραμμής εντολών `p4` (από τον οποίο εξαρτάται το git-p4), θα χρειαστεί να ορίσουμε μερικές μεταβλητές περιβάλλοντος:

In order to use the `p4` command-line client (which git-p4 depends on), you'll need to set a couple of environment variables:

[source,console]
----
$ export P4PORT=10.0.1.254:1666
$ export P4USER=john
----

====== Getting Started

Όπως και με οτιδήποτε στο Git, η πρώτη εντολή είναι να κλωνοποιήσουμε:

As with anything in Git, the first command is to clone:

[source,console]
----
$ git p4 clone //depot/www/live www-shallow
Importing from //depot/www/live into www-shallow
Initialized empty Git repository in /private/tmp/www-shallow/.git/
Doing initial import of //depot/www/live/ from revision #head into refs/remotes/p4/master
----

This creates what in Git terms is a ``shallow'' clone; only the very latest Perforce revision is imported into Git; remember, Perforce isn't designed to give every revision to every user.
This is enough to use Git as a Perforce client, but for other purposes it's not enough.

Αυτό δημιουργεί ό, τι στους όρους Git είναι ένας «ρηχός» κλώνος. μόνο η τελευταία αναθεώρηση Perforce εισάγεται στο Git. θυμηθούμε, το Perforce δεν έχει σχεδιαστεί για να παρέχει κάθε αναθεώρηση σε κάθε χρήστη.
Αυτό αρκεί για να χρησιμοποιήσει το Git ως πελάτη Perforce, αλλά για άλλους σκοπούς δεν είναι αρκετό.

Μόλις τελειώσει, έχουμε έναν πλήρως λειτουργικό αποθετήριο Git:

Once it's finished, we have a fully-functional Git repository:

[source,console]
----
$ cd myproject
$ git log --oneline --all --graph --decorate
* 70eaf78 (HEAD, p4/master, p4/HEAD, master) Initial import of //depot/www/live/ from the state at revision #head
----

Σημειώστε πως υπάρχει ένα απομακρυσμένο `` p4 '' για το διακομιστή Perforce, αλλά όλα όσα μοιάζουν με έναν πρότυπο κλώνο.
Στην πραγματικότητα, αυτό είναι λίγο παραπλανητικό. δεν υπάρχει πραγματικά ένα απομακρυσμένο εκεί.

Note how there's a ``p4'' remote for the Perforce server, but everything else looks like a standard clone.
Actually, that's a bit misleading; there isn't actually a remote there.

[source,console]
----
$ git remote -v
----

Δεν υπάρχουν απομακρυσμένες μονάδες σε αυτήν την αποθήκη καθόλου.
Το Git-p4 δημιούργησε κάποιους λόγους ώστε να αντιπροσωπεύει την κατάσταση του διακομιστή και μοιάζουν με απομακρυσμένες αναφορές στο `git log`, αλλά δεν διαχειρίζονται από το ίδιο το Git και δεν μπορούμε να τους σπρώξουμε.

No remotes exist in this repository at all.
Git-p4 has created some refs to represent the state of the server, and they look like remote refs to `git log`, but they're not managed by Git itself, and you can't push to them.

====== Ροή εργασιών

Εντάξει, ας δουλέψουμε.
Ας υποθέσουμε ότι έχουμε σημειώσει κάποια πρόοδο σε ένα πολύ σημαντικό χαρακτηριστικό και είστε έτοιμοι να το δείξουμε στην υπόλοιπη ομάδα μας.

Okay, let's do some work.
Let's assume you've made some progress on a very important feature, and you're ready to show it to the rest of your team.

[source,console]
----
$ git log --oneline --all --graph --decorate
* 018467c (HEAD, master) Change page title
* c0fb617 Update link
* 70eaf78 (p4/master, p4/HEAD) Initial import of //depot/www/live/ from the state at revision #head
----

Έχουμε κάνει δύο νέες υποβολές ότι είμαστε έτοιμοι να υποβάλουμε στο διακομιστή Perforce.
Ας ελέγξουμε αν κάποιος άλλος δούλευε σήμερα:

We've made two new commits that we're ready to submit to the Perforce server.
Let's check if anyone else was working today:

[source,console]
----
$ git p4 sync
git p4 sync
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12142 (100%)
$ git log --oneline --all --graph --decorate
* 75cd059 (p4/master, p4/HEAD) Update copyright
| * 018467c (HEAD, master) Change page title
| * c0fb617 Update link
|/
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

Φαίνεται ότι ήταν, και οι «master» και «p4 / master» έχουν αποκλίνει.
Το σύστημα διακλάδωσης της Perforce δεν είναι όπως το Git, οπότε η υποβολή δεσμεύσεων συγχώνευσης δεν έχει νόημα.
Το Git-p4 συνιστά να αναδιοργανώσουμε τις υποβολές μας και έρχεται ακόμη και με μια συντόμευση για να το κάνουμε:

Looks like they were, and `master` and `p4/master` have diverged.
Perforce's branching system is _nothing_ like Git's, so submitting merge commits doesn't make any sense.
Git-p4 recommends that you rebase your commits, and even comes with a shortcut to do so:

[source,console]
----
$ git p4 rebase
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
No changes to import!
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
Applying: Update link
Applying: Change page title
 index.html | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
----

You can probably tell from the output, but `git p4 rebase` is a shortcut for `git p4 sync` followed by `git rebase p4/master`.
It's a bit smarter than that, especially when working with multiple branches, but this is a good approximation.

Μπορεί πιθανώς να το πούμε από την έξοδο, αλλά το `git p4 rebase` είναι μια συντόμευση για το` git p4 sync` ακολουθούμενη από `git rebase p4 / master`.
Είναι λίγο πιο έξυπνο από αυτό, ειδικά όταν εργάζεστε με πολλαπλούς κλάδους, αλλά αυτό είναι μια καλή προσέγγιση.

Τώρα η ιστορία μας είναι και πάλι γραμμική και είμαστε έτοιμοι να συνεισφέρουμε τις αλλαγές μας στο Perforce.
Η εντολή `git p4 submit` θα προσπαθήσει να δημιουργήσει μια νέα έκδοση Perforce για κάθε διαπραγμάτευση Git μεταξύ` p4 / master 'και `master'.
Το τρέξιμο μας πέφτει στον αγαπημένο μας επεξεργαστή και το περιεχόμενο του αρχείου μοιάζει με αυτό:

Now our history is linear again, and we're ready to contribute our changes back to Perforce.
The `git p4 submit` command will try to create a new Perforce revision for every Git commit between `p4/master` and `master`.
Running it drops us into our favorite editor, and the contents of the file look something like this:

[source,console]
----
# A Perforce Change Specification.
#
#  Change:      The change number. 'new' on a new changelist.
#  Date:        The date this specification was last modified.
#  Client:      The client on which the changelist was created.  Read-only.
#  User:        The user who created the changelist.
#  Status:      Either 'pending' or 'submitted'. Read-only.
#  Type:        Either 'public' or 'restricted'. Default is 'public'.
#  Description: Comments about the changelist.  Required.
#  Jobs:        What opened jobs are to be closed by this changelist.
#               You may delete jobs from this list.  (New changelists only.)
#  Files:       What opened files from the default changelist are to be added
#               to this changelist.  You may delete files from this list.
#               (New changelists only.)

Change:  new

Client:  john_bens-mbp_8487

User: john

Status:  new

Description:
   Update link

Files:
   //depot/www/live/index.html   # edit


######## git author ben@straub.cc does not match your p4 account.
######## Use option --preserve-user to modify authorship.
######## Variable git-p4.skipUserNameCheck hides this message.
######## everything below this line is just the diff #######
--- //depot/www/live/index.html  2014-08-31 18:26:05.000000000 0000
+++ /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/index.html   2014-08-31 18:26:05.000000000 0000
@@ -60,7 +60,7 @@
 </td>
 <td valign=top>
 Source and documentation for
-<a href="http://www.perforce.com/jam/jam.html">
+<a href="jam.html">
 Jam/MR</a>,
 a software build tool.
 </td>
----

This is mostly the same content you'd see by running `p4 submit`, except the stuff at the end which git-p4 has helpfully included.
Git-p4 tries to honor your Git and Perforce settings individually when it has to provide a name for a commit or changeset, but in some cases you want to override it.
For example, if the Git commit you're importing was written by a contributor who doesn't have a Perforce user account, you may still want the resulting changeset to look like they write it (and not you).

Αυτό είναι ως επί το πλείστον το ίδιο περιεχόμενο που θα βλέπατε τρέχοντας `p4 submit ', εκτός από τα πράγματα στο τέλος που git-p4 έχει συμπεριληφθεί.
Το Git-p4 προσπαθεί να τιμά τις ρυθμίσεις Git και Perforce ξεχωριστά όταν πρέπει να παράσχει ένα όνομα για μια υποβολή ή μια ομάδα αλλαγών, αλλά σε ορισμένες περιπτώσεις θέλουμε να το αντικαταστήσουμε.
Για παράδειγμα, εάν η υποβολή Git που εισάγουμε γράφτηκε από έναν συνεισφέροντα που δεν διαθέτει λογαριασμό χρήστη Perforce, ίσως θέλουμε τα προκύπτοντα changeset να μοιάζουν με αυτά που γράφουμε (και όχι εσείς).

Το Git-p4 εισήγαγε με προσοχή το μήνυμα από τη υποβολή Git ως το περιεχόμενο αυτής της δέσμης αλλαγών Perforce, οπότε το μόνο που έχουμε να κάνουμε είναι να αποθηκεύσουμε και να το κόψουμε δύο φορές (μία φορά για κάθε υποβολή).
Η προκύπτουσα έξοδος κελύφους θα φαίνεται κάπως έτσι:

Git-p4 has helpfully imported the message from the Git commit as the content for this Perforce changeset, so all we have to do is save and quit, twice (once for each commit).
The resulting shell output will look something like this:

[source,console]
----
$ git p4 submit
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Synchronizing p4 checkout...
... - file(s) up-to-date.
Applying dbac45b Update link
//depot/www/live/index.html#4 - opened for edit
Change 12143 created with 1 open file(s).
Submitting change 12143.
Locking 1 files ...
edit //depot/www/live/index.html#5
Change 12143 submitted.
Applying 905ec6a Change page title
//depot/www/live/index.html#5 - opened for edit
Change 12144 created with 1 open file(s).
Submitting change 12144.
Locking 1 files ...
edit //depot/www/live/index.html#6
Change 12144 submitted.
All commits applied!
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12144 (100%)
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
$ git log --oneline --all --graph --decorate
* 775a46f (HEAD, p4/master, p4/HEAD, master) Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

The result is as though we just did a `git push`, which is the closest analogy to what actually did happen.

Το αποτέλεσμα είναι σαν να κάναμε ένα `git push ', το οποίο είναι η πιο κοντινή αναλογία με αυτό που πραγματικά συνέβη.

Λάβουμε υπόψη ότι κατά τη διάρκεια αυτής της διαδικασίας, κάθε υποβολή Git μετατρέπεται σε ένα σύνολο αλλαγών Perforce. αν θέλουμε να τα καταρρίψουμε σε ένα ενιαίο σύνολο αλλαγών, μπορούμε να το κάνουμε αυτό με μια διαδραστική ανανέωση πριν τρέξουμε το `git p4 submit`.
Επίσης, σημειώστε ότι οι SHA-1 hashes όλων των δεσμεύσεων που υποβλήθηκαν ως changesets έχουν αλλάξει. αυτό συμβαίνει επειδή το git-p4 προσθέτει μια γραμμή στο τέλος κάθε υποβολής που μετατρέπει:

Note that during this process every Git commit is turned into a Perforce changeset; if you want to squash them down into a single changeset, you can do that with an interactive rebase before running `git p4 submit`.
Also note that the SHA-1 hashes of all the commits that were submitted as changesets have changed; this is because git-p4 adds a line to the end of each commit it converts:

[source,console]
----
$ git log -1
commit 775a46f630d8b46535fc9983cf3ebe6b9aa53145
Author: John Doe <john@example.com>
Date:   Sun Aug 31 10:31:44 2014 -0800

    Change page title

    [git-p4: depot-paths = "//depot/www/live/": change = 12144]
----

Τι θα συμβεί αν προσπαθήσουμε να υποβάλουμε μια υποβολή συγχώνευσης;
Ας το δοκιμάσουμε.
Ακολουθεί η κατάσταση στην οποία βρισκόμαστε:

What happens if you try to submit a merge commit?
Let's give it a try.
Here's the situation we've gotten ourselves into:

[source,console]
----
$ git log --oneline --all --graph --decorate
* 3be6fd8 (HEAD, master) Correct email address
*   1dcbf21 Merge remote-tracking branch 'p4/master'
|\
| * c4689fc (p4/master, p4/HEAD) Grammar fix
* | cbacd0a Table borders: yes please
* | b4959b6 Trademark
|/
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

Η ιστορία Git και Perforce αποκλίνει μετά από 775a46f.
Η πλευρά του Git έχει δύο υποβολές, στη συνέχεια μια συγχώνευση δεσμεύεται με το κεφάλι Perforce, έπειτα ένα άλλο commit.
Θα προσπαθήσουμε να τα υποβάλουμε στην κορυφή μιας ενιαίας ομάδας αλλαγών στην πλευρά Perforce.
Ας δούμε τι θα συμβεί αν προσπαθήσουμε να υποβάλουμε τώρα:

The Git and Perforce history diverge after 775a46f.
The Git side has two commits, then a merge commit with the Perforce head, then another commit.
We're going to try to submit these on top of a single changeset on the Perforce side.
Let's see what would happen if we tried to submit now:

[source,console]
----
$ git p4 submit -n
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would synchronize p4 checkout in /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would apply
  b4959b6 Trademark
  cbacd0a Table borders: yes please
  3be6fd8 Correct email address
----

Η σημαία `-n` είναι σύντομη για το` --dry-run`, το οποίο προσπαθεί να αναφέρει τι θα συνέβαινε εάν η εντολή υποβολής εκτελέστηκε για πραγματική.
Σε αυτήν την περίπτωση, φαίνεται ότι θα δημιουργούσαμε τρία σύνολα αλλαγών Perforce, τα οποία αντιστοιχούν στις τρεις υποβολές μη συγχώνευσης που δεν υπάρχουν ακόμα στον διακομιστή Perforce.
Αυτό ακούγεται ακριβώς όπως θέλουμε, ας δούμε πώς αποδεικνύεται:

The `-n` flag is short for `--dry-run`, which tries to report what would happen if the submit command were run for real.
In this case, it looks like we'd be creating three Perforce changesets, which correspond to the three non-merge commits that don't yet exist on the Perforce server.
That sounds like exactly what we want, let's see how it turns out:

[source,console]
----
$ git p4 submit
[…]
$ git log --oneline --all --graph --decorate
* dadbd89 (HEAD, p4/master, p4/HEAD, master) Correct email address
* 1b79a80 Table borders: yes please
* 0097235 Trademark
* c4689fc Grammar fix
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

Η ιστορία μας έγινε γραμμική, σαν να είχαμε ξεκαθαρίσει πριν υποβάλει (πράγμα που ακριβώς συνέβη ακριβώς).
Αυτό σημαίνει ότι μπορούμε να δημιουργήσουμε, να εργαστούμε, να πετάξουμε και να συγχωνεύσουμε κλάδους στην πλευρά του Git χωρίς φόβο ότι η ιστορία μας θα γίνει κάπως ασυμβίβαστη με την Perforce.
Εάν μπορούμε να το επαναβάλουμε, μπορούμε να το συμβάλλουμε σε ένα διακομιστή Perforce.

Our history became linear, just as though we had rebased before submitting (which is in fact exactly what happened).
This means you can be free to create, work on, throw away, and merge branches on the Git side without fear that your history will somehow become incompatible with Perforce.
If you can rebase it, you can contribute it to a Perforce server.

[[_git_p4_branches]]
====== Διακλάδωση

Εάν το έργο Perforce έχει πολλούς κλάδους, δεν είμαστε και τόσο άτυχοι. Η `git-p4` μπορεί να το χειριστεί με τρόπο που το κάνει να νιώθει σαν το Git.
Ας υποθέσουμε ότι η αποθήκη Perforce έχει ως εξής:

If your Perforce project has multiple branches, you're not out of luck; git-p4 can handle that in a way that makes it feel like Git.
Let's say your Perforce depot is laid out like this:

[source]
----
//depot
  └── project
      ├── main
      └── dev
----

Και ας πούμε ότι έχουμε έναν κλάδο `dev`, ο οποίος έχει ένα spec view που μοιάζει με αυτό:

And let's say you have a `dev` branch, which has a view spec that looks like this:

[source]
----
//depot/project/main/... //depot/project/dev/...
----

Το Git-p4 μπορεί να εντοπίσει αυτόματα την κατάσταση και να κάνει το σωστό:

Git-p4 can automatically detect that situation and do the right thing:

[source,console]
----
$ git p4 clone --detect-branches //depot/project@all
Importing from //depot/project@all into project
Initialized empty Git repository in /private/tmp/project/.git/
Importing revision 20 (50%)
    Importing new branch project/dev

    Resuming with change 20
Importing revision 22 (100%)
Updated branches: main dev
$ cd project; git log --oneline --all --graph --decorate
* eae77ae (HEAD, p4/master, p4/HEAD, master) main
| * 10d55fb (p4/project/dev) dev
| * a43cfae Populate //depot/project/main/... //depot/project/dev/....
|/
* 2b83451 Project init
----

Note the ``@all'' specifier in the depot path; that tells git-p4 to clone not just the latest changeset for that subtree, but all changesets that have ever touched those paths.
This is closer to Git's concept of a clone, but if you're working on a project with a long history, it could take a while.

Σημειώστε τον προδιαγραφέα `` @all '' στη διαδρομή αποθήκευσης. που λέει στο git-p4 να κλωνοποιήσει όχι μόνο το τελευταίο σύνολο αλλαγών για αυτό το δευτερεύον φύλλο, αλλά όλες τις αλλαγές που έχουν αγγίξει ποτέ αυτές τις διαδρομές.
Αυτό είναι πιο κοντά στην αντίληψη του Git για έναν κλώνο, αλλά αν εργάζεστε σε ένα έργο με μακρά ιστορία, θα μπορούσε να διαρκέσει λίγο.

Η σημαία `--detect-branches 'λέει στο git-p4 να χρησιμοποιήσει τις προδιαγραφές υποκαταστημάτων της Perforce για να χαρτογραφήσει τα υποκαταστήματα στο Git refs.
Εάν αυτές οι αντιστοιχίσεις δεν υπάρχουν στον εξυπηρετητή Perforce (ο οποίος είναι ένας απόλυτα έγκυρος τρόπος χρήσης του Perforce), μπορούμε να πούμε στο git-p4 ποιες είναι οι αντιστοιχίσεις κλάδων και έχουμε το ίδιο αποτέλεσμα:

The `--detect-branches` flag tells git-p4 to use Perforce's branch specs to map the branches to Git refs.
If these mappings aren't present on the Perforce server (which is a perfectly valid way to use Perforce), you can tell git-p4 what the branch mappings are, and you get the same result:

[source,console]
----
$ git init project
Initialized empty Git repository in /tmp/project/.git/
$ cd project
$ git config git-p4.branchList main:dev
$ git clone --detect-branches //depot/project@all .
----

Setting the `git-p4.branchList` configuration variable to `main:dev` tells git-p4 that ``main'' and ``dev'' are both branches, and the second one is a child of the first one.

Η ρύθμιση της μεταβλητής ρύθμισης `git-p4.branchList` στο` main: dev` λέει στο git-p4 ότι οι `` main '' και `` dev '' είναι και οι δύο κλάδοι και το δεύτερο είναι παιδί του πρώτου.

Αν τώρα βγάλουμε το check -b dev p4 / project / dev` και κάνουμε κάποιες υποβολές, το git-p4 είναι αρκετά έξυπνο για να στοχεύσει το δεξί υποκατάστημα όταν κάνουμε το `git p4 submit`.
Δυστυχώς, το git-p4 δεν μπορεί να αναμείξει ρηχικούς κλώνους και πολλαπλούς κλάδους. εάν έχουμε ένα τεράστιο έργο και θέλουμε να εργαστούμε σε περισσότερους από έναν κλάδους, θα πρέπει να «git p4 clone» μία φορά για κάθε υποκατάστημα στο οποίο θέλουμε να υποβάλουμε.

If we now `git checkout -b dev p4/project/dev` and make some commits, git-p4 is smart enough to target the right branch when we do `git p4 submit`.
Unfortunately, git-p4 can't mix shallow clones and multiple branches; if you have a huge project and want to work on more than one branch, you'll have to `git p4 clone` once for each branch you want to submit to.

Για τη δημιουργία ή την ενοποίηση υποκαταστημάτων, θα πρέπει να χρησιμοποιήσουμε έναν πελάτη Perforce.
Το Git-p4 μπορεί μόνο να συγχρονίζει και να υποβάλλεται σε υπάρχοντα υποκαταστήματα και μπορεί να το κάνει μόνο μία γραμμική αλλαγή ανά πάσα στιγμή.
Εάν συγχωνεύσουμε δύο υποκαταστήματα στο Git και προσπαθήσουμε να υποβάλουμε τη νέα σειρά αλλαγών, όλα αυτά που θα καταγραφούν είναι μια δέσμη αλλαγών αρχείων. τα μεταδεδομένα σχετικά με τους κλάδους που εμπλέκονται στην ολοκλήρωση θα χαθούν.

For creating or integrating branches, you'll have to use a Perforce client.
Git-p4 can only sync and submit to existing branches, and it can only do it one linear changeset at a time.
If you merge two branches in Git and try to submit the new changeset, all that will be recorded is a bunch of file changes; the metadata about which branches are involved in the integration will be lost.

===== Ανακεφαλαίωση Git και Perforce

Το Git-p4 καθιστά δυνατή τη χρήση μιας ροής εργασίας Git με ένα διακομιστή Perforce και είναι αρκετά καλό σε αυτό.
Ωστόσο, είναι σημαντικό να θυμάστε ότι η Perforce είναι υπεύθυνη για την πηγή και χρησιμοποιούμε μόνο Git για να εργαστούμε τοπικά.
Απλά να είστε πολύ προσεκτικοί σχετικά με την κοινή χρήση των δεσμεύσεων της Git. εάν διαθέτουμε ένα απομακρυσμένο από άλλους χρήστες, μην προωθούμε υποβολές που δεν έχουν ήδη υποβληθεί στο διακομιστή Perforce.

Git-p4 makes it possible to use a Git workflow with a Perforce server, and it's pretty good at it.
However, it's important to remember that Perforce is in charge of the source, and you're only using Git to work locally.
Just be really careful about sharing Git commits; if you have a remote that other people use, don't push any commits that haven't already been submitted to the Perforce server.

Αν θέλουμε να αναμίξουμε ελεύθερα τη χρήση του Perforce και του Git ως πελάτες για τον έλεγχο πηγής και μπορούμε να πείσουμε τον διαχειριστή του διακομιστή να το εγκαταστήσει, το Git Fusion κάνει χρήση του Git ως πελάτης ελέγχου έκδοσης πρώτης κατηγορίας για έναν διακομιστή Perforce.

If you want to freely mix the use of Perforce and Git as clients for source control, and you can convince the server administrator to install it, Git Fusion makes using Git a first-class version-control client for a Perforce server.
