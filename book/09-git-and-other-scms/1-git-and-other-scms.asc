== Git and Other Systems

The world isn't perfect.
Usually, you can't immediately switch every project you come in contact with to Git.
Sometimes you're stuck on a project using another VCS, and many times that system is Subversion.
You'll spend the first part of this chapter learning about `git svn`, the bidirectional Subversion gateway tool in Git.

At some point, you may want to convert your existing project to Git.
The second part of this chapter covers how to migrate your project into Git: first from Subversion, then from Perforce, and finally via a custom import script for a nonstandard importing case.

=== Git as a Client

(((Git as a client)))
Git provides such a nice experience for developers that many people have figured out how to use it on their workstation, even if the rest of their team is using an entirely different VCS.
There are a number of these adapters, called ``bridges,'' available.
Here we'll cover the ones you're most likely to run into in the wild.

==== Git and Subversion

(((Subversion)))(((Interoperation with other VCSs, Subversion)))
A large fraction of open source development projects and a good number of corporate projects use Subversion to manage their source code.
It's been around for more than a decade, and for most of that time was the _de facto_ VCS choice for open-source projects.
It's also very similar in many ways to CVS, which was the big boy of the source-control world before that.

(((git commands, svn)))(((git-svn)))
One of Git's great features is a bidirectional bridge to Subversion called `git svn`.
This tool allows you to use Git as a valid client to a Subversion server, so you can use all the local features of Git and then push to a Subversion server as if you were using Subversion locally.
This means you can do local branching and merging, use the staging area, use rebasing and cherry-picking, and so on, while your collaborators continue to work in their dark and ancient ways.
It's a good way to sneak Git into the corporate environment and help your fellow developers become more efficient while you lobby to get the infrastructure changed to support Git fully.
The Subversion bridge is the gateway drug to the DVCS world.

===== `git svn`

The base command in Git for all the Subversion bridging commands is `git svn`.
It takes quite a few commands, so we'll show the most common while going through a few simple workflows.

It's important to note that when you're using `git svn`, you're interacting with Subversion, which is a system that works very differently from Git.
Although you *can* do local branching and merging, it's generally best to keep your history as linear as possible by rebasing your work, and avoiding doing things like simultaneously interacting with a Git remote repository.

Don't rewrite your history and try to push again, and don't push to a parallel Git repository to collaborate with fellow Git developers at the same time.
Subversion can have only a single linear history, and confusing it is very easy.
If you're working with a team, and some are using SVN and others are using Git, make sure everyone is using the SVN server to collaborate – doing so will make your life easier.

===== Setting Up

To demonstrate this functionality, you need a typical SVN repository that you have write access to.
If you want to copy these examples, you'll have to make a writeable copy of my test repository.
In order to do that easily, you can use a tool called `svnsync` that comes with Subversion.
For these tests, I created a new Subversion repository on Google Code that was a partial copy of the `protobuf` project, which is a tool that encodes structured data for network transmission.

To follow along, you first need to create a new local Subversion repository:

[source,shell]
----
$ mkdir /tmp/test-svn
$ svnadmin create /tmp/test-svn
----

Then, enable all users to change revprops – the easy way is to add a `pre-revprop-change` script that always exits 0:

[source,shell]
----
$ cat /tmp/test-svn/hooks/pre-revprop-change
#!/bin/sh
exit 0;
$ chmod +x /tmp/test-svn/hooks/pre-revprop-change
----

You can now sync this project to your local machine by calling `svnsync init` with the to and from repositories.

[source,shell]
----
$ svnsync init file:///tmp/test-svn http://progit-example.googlecode.com/svn/
----

This sets up the properties to run the sync.
You can then clone the code by running

[source,shell]
----
$ svnsync sync file:///tmp/test-svn
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .............................[...]
Committed revision 2.
Copied properties for revision 2.
[…]
----

Although this operation may take only a few minutes, if you try to copy the original repository to another remote repository instead of a local one, the process will take nearly an hour, even though there are fewer than 100 commits.
Subversion has to clone one revision at a time and then push it back into another repository – it's ridiculously inefficient, but it's the only easy way to do this.

===== Getting Started

Now that you have a Subversion repository to which you have write access, you can go through a typical workflow.
You'll start with the `git svn clone` command, which imports an entire Subversion repository into a local Git repository.
Remember that if you're importing from a real hosted Subversion repository, you should replace the `file:///tmp/test-svn` here with the URL of your Subversion repository:

[source,shell]
----
$ git svn clone file:///tmp/test-svn -T trunk -b branches -t tags
Initialized empty Git repository in /private/tmp/progit/test-svn/.git/
r1 = dcbfb5891860124cc2e8cc616cded42624897125 (refs/remotes/origin/trunk)
	A	m4/acx_pthread.m4
	A	m4/stl_hash.m4
	A	java/src/test/java/com/google/protobuf/UnknownFieldSetTest.java
	A	java/src/test/java/com/google/protobuf/WireFormatTest.java
…
r75 = 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae (refs/remotes/origin/trunk)
Found possible branch point: file:///tmp/test-svn/trunk => file:///tmp/test-svn/branches/my-calc-branch, 75
Found branch parent: (refs/remotes/origin/my-calc-branch) 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae
Following parent with do_switch
Successfully followed parent
r76 = 0fb585761df569eaecd8146c71e58d70147460a2 (refs/remotes/origin/my-calc-branch)
Checked out HEAD:
  file:///tmp/test-svn/trunk r75
----

This runs the equivalent of two commands – `git svn init` followed by `git svn fetch` – on the URL you provide.
This can take a while.
The test project has only about 75 commits and the codebase isn't that big, but Git has to check out each version, one at a time, and commit it individually.
For a project with hundreds or thousands of commits, this can literally take hours or even days to finish.

The `-T trunk -b branches -t tags` part tells Git that this Subversion repository follows the basic branching and tagging conventions.
If you name your trunk, branches, or tags differently, you can change these options.
Because this is so common, you can replace this entire part with `-s`, which means standard layout and implies all those options.
The following command is equivalent:

[source,shell]
----
$ git svn clone file:///tmp/test-svn -s
----

At this point, you should have a valid Git repository that has imported your branches and tags:

[source,shell]
----
$ git branch -a
* master
  remotes/origin/my-calc-branch
  remotes/origin/tags/2.0.2
  remotes/origin/tags/release-2.0.1
  remotes/origin/tags/release-2.0.2
  remotes/origin/tags/release-2.0.2rc1
  remotes/origin/trunk
----

Note how this tool manages Subversion tags as remote refs.
(((git commands, show-ref)))
Let's take a closer look with the Git plumbing command `show-ref`:

[source,shell]
----
$ git show-ref
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/heads/master
0fb585761df569eaecd8146c71e58d70147460a2 refs/remotes/origin/my-calc-branch
bfd2d79303166789fc73af4046651a4b35c12f0b refs/remotes/origin/tags/2.0.2
285c2b2e36e467dd4d91c8e3c0c0e1750b3fe8ca refs/remotes/origin/tags/release-2.0.1
cbda99cb45d9abcb9793db1d4f70ae562a969f1e refs/remotes/origin/tags/release-2.0.2
a9f074aa89e826d6f9d30808ce5ae3ffe711feda refs/remotes/origin/tags/release-2.0.2rc1
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/remotes/origin/trunk
----

Git doesn't do this when it clones from a Git server; here's what a repository with tags looks like after a fresh clone:

[source,shell]
----
$ git show-ref
c3dcbe8488c6240392e8a5d7553bbffcb0f94ef0 refs/remotes/origin/master
32ef1d1c7cc8c603ab78416262cc421b80a8c2df refs/remotes/origin/branch-1
75f703a3580a9b81ead89fe1138e6da858c5ba18 refs/remotes/origin/branch-2
23f8588dde934e8f33c263c6d8359b2ae095f863 refs/tags/v0.1.0
7064938bd5e7ef47bfd79a685a62c1e2649e2ce7 refs/tags/v0.2.0
6dcb09b5b57875f334f61aebed695e2e4193db5e refs/tags/v1.0.0
----

Git fetches the tags directly into `refs/tags`, rather than treating them remote branches.

===== Committing Back to Subversion

Now that you have a working repository, you can do some work on the project and push your commits back upstream, using Git effectively as a SVN client.
If you edit one of the files and commit it, you have a commit that exists in Git locally that doesn't exist on the Subversion server:

[source,shell]
----
$ git commit -am 'Adding git-svn instructions to the README'
[master 4af61fd] Adding git-svn instructions to the README
 1 file changed, 5 insertions(+)
----

Next, you need to push your change upstream.
Notice how this changes the way you work with Subversion – you can do several commits offline and then push them all at once to the Subversion server.
To push to a Subversion server, you run the `git svn dcommit` command:

[source,shell]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
	M	README.txt
Committed r77
	M	README.txt
r77 = 95e0222ba6399739834380eb10afcd73e0670bc5 (refs/remotes/origin/trunk)
No changes between 4af61fd05045e07598c553167e0f31c84fd6ffe1 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk
----

This takes all the commits you've made on top of the Subversion server code, does a Subversion commit for each, and then rewrites your local Git commit to include a unique identifier.
This is important because it means that all the SHA-1 checksums for your commits change.
Partly for this reason, working with Git-based remote versions of your projects concurrently with a Subversion server isn't a good idea.
If you look at the last commit, you can see the new `git-svn-id` that was added:

[source,shell]
----
$ git log -1
commit 95e0222ba6399739834380eb10afcd73e0670bc5
Author: ben <ben@0b684db3-b064-4277-89d1-21af03df0a68>
Date:   Thu Jul 24 03:08:36 2014 +0000

    Adding git-svn instructions to the README

    git-svn-id: file:///tmp/test-svn/trunk@77 0b684db3-b064-4277-89d1-21af03df0a68
----

Notice that the SHA checksum that originally started with `4af61fd` when you committed now begins with `95e0222`.
If you want to push to both a Git server and a Subversion server, you have to push (`dcommit`) to the Subversion server first, because that action changes your commit data.

===== Pulling in New Changes

If you're working with other developers, then at some point one of you will push, and then the other one will try to push a change that conflicts.
That change will be rejected until you merge in their work.
In `git svn`, it looks like this:

[source,shell]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File '/trunk/README.txt' is out of date
W: d5837c4b461b7c0e018b49d12398769d2bfc240a and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 f414c433af0fd6734428cf9d2a9fd8ba00ada145 c80b6127dd04f5fcda218730ddf3a2da4eb39138 M	README.txt
Current branch master is up to date.
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.
----

To resolve this situation, you can run `git svn rebase`, which pulls down any changes on the server that you don't have yet and rebases any work you have on top of what is on the server:

[source,shell]
----
$ git svn rebase
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File '/trunk/README.txt' is out of date
W: eaa029d99f87c5c822c5c29039d19111ff32ef46 and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 65536c6e30d263495c17d781962cfff12422693a b34372b25ccf4945fe5658fa381b075045e7702a M	README.txt
First, rewinding head to replay your work on top of it...
Applying: update foo
Using index info to reconstruct a base tree...
M	README.txt
Falling back to patching base and 3-way merge...
Auto-merging README.txt
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.
----

Now, all your work is on top of what is on the Subversion server, so you can successfully `dcommit`:

[source,shell]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
	M	README.txt
Committed r85
	M	README.txt
r85 = 9c29704cc0bbbed7bd58160cfb66cb9191835cd8 (refs/remotes/origin/trunk)
No changes between 5762f56732a958d6cfda681b661d2a239cc53ef5 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk
----

Note that unlike Git, which requires you to merge upstream work you don't yet have locally before you can push, `git svn` makes you do that only if the changes conflict (much like how Subversion works).
If someone else pushes a change to one file and then you push a change to another file, your `dcommit` will work fine:

[source,shell]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
	M	configure.ac
Committed r87
	M	autogen.sh
r86 = d8450bab8a77228a644b7dc0e95977ffc61adff7 (refs/remotes/origin/trunk)
	M	configure.ac
r87 = f3653ea40cb4e26b6281cec102e35dcba1fe17c4 (refs/remotes/origin/trunk)
W: a0253d06732169107aa020390d9fefd2b1d92806 and refs/remotes/origin/trunk differ, using rebase:
:100755 100755 efa5a59965fbbb5b2b0a12890f1b351bb5493c18 e757b59a9439312d80d5d43bb65d4a7d0389ed6d M	autogen.sh
First, rewinding head to replay your work on top of it...
----

This is important to remember, because the outcome is a project state that didn't exist on either of your computers when you pushed.
If the changes are incompatible but don't conflict, you may get issues that are difficult to diagnose.
This is different than using a Git server – in Git, you can fully test the state on your client system before publishing it, whereas in SVN, you can't ever be certain that the states immediately before commit and after commit are identical.

You should also run this command to pull in changes from the Subversion server, even if you're not ready to commit yourself.
You can run `git svn fetch` to grab the new data, but `git svn rebase` does the fetch and then updates your local commits.

[source,shell]
----
$ git svn rebase
	M	autogen.sh
r88 = c9c5f83c64bd755368784b444bc7a0216cc1e17b (refs/remotes/origin/trunk)
First, rewinding head to replay your work on top of it...
Fast-forwarded master to refs/remotes/origin/trunk.
----

Running `git svn rebase` every once in a while makes sure your code is always up to date.
You need to be sure your working directory is clean when you run this, though.
If you have local changes, you must either stash your work or temporarily commit it before running `git svn rebase` – otherwise, the command will stop if it sees that the rebase will result in a merge conflict.

===== Git Branching Issues

When you've become comfortable with a Git workflow, you'll likely create topic branches, do work on them, and then merge them in.
If you're pushing to a Subversion server via `git svn`, you may want to rebase your work onto a single branch each time instead of merging branches together.
The reason to prefer rebasing is that Subversion has a linear history and doesn't deal with merges like Git does, so `git svn` follows only the first parent when converting the snapshots into Subversion commits.

Suppose your history looks like the following: you created an `experiment` branch, did two commits, and then merged them back into `master`.
When you `dcommit`, you see output like this:

[source,shell]
----
$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
	M	CHANGES.txt
Committed r89
	M	CHANGES.txt
r89 = 89d492c884ea7c834353563d5d913c6adf933981 (refs/remotes/origin/trunk)
	M	COPYING.txt
	M	INSTALL.txt
Committed r90
	M	INSTALL.txt
	M	COPYING.txt
r90 = cb522197870e61467473391799148f6721bcf9a0 (refs/remotes/origin/trunk)
No changes between 71af502c214ba13123992338569f4669877f55fd and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk
----

Running `dcommit` on a branch with merged history works fine, except that when you look at your Git project history, it hasn't rewritten either of the commits you made on the `experiment` branch – instead, all those changes appear in the SVN version of the single merge commit.

When someone else clones that work, all they see is the merge commit with all the work squashed into it, as though you ran `git merge --squash`; they don't see the commit data about where it came from or when it was committed.

===== Subversion Branching

Branching in Subversion isn't the same as branching in Git; if you can avoid using it much, that's probably best.
However, you can create and commit to branches in Subversion using git svn.

====== Creating a New SVN Branch

To create a new branch in Subversion, you run `git svn branch [branchname]`:

[source,shell]
----
$ git svn branch opera
Copying file:///tmp/test-svn/trunk at r90 to file:///tmp/test-svn/branches/opera...
Found possible branch point: file:///tmp/test-svn/trunk => file:///tmp/test-svn/branches/opera, 90
Found branch parent: (refs/remotes/origin/opera) cb522197870e61467473391799148f6721bcf9a0
Following parent with do_switch
Successfully followed parent
r91 = f1b64a3855d3c8dd84ee0ef10fa89d27f1584302 (refs/remotes/origin/opera)
----

This does the equivalent of the `svn copy trunk branches/opera` command in Subversion and operates on the Subversion server.
It's important to note that it doesn't check you out into that branch; if you commit at this point, that commit will go to `trunk` on the server, not `opera`.

===== Switching Active Branches

Git figures out what branch your dcommits go to by looking for the tip of any of your Subversion branches in your history – you should have only one, and it should be the last one with a `git-svn-id` in your current branch history.

If you want to work on more than one branch simultaneously, you can set up local branches to `dcommit` to specific Subversion branches by starting them at the imported Subversion commit for that branch.
If you want an `opera` branch that you can work on separately, you can run

[source,shell]
----
$ git branch opera remotes/origin/opera
----

Now, if you want to merge your `opera` branch into `trunk` (your `master` branch), you can do so with a normal `git merge`.
But you need to provide a descriptive commit message (via `-m`), or the merge will say ``Merge branch opera'' instead of something useful.

Remember that although you're using `git merge` to do this operation, and the merge likely will be much easier than it would be in Subversion (because Git will automatically detect the appropriate merge base for you), this isn't a normal Git merge commit.
You have to push this data back to a Subversion server that can't handle a commit that tracks more than one parent; so, after you push it up, it will look like a single commit that squashed in all the work of another branch under a single commit.
After you merge one branch into another, you can't easily go back and continue working on that branch, as you normally can in Git.
The `dcommit` command that you run erases any information that says what branch was merged in, so subsequent merge-base calculations will be wrong – the dcommit makes your `git merge` result look like you ran `git merge --squash`.
Unfortunately, there's no good way to avoid this situation – Subversion can't store this information, so you'll always be crippled by its limitations while you're using it as your server.
To avoid issues, you should delete the local branch (in this case, `opera`) after you merge it into trunk.

===== Subversion Commands

The `git svn` toolset provides a number of commands to help ease the transition to Git by providing some functionality that's similar to what you had in Subversion.
Here are a few commands that give you what Subversion used to.

====== SVN Style History

If you're used to Subversion and want to see your history in SVN output style, you can run `git svn log` to view your commit history in SVN formatting:

[source,shell]
----
$ git svn log
------------------------------------------------------------------------
r87 | schacon | 2014-05-02 16:07:37 -0700 (Sat, 02 May 2014) | 2 lines

autogen change

------------------------------------------------------------------------
r86 | schacon | 2014-05-02 16:00:21 -0700 (Sat, 02 May 2014) | 2 lines

Merge branch 'experiment'

------------------------------------------------------------------------
r85 | schacon | 2014-05-02 16:00:09 -0700 (Sat, 02 May 2014) | 2 lines

updated the changelog
----

You should know two important things about `git svn log`.
First, it works offline, unlike the real `svn log` command, which asks the Subversion server for the data.
Second, it only shows you commits that have been committed up to the Subversion server.
Local Git commits that you haven't dcommited don't show up; neither do commits that people have made to the Subversion server in the meantime.
It's more like the last known state of the commits on the Subversion server.

====== SVN Annotation

Much as the `git svn log` command simulates the `svn log` command offline, you can get the equivalent of `svn annotate` by running `git svn blame [FILE]`.
The output looks like this:

[source,shell]
----
$ git svn blame README.txt
 2   temporal Protocol Buffers - Google's data interchange format
 2   temporal Copyright 2008 Google Inc.
 2   temporal http://code.google.com/apis/protocolbuffers/
 2   temporal
22   temporal C++ Installation - Unix
22   temporal =======================
 2   temporal
79    schacon Committing in git-svn.
78    schacon
 2   temporal To build and install the C++ Protocol Buffer runtime and the Protocol
 2   temporal Buffer compiler (protoc) execute the following:
 2   temporal
----

Again, it doesn't show commits that you did locally in Git or that have been pushed to Subversion in the meantime.

====== SVN Server Information

You can also get the same sort of information that `svn info` gives you by running `git svn info`:

[source,shell]
----
$ git svn info
Path: .
URL: https://schacon-test.googlecode.com/svn/trunk
Repository Root: https://schacon-test.googlecode.com/svn
Repository UUID: 4c93b258-373f-11de-be05-5f7a86268029
Revision: 87
Node Kind: directory
Schedule: normal
Last Changed Author: schacon
Last Changed Rev: 87
Last Changed Date: 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009)
----

This is like `blame` and `log` in that it runs offline and is up to date only as of the last time you communicated with the Subversion server.

====== Ignoring What Subversion Ignores

If you clone a Subversion repository that has `svn:ignore` properties set anywhere, you'll likely want to set corresponding `.gitignore` files so you don't accidentally commit files that you shouldn't.
`git svn` has two commands to help with this issue.
The first is `git svn create-ignore`, which automatically creates corresponding `.gitignore` files for you so your next commit can include them.

The second command is `git svn show-ignore`, which prints to stdout the lines you need to put in a `.gitignore` file so you can redirect the output into your project exclude file:

[source,shell]
----
$ git svn show-ignore > .git/info/exclude
----

That way, you don't litter the project with `.gitignore` files.
This is a good option if you're the only Git user on a Subversion team, and your teammates don't want `.gitignore` files in the project.

===== Git-Svn Summary

The `git svn` tools are useful if you're stuck with a Subversion server, or are otherwise in a development environment that necessitates running a Subversion server.
You should consider it crippled Git, however, or you'll hit issues in translation that may confuse you and your collaborators.
To stay out of trouble, try to follow these guidelines:

* Keep a linear Git history that doesn't contain merge commits made by `git merge`.
  Rebase any work you do outside of your mainline branch back onto it; don't merge it in.
* Don't set up and collaborate on a separate Git server.
  Possibly have one to speed up clones for new developers, but don't push anything to it that doesn't have a `git-svn-id` entry.
  You may even want to add a `pre-receive` hook that checks each commit message for a `git-svn-id` and rejects pushes that contain commits without it.

If you follow those guidelines, working with a Subversion server can be more bearable.
However, if it's possible to move to a real Git server, doing so can gain your team a lot more.

==== Git and Mercurial

(((Interoperation with other VCSs, Mercurial)))
(((Mercurial)))
// TODO:
https://github.com/felipec/git-remote-hg[] is also `contrib/remote-helpers/git-remote-hg`

==== Git and Perforce

(((Interoperation with other VCSs, Perforce)))(((git commands, p4)))
(((Perforce)))
// TODO
`git-p4`: http://git-scm.com/docs/git-p4[]

==== Git and TFS

(((Interoperation with other VCSs, TFS)))
(((TFS)))((("TFVC", see="TFS")))
Git is becoming popular with Windows developers, and if you're writing code on Windows, there's a good chance you're using Microsoft's Team Foundation Server (TFS).
TFS is a collaboration suite that includes defect and work-item tracking, process support for Scrum and others, code review, and version control.
Here there's a bit of confusion ahead of you: TFS is the *server*, which supports controlling source code using both Git and their own custom VCS, which they've dubbed TFVC (Team Foundation Version Control).
Git support is a somewhat new feature (shipping with the 2013 version), so all of the tools that predate that refer to the version-control portion as ``TFS'', even though they're mostly working with TFVC.

If you find yourself on a team that's using TFVC but you'd rather use Git as your version-control client, there's a project for you.

===== Which Tool

(((git-tf)))(((git-tfs)))
In fact, there are two: git-tf and git-tfs.

Git-tfs (found at http://git-tfs.com/) is a .NET project, and (as of this writing) it only runs on Windows.
To work with Git repositories, it uses the .NET bindings for libgit2, a library-oriented implementation of Git which is highly performant and allows a lot of flexibility with the guts of a Git repository.
Libgit2 is not a complete implementation of Git, so to cover the difference git-tfs will actually call the command-line Git client for some operations, so there are no artificial limits on what it can do with Git repositories.
However, its support of TFS features is very mature, since it uses the Visual Studio assemblies for operations with servers (however, this means you need a version of Visual Studio installed that includes access to TFVC; as of this writing, none of the free-of-charve versions of Visual Studio can connect with a TFS server).

Git-tf (whose home is at https://gittf.codeplex.com/[]) is a Java project, and as such runs on most platforms that can support a Java runtime environment.
It interfaces with Git repositories through JGit (a JVM implementation of Git), which means it has virtually no limitations in terms of Git functions, but is limited in terms of TFS support.

We'll cover the basic usage of both tools in this book.

[NOTE]
====
You'll need access to a TFVC-based repository to follow along with these instructions.
These aren't as plentiful in the wild as Git or Subversion repositories, so you may need to create one of your own.
Codeplex (https://www.codeplex.com/[]) or Visual Studio Online (http://www.visualstudio.com/[]) are both good choices for this.
====


===== Getting Started: `git-tf`

The first thing you do, just as with any regular Git repository, is clone.
Here's what that looks like with `git-tf`

[source,shell]
----
$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main project_git
----

The first argument is the URL of a TFVC collection, the second is of the form `$/project/branch`, and the third is the path to the local Git repository that is to be created (this last one is optional).
Git-tf can only work with one branch at a time; if you want to make checkins on a different TFVC branch, you'll have to make a new clone from that branch.

This creates a fully functional Git repository:

[source,shell]
----
$ cd project_git
$ git log --all --oneline --decorate
512e75a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Checkin message
----

This is called a _shallow_ clone, meaning that only the latest changeset has been downloaded (see <<_shallow>> for more on shallow clones).
TFVC isn't designed for each client to have a full copy of the history, so git-tf defaults to only getting the latest version, which is much faster.

If you have some time, it's probably worth it to clone the entire project history, using the `--deep` option:

[source,shell]
----
$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main project_git --deep
Username: domain\user
Password:
Connecting to TFS...
Cloning $/myproject into /tmp/project_git: 100%, done.
Cloned 4 changesets. Cloned last changeset 35190 as d44b17a
$ cd project_git
$ git log --all --oneline --decorate
d44b17a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Goodbye
126aa7b (tag: TFS_C35189)
8f77431 (tag: TFS_C35178) FIRST
0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the Team Project Creation Wizard
----

Notice the tags with names like `TFS_C35189`; this is a feature that helps you know which Git commits are associated with TFVC changesets.
This is a nice way to represent it, since you can see with a simple log command which of your commits is associated with a snapshot that also exists in TFVC.
They aren't necessary (and in fact you can turn them off with `git config git-tf.tag false`) – git-tf keeps the real commit-changeset mappings in the `.git/git-tf` file.


===== Getting Started: `git-tfs`

Git-tfs cloning behaves slightly differently.
Observe:

[source,powershell]
----
PS> git tfs clone --with-branches https://username.visualstudio.com/DefaultCollection $/project/Trunk project_git
Initialized empty Git repository in C:/Users/ben/project_git/.git/
C15 = b75da1aba1ffb359d00e85c52acb261e4586b0c9
C16 = c403405f4989d73a2c3c119e79021cb2104ce44a
Tfs branches found:
- $/tfvc-test/featureA
The name of the local branch will be : featureA
C17 = d202b53f67bde32171d5078968c644e562f1c439
C18 = 44cd729d8df868a8be20438fdeeefb961958b674
----

Notice the `--with-branches` flag.
Git-tfs is capable of mapping TFVC branches to Git branches, and this flag tells it to set up alocal Git branch for every TFVC branch.
This is highly recommended if you've ever branched or merged in TFS, but it won't work with TFVC servers older than 2010 – before that release, ``branches'' were just folders, so git-tfs can't tell them from regular folders.

Let's take a look at the resulting Git repository:

[source,powershell]
----
PS> git log --oneline --graph --decorate --all
* 44cd729 (tfs/featureA, featureA) Goodbye
* d202b53 Branched from $/tfvc-test/Trunk
* c403405 (HEAD, tfs/default, master) Hello
* b75da1a New project
PS> git log
commit c403405f4989d73a2c3c119e79021cb2104ce44a
Author: Ben Straub <ben@straub.cc>
Date:   Fri Aug 1 03:41:59 2014 +0000

    Hello

    git-tfs-id: [https://username.visualstudio.com/DefaultCollection]$/myproject/Trunk;C16

commit b75da1aba1ffb359d00e85c52acb261e4586b0c9
Author: Ben Straub <ben@straub.cc>
Date:   Fri Aug 1 03:41:18 2014 +0000

    New project

    git-tfs-id: [https://username.visualstudio.com/DefaultCollection]$/myproject/Trunk;C15
----

There are two local branches, `master` and `featureA`, which represent the initial starting point of the clone (`Trunk` in TFVC) and a child branch (`featureA` in TFVC).
You can also see that the `tfs` ``remote'' has a couple of refs too: `default` and `featureA`, which represent TFVC branches.
Git-tfs maps the branch you cloned from to `tfs/default`, and others get their own names.

Another thing to notice is the `git-tfs-id:` lines in the commit messages.
Instead of tags, git-tfs uses these markers to relate TFVC changesets to Git commits.
This has the implication that your Git commits may have a different SHA-1 hash before and after they has been pushed to TFVC.

===== Git-tf[s] Workflow

[NOTE]
====
Regardless of which tool you're using, you should set a couple of Git configuration values for the interop repos to avoid running into issues.

[source,shell]
----
$ git config set --local core.ignorecase=true
$ git config set --local core.autocrlf=false
----
====

The obvious next thing you're going to want to do is work on the project.
TFVC and TFS have several features that may add complexity to your workflow:

. Feature branches that aren't represented in TFVC add a bit of complexity.
  This has to do with the *very* different ways that TFVC and Git represent branches.
. Be aware that TFVC allows users to ``checkout'' files from the server, locking them so nobody else can edit them.
  This obviously won't stop you from editing them in your local repo, but it could bite you when it comes time to push your changes up to the TFVC server.
. TFS has the concept of ``gated'' checkins, where a TFS build-test cycle has to complete successfully before the checkin is allowed.
  This uses the ``shelve'' function in TFVC, which we don't cover in detail here.
	You can fake this in a manual fashion with git-tf, and git-tfs provides the `checkintool` command which is gate-aware.

What we'll cover here is the happy path, which sidesteps or avoids most of these issues.

===== Workflow: `git-tf`


Let's say you've done some work, made a couple of Git commits on `master`, and you're ready to share your progress on the TFVC server.
Here's our Git repository:

[source,shell]
----
$ git log --oneline --graph --decorate --all
* 4178a82 (HEAD, master) update code
* 9df2ae3 update readme
* d44b17a (tag: TFS_C35190, origin_tfs/tfs) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the Team Project Creation Wizard
----

We want to take the snapshot that's in the `4178a82` commit and push it up to the TFVC server.
First things first: let's see if any of our teammates did anything since we last connected:

[source,shell]
----
$ git tf fetch
Username: domain\user
Password:
Connecting to TFS...
Fetching $/myproject at latest changeset: 100%, done.
Downloaded changeset 35320 as commit 8ef06a8. Updated FETCH_HEAD.
$ git log --oneline --graph --decorate --all
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
| * 4178a82 (HEAD, master) update code
| * 9df2ae3 update readme
|/
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the Team Project Creation Wizard
----

Looks like someone else is working, too, and now we have divergent history.
This is where Git shines, but we have two choices of how to proceed:

. Making a merge commit is fairly natural, but TFVC won't represent the history in the same way; eventually it'll have to be squashed down to one changeset.
	Git-tf can do this for you with a simple `git tf pull`.
. Rebasing makes our commit history linear again, which means we could turn each of our Git commits into a TFVC changeset.
  You can let git-tf do this for you with `git tf pull --rebase`.

The choice is yours.
For this example, we'll be rebasing:

[source,shell]
----
$ git rebase FETCH_HEAD
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
$ git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the Team Project Creation Wizard
----

Now we're ready to make a checkin to the TFVC server.
Git-tf gives you the choice of making a single changeset that represents all the changes since the last one (`--shallow`) and creating a new changeset for each Git commit (`--deep`).
For this example, we'll just create one:

[source,shell]
----
$ git tf checkin -m 'Updating readme and code'
Username: domain\user
Password:
Connecting to TFS...
Checking in to $/myproject: 100%, done.
Checked commit 5a0e25e in as changeset 35348
$
* 5a0e25e (HEAD, tag: TFS_C35348, origin_tfs/tfs, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the Team Project Creation Wizard
----

There's a new `TFS_C35348` tag, indicating that TFVC is storing the exact same snapshot as the `5a0e25e` commit.
It's important to note that not every Git commit needs to have an exact counterpart in TFVC; the `6eb3eb5` commit doesn't exist anywhere on the server.

That's the main workflow.
There are a couple other considerations you'll want to keep in mind:

* There is no branching.
  Git-tf can only create Git repositories from one TFVC branch at a time.
* Collaborate using either TFVC or Git, but not both.
  Different git-tf clones of the same TFVC repository may have different commit SHA hashes, which will cause no end of headaches.
	If you're using Git for collaboration, only publish to TFVC with one of the repositories.


===== Workflow: `git-tfs`

Let's walk through the same scenario using git-tfs.
First, let's look at the new commits we've made to the `master` branch in our Git repository:

[source,powershell]
----
PS> git log --oneline --graph --all --decorate
* c3bd3ae (HEAD, master) update code
* d85e5a2 update readme
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 (tfs/default) Hello
* b75da1a New project
----

Now let's see if anyone else has done work while we were hacking away:

[source,powershell]
----
PS> git tfs fetch
C19 = aea74a0313de0a391940c999e51c5c15c381d91d
PS> git log --all --oneline --graph --decorate
* aea74a0 (tfs/default) update documentation
| * c3bd3ae (HEAD, master) update code
| * d85e5a2 update readme
|/
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Yes, it turns out our coworker has added a new TFVC changeset, which shows up as the new `aea74a0` commit, and the `tfs/default` remote branch has moved.

As with git-tf, we have two fundamental options for how to resolve this divergent history:

. Rebase to preserve a linear history.
. Merge to preserve what actually happened.

In this case, we're going to do a ``deep'' checkin, where every Git commit becomes a TFVC changeset, so we want to rebase.

[source,powershell]
----
PS> git rebase tfs/default
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
PS> git log --all --oneline --graph --decorate
* 10a75ac (HEAD, master) update code
* 5cec4ab update readme
* aea74a0 (tfs/default) update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Now we're ready to complete our contribution by checking in our code to the TFVC server.
We'll use the `rcheckin` command here to create a TFVC changeset for each Git commit in the path from HEAD to the first `tfs` remote branch found (the `checkin` command would only create one changeset, sort of like squashing Git commits).

[source,powershell]
----
PS> git tfs rcheckin
Working with tfs remote: default
Fetching changes from TFS to minimize possibility of late conflict...
Starting checkin of 5cec4ab4 'update readme'
 add README.md
C20 = 71a5ddce274c19f8fdc322b4f165d93d89121017
Done with 5cec4ab4b213c354341f66c80cd650ab98dcf1ed, rebasing tail onto new TFS-commit...
Rebase done successfully.
Starting checkin of b1bf0f99 'update code'
 edit .git\tfs\default\workspace\ConsoleApplication1/ConsoleApplication1/Program.cs
C21 = ff04e7c35dfbe6a8f94e782bf5e0031cee8d103b
Done with b1bf0f9977b2d48bad611ed4a03d3738df05ea5d, rebasing tail onto new TFS-commit...
Rebase done successfully.
No more to rcheckin.
PS> git log --all --oneline --graph --decorate
* ff04e7c (HEAD, tfs/default, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Notice how after every successful checkin to the TFVC server, git-tfs is rebasing the remaining work onto what it just did.
That's because it's adding the `git-tfs-id` field to the bottom of the commit messages, which changes the SHA-1 hashes.
This is exactly as designed, and there's nothing to worry about, but you should be aware if you're sharing Git commits with others as well as TFVC changesets.

TFS actually exposes lots of extra stuff to your team, such as work items, designated reviewers, gated checkins, and so on.
It can be cumbersome to work with these features using only a command-line tool.
Fortunately, git-tfs lets you launch a graphical checkin tool very easily:

[source,powershell]
----
PS> git tfs checkintool
PS> git tfs ct
----

It looks a bit like this:

.The git-tfs checkin tool.
image::images/git-tfs-ct.png[The git-tfs checkin tool.]

Git-tfs also lets you control TFVC branches from your Git repository.
As an example, let's create one:

[source,powershell]
----
PS> git tfs branch $/tfvc-test/featureBee
The name of the local branch will be : featureBee
C26 = 1d54865c397608c004a2cadce7296f5edc22a7e5
PS> git lga
* 1d54865 (tfs/featureBee) Creation branch $/myproject/featureBee
* ff04e7c (HEAD, tfs/default, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Creating a branch in TFVC means creating a changeset where that branch now exists, and this is projected as a Git commit.
Note also that git-tfs *created* the `tfs/featureBee` remote branch, but `HEAD` is still pointing to `master`.
If you want to work on the newly-minted branch, you'll want to base your new commits on the `1d54865` commit, perhaps by creating a topic branch from that commit.


===== Git and TFS Summary

Git-tf and Git-tfs are both great tools for interfacing with a TFVC server.
They allow you to use the power of Git locally, avoid constantly having to round-trip to the central TFVC server, and make your live as a developer much easier, without forcing your entire team to migrate to Git.
If you're working on Windows (which is likely if your team is using TFS), you'll probably want to use git-tfs, since it's feature set is more complete; if you're working on another platform, you'll be using git-tf, which is more limited.

[[_migrating]]
=== Migrating to Git

(((Migrating to Git)))
If you have an existing codebase in another VCS but you've decided to start using Git, you must migrate your project one way or another.
This section goes over some importers that are included with Git for common systems and then demonstrates how to develop your own custom importer.

==== Importing

You'll learn how to import data from several of the bigger professionally used SCM systems, because they make up the majority of users who are currently switching, and because high-quality tools for them are easy to come by.

==== Subversion

(((Subversion)))
(((Importing, from Subversion)))
If you read the previous section about using `git svn`, you can easily use those instructions to `git svn clone` a repository; then, stop using the Subversion server, push to a new Git server, and start using that.
If you want the history, you can accomplish that as quickly as you can pull the data out of the Subversion server (which may take a while).

However, the import isn't perfect; and because it will take so long, you may as well do it right.
The first problem is the author information.
In Subversion, each person committing has a user on the system who is recorded in the commit information.
The examples in the previous section show `schacon` in some places, such as the `blame` output and the `git svn log`.
If you want to map this to better Git author data, you need a mapping from the Subversion users to the Git authors.
Create a file called `users.txt` that has this mapping in a format like this:

[source]
----
schacon = Scott Chacon <schacon@geemail.com>
selse = Someo Nelse <selse@geemail.com>
----

To get a list of the author names that SVN uses, you can run this:

[source,shell]
----
$ svn log --xml | grep author | sort -u | \
  perl -pe 's/.*>(.*?)<.*/$1 = /'
----

That gives you the log output in XML format – you can look for the authors, create a unique list, and then strip out the XML.
(Obviously this only works on a machine with `grep`, `sort`, and `perl` installed.)
Then, redirect that output into your users.txt file so you can add the equivalent Git user data next to each entry.

You can provide this file to `git svn` to help it map the author data more accurately.
You can also tell `git svn` not to include the metadata that Subversion normally imports, by passing `--no-metadata` to the `clone` or `init` command.
This makes your `import` command look like this:

[source,shell]
----
$ git-svn clone http://my-project.googlecode.com/svn/ \
      --authors-file=users.txt --no-metadata -s my_project
----

Now you should have a nicer Subversion import in your `my_project` directory.
Instead of commits that look like this

[source]
----
commit 37efa680e8473b615de980fa935944215428a35a
Author: schacon <schacon@4c93b258-373f-11de-be05-5f7a86268029>
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk

    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-
    be05-5f7a86268029
----

they look like this:

[source]
----
commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2
Author: Scott Chacon <schacon@geemail.com>
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk
----

Not only does the Author field look a lot better, but the `git-svn-id` is no longer there, either.

You need to do a bit of post-import cleanup.
For one thing, you should clean up the weird references that `git svn` set up.
First you'll move the tags so they're actual tags rather than strange remote branches, and then you'll move the rest of the branches so they're local.

To move the tags to be proper Git tags, run

[source,shell]
----
$ cp -Rf .git/refs/remotes/origin/tags/* .git/refs/tags/
$ rm -Rf .git/refs/remotes/origin/tags
----

This takes the references that were remote branches that started with `remotes/origin/tags/` and makes them real (lightweight) tags.

Next, move the rest of the references under `refs/remotes` to be local branches:

[source,shell]
----
$ cp -Rf .git/refs/remotes/* .git/refs/heads/
$ rm -Rf .git/refs/remotes
----

Now all the old branches are real Git branches and all the old tags are real Git tags.
The last thing to do is add your new Git server as a remote and push to it.
Here is an example of adding your server as a remote:

[source,shell]
----
$ git remote add origin git@my-git-server:myrepository.git
----

Because you want all your branches and tags to go up, you can now run this:

[source,shell]
----
$ git push origin --all
----

All your branches and tags should be on your new Git server in a nice, clean import.

==== Mercurial

// TODO
(((Mercurial)))(((Importing, from Mercurial)))

==== Perforce

(((Perforce)))(((Importing, from Perforce)))
The next system you'll look at importing from is Perforce.
As mentioned above, Git ships with a tool called `git-p4`, which acts as both a bidirectional bridge and as an import tool.

As an example, we'll import the Jam project from the Perforce Public Depot.
To set up your client, you must export the P4PORT environment variable to point to the Perforce depot:

[source,shell]
----
$ export P4PORT=public.perforce.com:1666
----

(((git commands, p4)))
Run the `git p4 clone` command to import the Jam project from the Perforce server, supplying the depot and project path and the path into which you want to import the project:

[source,shell]
----
$ git-p4 clone //public/jam/src@all p4import
Importing from //public/jam/src@all into p4import
Initialized empty Git repository in /private/tmp/p4import/.git/
Import destination: refs/remotes/p4/master
Importing revision 8068 (100%)
----

[NOTE]
======
You'll need the `p4` tool somewhere in your `PATH` for this to work.
As of this writing, it is freely available at http://www.perforce.com/downloads/Perforce/20-User[].
======


If you go to the `p4import` directory and run `git log`, you can see your imported work:

[source,shell]
----
$ git log -2
commit e5da1c909e5db3036475419f6379f2c73710c4e6
Author: giles <giles@giles@perforce.com>
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change </UL> to </OL>.

    [git-p4: depot-paths = "//public/jam/src/": change = 8068]

commit aa21359a0a135dda85c50a7f7cf249e4f7b8fd98
Author: kwirth <kwirth@perforce.com>
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -> cumulative).

    [git-p4: depot-paths = "//public/jam/src/": change = 7304]
----

You can see the `git-p4` identifier in each commit.
It's fine to keep that identifier there, in case you need to reference the Perforce change number later.
However, if you'd like to remove the identifier, now is the time to do so – before you start doing work on the new repository.
(((git commands, filter-branch)))
You can use `git filter-branch` to remove the identifier strings en masse:

[source,shell]
----
$ git filter-branch --msg-filter 'sed -e "/^\[git-p4:/d"'
Rewrite e5da1c909e5db3036475419f6379f2c73710c4e6 (125/125)
Ref 'refs/heads/master' was rewritten
----

If you run `git log`, you can see that all the SHA-1 checksums for the commits have changed, but the `git-p4` strings are no longer in the commit messages:

[source,shell]
----
$ git log -2
commit b17341801ed838d97f7800a54a6f9b95750839b7
Author: giles <giles@giles@perforce.com>
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change </UL> to </OL>.

commit 3e68c2e26cd89cb983eb52c024ecdfba1d6b3fff
Author: kwirth <kwirth@perforce.com>
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -> cumulative).
----

Your import is ready to push up to your new Git server.

==== TFS

// TODO
(((TFS)))(((Importing, from TFS)))
If your team is convering their source control from TFVC to Git, you'll want the highest-fidelity conversion you can get.
This means that, while we covered both git-tfs and git-tf for the interop section, we'll only be covering git-tfs for this part, because git-tfs supports branches, and this is prohibitively difficult using git-tf.

[NOTE]
====
This is a one-way conversion.
The resulting Git repository won't be able to connect with the original TFVC project.
====

The first thing to do is map usernames.
TFVC is fairly liberal with what goes into the author field for changesets, but Git wants a human-readable name and email address.
You can get this information from the `tf` command-line client, like so:

[source,powershell]
----
PS> tf history $/myproject -recursive | cut -b 11-20 | tail -n+3 | uniq | sort > AUTHORS
----

This grabs all of the changesets in the history of the project.
The `cut` command ignores everything except characters 11-20 from each line (you'll have to experiment with the length of the fields to get these numbers right).
The `tail` command skips the first two lines, which are field headers and ASCII-art underlines.
The result of all of this is piped to `uniq` to eliminate duplicates, and saved to a file named `AUTHORS`.
The next step is manual; in order for git-tfs to make effective use of this file, each line must be in this format:

[source,text]
----
DOMAIN\username = User Name <email@address.com>
----

The portion on the left is the ``User'' field from TFVC, and the portion on the right side of the equals sign is the user name that will be used for Git commits.

Once you have this file, the next thing to do is make a full clone of the TFVC project you're interested in:

[source,powershell]
----
PS> git tfs clone --with-branches --authors=AUTHORS https://username.visualstudio.com/DefaultCollection $/project/Trunk project_git
----

Next you'll want to clean the `git-tfs-id` sections from the bottom of the commit messages.
The following command will do that:

[source,powershell]
----
PS> git filter-branch -f --msg-filter 'sed "s/^git-tfs-id:.*$//g"' -- --all
----

That uses the `sed` command from the Git-bash environment to replace any line starting with ``git-tfs-id:'' with emptiness, which Git will then ignore.

Once that's all done, you're ready to add a new remote, push all your branches up, and have your team start working from Git.


==== A Custom Importer

(((git commands, fast-import)))
(((Importing, from others)))
If your system isn't Subversion or Perforce, you should look for an importer online – quality importers are available for CVS, Clear Case, Visual Source Safe, even a directory of archives.
If none of these tools works for you, you have a more obscure tool, or you otherwise need a more custom importing process, you should use `git fast-import`.
This command reads simple instructions from stdin to write specific Git data.
It's much easier to create Git objects this way than to run the raw Git commands or try to write the raw objects (see <<_git_internals>> for more information).
This way, you can write an import script that reads the necessary information out of the system you're importing from and prints straightforward instructions to stdout.
You can then run this program and pipe its output through `git fast-import`.

To quickly demonstrate, you'll write a simple importer.
Suppose you work in current, you back up your project by occasionally copying the directory into a time-stamped `back_YYYY_MM_DD` backup directory, and you want to import this into Git.
Your directory structure looks like this:

[source,shell]
----
$ ls /opt/import_from
back_2014_01_02
back_2014_01_04
back_2014_01_14
back_2014_02_03
current
----

In order to import a Git directory, you need to review how Git stores its data.
As you may remember, Git is fundamentally a linked list of commit objects that point to a snapshot of content.
All you have to do is tell `fast-import` what the content snapshots are, what commit data points to them, and the order they go in.
Your strategy will be to go through the snapshots one at a time and create commits with the contents of each directory, linking each commit back to the previous one.

As we did in <<_an_example_git_enforced_policy>>, we'll write this in Ruby, because it's what we generally work with and it tends to be easy to read.
You can write this example pretty easily in anything you're familiar with – it just needs to print the appropriate information to `stdout`.
And, if you are running on Windows, this means you'll need to take special care to not introduce carriage returns at the end your lines – git fast-import is very particular about just wanting line feeds (LF) not the carriage return line feeds (CRLF) that Windows uses.

To begin, you'll change into the target directory and identify every subdirectory, each of which is a snapshot that you want to import as a commit.
You'll change into each subdirectory and print the commands necessary to export it.
Your basic main loop looks like this:

[source,ruby]
----
last_mark = nil

# loop through the directories
Dir.chdir(ARGV[0]) do
  Dir.glob("*").each do |dir|
    next if File.file?(dir)

    # move into the target directory
    Dir.chdir(dir) do
      last_mark = print_export(dir, last_mark)
    end
  end
end
----

You run `print_export` inside each directory, which takes the manifest and mark of the previous snapshot and returns the manifest and mark of this one; that way, you can link them properly.
``Mark'' is the `fast-import` term for an identifier you give to a commit; as you create commits, you give each one a mark that you can use to link to it from other commits.
So, the first thing to do in your `print_export` method is generate a mark from the directory name:

[source,ruby]
----
mark = convert_dir_to_mark(dir)
----

You'll do this by creating an array of directories and using the index value as the mark, because a mark must be an integer.
Your method looks like this:

[source,ruby]
----
$marks = []
def convert_dir_to_mark(dir)
  if !$marks.include?(dir)
    $marks << dir
  end
  ($marks.index(dir) + 1).to_s
end
----

Now that you have an integer representation of your commit, you need a date for the commit metadata.
Because the date is expressed in the name of the directory, you'll parse it out.
The next line in your `print_export` file is

[source,ruby]
----
date = convert_dir_to_date(dir)
----

where `convert_dir_to_date` is defined as

[source,ruby]
----
def convert_dir_to_date(dir)
  if dir == 'current'
    return Time.now().to_i
  else
    dir = dir.gsub('back_', '')
    (year, month, day) = dir.split('_')
    return Time.local(year, month, day).to_i
  end
end
----

That returns an integer value for the date of each directory.
The last piece of meta-information you need for each commit is the committer data, which you hardcode in a global variable:

[source,ruby]
----
$author = 'John Doe <john@example.com>'
----

Now you're ready to begin printing out the commit data for your importer.
The initial information states that you're defining a commit object and what branch it's on, followed by the mark you've generated, the committer information and commit message, and then the previous commit, if any.
The code looks like this:

[source,ruby]
----
# print the import information
puts 'commit refs/heads/master'
puts 'mark :' + mark
puts "committer #{$author} #{date} -0700"
export_data('imported from ' + dir)
puts 'from :' + last_mark if last_mark
----

You hardcode the time zone (-0700) because doing so is easy.
If you're importing from another system, you must specify the time zone as an offset.
The commit message must be expressed in a special format:

[source]
----
data (size)\n(contents)
----

The format consists of the word data, the size of the data to be read, a newline, and finally the data.
Because you need to use the same format to specify the file contents later, you create a helper method, `export_data`:

[source,ruby]
----
def export_data(string)
  print "data #{string.size}\n#{string}"
end
----

All that's left is to specify the file contents for each snapshot.
This is easy, because you have each one in a directory – you can print out the `deleteall` command followed by the contents of each file in the directory.
Git will then record each snapshot appropriately:

[source,ruby]
----
puts 'deleteall'
Dir.glob("**/*").each do |file|
  next if !File.file?(file)
  inline_data(file)
end
----

Note:  Because many systems think of their revisions as changes from one commit to another, fast-import can also take commands with each commit to specify which files have been added, removed, or modified and what the new contents are.
You could calculate the differences between snapshots and provide only this data, but doing so is more complex – you may as well give Git all the data and let it figure it out.
If this is better suited to your data, check the `fast-import` man page for details about how to provide your data in this manner.

The format for listing the new file contents or specifying a modified file with the new contents is as follows:

[source]
----
M 644 inline path/to/file
data (size)
(file contents)
----

Here, 644 is the mode (if you have executable files, you need to detect and specify 755 instead), and inline says you'll list the contents immediately after this line.
Your `inline_data` method looks like this:

[source,ruby]
----
def inline_data(file, code = 'M', mode = '644')
  content = File.read(file)
  puts "#{code} #{mode} inline #{file}"
  export_data(content)
end
----

You reuse the `export_data` method you defined earlier, because it's the same as the way you specified your commit message data.

The last thing you need to do is to return the current mark so it can be passed to the next iteration:

[source,ruby]
----
return mark
----

[NOTE]
====
If you are running on Windows you'll need to make sure that you add one extra step.
As metioned before, Windows uses CRLF for new line characters while git fast-import expects only LF.
To get around this problem and make git fast-import happy, you need to tell ruby to use LF instead of CRLF:

[source,ruby]
----
$stdout.binmode
----
====

That's it.
Here's the script in its entirety:


[source,ruby]
----
#!/usr/bin/env ruby

$stdout.binmode
$author = "John Doe <john@example.com>"

$marks = []
def convert_dir_to_mark(dir)
	if !$marks.include?(dir)
		$marks << dir
	end
	($marks.index(dir)+1).to_s
end


def convert_dir_to_date(dir)
	if dir == 'current'
		return Time.now().to_i
	else
		dir = dir.gsub('back_', '')
		(year, month, day) = dir.split('_')
		return Time.local(year, month, day).to_i
	end
end

def export_data(string)
	print "data #{string.size}\n#{string}"
end

def inline_data(file, code='M', mode='644')
	content = File.read(file)
	puts "#{code} #{mode} inline #{file}"
	export_data(content)
end

def print_export(dir, last_mark)
	date = convert_dir_to_date(dir)
	mark = convert_dir_to_mark(dir)

	puts 'commit refs/heads/master'
	puts "mark :#{mark}"
	puts "committer #{$author} #{date} -0700"
	export_data("imported from #{dir}")
	puts "from :#{last_mark}" if last_mark

	puts 'deleteall'
	Dir.glob("**/*").each do |file|
		next if !File.file?(file)
		inline_data(file)
	end
	mark
end


# Loop through the directories
last_mark = nil
Dir.chdir(ARGV[0]) do
	Dir.glob("*").each do |dir|
		next if File.file?(dir)

		# move into the target directory
		Dir.chdir(dir) do
			last_mark = print_export(dir, last_mark)
		end
	end
end
----

If you run this script, you'll get content that looks something like this:

[source,shell]
----
$ ruby import.rb /opt/import_from
commit refs/heads/master
mark :1
committer John Doe <john@example.com> 1388649600 -0700
data 29
imported from back_2014_01_02deleteall
M 644 inline README.md
data 28
# Hello

This is my readme.
commit refs/heads/master
mark :2
committer John Doe <john@example.com> 1388822400 -0700
data 29
imported from back_2014_01_04from :1
deleteall
M 644 inline main.rb
data 34
#!/bin/env ruby

puts "Hey there"
M 644 inline README.md
(...)
----

To run the importer, pipe this output through `git fast-import` while in the Git directory you want to import into.
You can create a new directory and then run `git init` in it for a starting point, and then run your script:

[source,shell]
----
$ git init
Initialized empty Git repository in /opt/import_to/.git/
$ ruby import.rb /opt/import_from | git fast-import
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:       5000
Total objects:           13 (         6 duplicates                  )
      blobs  :            5 (         4 duplicates          3 deltas of          5 attempts)
      trees  :            4 (         1 duplicates          0 deltas of          4 attempts)
      commits:            4 (         1 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:           1 (         1 loads     )
      marks:           1024 (         5 unique    )
      atoms:              2
Memory total:          2344 KiB
       pools:          2110 KiB
     objects:           234 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =         10
pack_report: pack_mmap_calls          =          5
pack_report: pack_open_windows        =          2 /          2
pack_report: pack_mapped              =       1457 /       1457
---------------------------------------------------------------------
----

As you can see, when it completes successfully, it gives you a bunch of statistics about what it accomplished.
In this case, you imported 13 objects total for 4 commits into 1 branch.
Now, you can run `git log` to see your new history:

[source,shell]
----
$ git log -2
commit 3caa046d4aac682a55867132ccdfbe0d3fdee498
Author: John Doe <john@example.com>
Date:   Tue Jul 29 19:39:04 2014 -0700

    imported from current

commit 4afc2b945d0d3c8cd00556fbe2e8224569dc9def
Author: John Doe <john@example.com>
Date:   Mon Feb 3 01:00:00 2014 -0700

    imported from back_2014_02_03
----

There you go – a nice, clean Git repository.
It's important to note that nothing is checked out – you don't have any files in your working directory at first.
To get them, you must reset your branch to where `master` is now:

[source,shell]
----
$ ls
$ git reset --hard master
HEAD is now at 3caa046 imported from current
$ ls
README.md main.rb
----

You can do a lot more with the `fast-import` tool – handle different modes, binary data, multiple branches and merging, tags, progress indicators, and more.
A number of examples of more complex scenarios are available in the `contrib/fast-import` directory of the Git source code; one of the better ones is the `git-p4` script used above.

=== A Custom Credential Cache

// TODO
(((credential caches)))

=== Summary

You should feel comfortable using Git as a client for other version-control systems, or importing nearly any existing repository into a new Git one without losing data.
In the next chapter, we'll cover the raw internals of Git so you can craft every single byte, if need be.
