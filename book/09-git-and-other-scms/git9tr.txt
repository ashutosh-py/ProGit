CH 9 - Main file

== Git και άλλα συστήματα

Ο κόσμος δεν είναι τέλειος.
Συνήθως, δεν μπορείτε να αλλάξετε άμεσα κάθε έργο που έρχεστε σε επαφή με το Git.
Μερικές φορές είστε κολλημένοι σε ένα έργο που χρησιμοποιεί ένα άλλο VCS και επιθυμείτε να είναι το Git.
Θα αφιερώσουμε το πρώτο μέρος αυτού του κεφαλαίου για να μάθουμε τους τρόπους χρήσης του Git ως πελάτη όταν το έργο στο οποίο εργάζεστε φιλοξενείται σε διαφορετικό σύστημα.

Σε κάποιο σημείο, μπορεί να θέλετε να μετατρέψετε το υπάρχον έργο σας στο Git.
Το δεύτερο μέρος αυτού του κεφαλαίου καλύπτει τον τρόπο με τον οποίο μπορείτε να μεταφέρετε το έργο σας σε Git από διάφορα συγκεκριμένα συστήματα, καθώς και μια μέθοδο που θα λειτουργήσει εάν δεν υπάρχει κάποιο εργαλείο εισαγωγής που έχει κατασκευαστεί εκ των προτέρων.

=== Git ως πελάτης

((((Git ως πελάτης)))
Το Git προσφέρει μια τέτοια ωραία εμπειρία για τους προγραμματιστές ότι πολλοί άνθρωποι έχουν καταλάβει πώς να το χρησιμοποιήσουν στο σταθμό εργασίας τους, ακόμα κι αν η υπόλοιπη ομάδα τους χρησιμοποιεί ένα εντελώς διαφορετικό VCS.
Υπάρχουν ορισμένοι από αυτούς τους προσαρμογείς, που ονομάζονται `` γέφυρες ''.
Εδώ θα καλύψουμε εκείνα που είναι πιο πιθανό να συναντήσετε στη φύση.

περιλαμβάνουν :: τμήματα / client-svn.asc []

περιλαμβάνουν :: τμήματα / client-hg.asc []

περιλαμβάνουν :: τμήματα / client-p4.asc []

περιλαμβάνουν :: τμήματα / client-tfs.asc []

[[μεταναστεύει]]
=== Μετεγκατάσταση στο Git

(((Μετεγκατάσταση σε Git)))
Αν έχετε υπάρχον κωδικό σε άλλο VCS αλλά έχετε αποφασίσει να αρχίσετε να χρησιμοποιείτε το Git, πρέπει να μεταφέρετε το έργο σας με τον ένα ή τον άλλο τρόπο.
Αυτό το τμήμα αφορά ορισμένους εισαγωγείς για κοινά συστήματα και, στη συνέχεια, δείχνει πώς να αναπτύξετε το δικό σας έθιμο εισαγωγέα.
Θα μάθετε πώς μπορείτε να εισαγάγετε δεδομένα από πολλά από τα μεγαλύτερα επαγγελματικά χρησιμοποιούμενα συστήματα SCM, επειδή αποτελούν την πλειονότητα των χρηστών που μετακινούνται και επειδή τα εργαλεία υψηλής ποιότητας για αυτούς είναι εύκολο να έρθουν.

περιλαμβάνουν :: τμήματα / import-svn.asc []

include :: τμήματα / import-hg.asc []

περιλαμβάνουν :: τμήματα / import-p4.asc []

περιλαμβάνουν :: τμήματα / import-tfs.asc []

περιλαμβάνουν :: τμήματα / import-custom.asc []

=== Περίληψη

Θα πρέπει να αισθάνεστε άνετα χρησιμοποιώντας το Git ως πελάτη για άλλα συστήματα ελέγχου εκδόσεων ή να εισάγετε σχεδόν οποιοδήποτε υπάρχον αποθετήριο στο Git χωρίς να χάνετε δεδομένα.
Στο επόμενο κεφάλαιο, θα καλύψουμε τα ακατέργαστα εσωτερικά του Git έτσι ώστε να μπορέσετε να κατασκευάσετε κάθε byte, αν χρειαστεί.


Ενότητα 9.1.1.

[[_git_svn]]
==== Git και Subversion

(((Subversion)))) (((Διασύνδεση με άλλα VCS, Subversion)))
Ένα μεγάλο μέρος των αναπτυξιακών έργων ανοιχτού κώδικα και ένας μεγάλος αριθμός εταιρικών σχεδίων χρησιμοποιεί την Subversion για τη διαχείριση του πηγαίου κώδικα.
Έχει περάσει εδώ και πάνω από μια δεκαετία, και για το μεγαλύτερο μέρος της εποχής εκείνης υπήρξε η επιλογή της πραγματικής VCS για έργα ανοιχτού κώδικα.
Είναι επίσης πολύ παρόμοια με πολλούς τρόπους με το CVS, το οποίο ήταν το μεγάλο αγόρι του κόσμου ελέγχου πηγή πριν από αυτό.

(((git εντολές, svn))) (((git-svn)))
Ένα από τα εξαιρετικά χαρακτηριστικά του Git είναι μια αμφίδρομη γέφυρα για την Subversion που ονομάζεται `git svn`.
Αυτό το εργαλείο σάς επιτρέπει να χρησιμοποιείτε το Git ως έγκυρο πελάτη σε ένα διακομιστή Subversion, ώστε να μπορείτε να χρησιμοποιήσετε όλες τις τοπικές λειτουργίες του Git και στη συνέχεια να πιέσετε σε ένα διακομιστή Subversion σαν να χρησιμοποιούσατε το Subversion τοπικά.
Αυτό σημαίνει ότι μπορείτε να κάνετε τοπική διακλάδωση και συγχώνευση, να χρησιμοποιήσετε την περιοχή σταδιοποίησης, να χρησιμοποιήσετε την επαναχρησιμοποίηση και την επιλογή κερασιών κ.ο.κ., ενώ οι συνεργάτες σας συνεχίζουν να εργάζονται με τους σκοτεινούς και αρχαίους τρόπους.
Είναι ένας καλός τρόπος να γλιστρήσετε το Git στο εταιρικό περιβάλλον και να βοηθήσετε τους συνεργάτες σας να γίνουν πιο αποδοτικοί ενώ εσείς ασχολείστε για να αλλάξετε την υποδομή ώστε να υποστηρίξετε πλήρως το Git.
Η γέφυρα Subversion είναι το φάρμακο πύλης στον κόσμο DVCS.

===== 'git svn`

Η εντολή βάσης στο Git για όλες τις εντολές γεφύρωσης Subversion είναι `git svn`.
Χρειάζονται αρκετές εντολές, επομένως θα δείξουμε το πιο κοινό ενώ περνάμε μερικές απλές ροές εργασίας.

Είναι σημαντικό να σημειώσετε ότι όταν χρησιμοποιείτε το `git svn`, αλληλεπιδράτε με το Subversion, το οποίο είναι ένα σύστημα που λειτουργεί πολύ διαφορετικά από το Git.
Παρόλο που μπορείτε * να κάνετε τοπική διακλάδωση και συγχώνευση, είναι γενικά καλύτερα να διατηρήσετε το ιστορικό σας όσο το δυνατόν γραμμικό, ανανεώνοντας το έργο σας και αποφεύγοντας να κάνετε πράγματα όπως ταυτόχρονα αλληλεπιδρώντας με ένα απομακρυσμένο αποθετήριο Git.

Μην ξαναγράφετε το ιστορικό σας και προσπαθήστε να επαναφέρετε ξανά και μην πιέζετε σε ένα παράλληλο Git repository για να συνεργαστείτε με τους συνεργάτες προγραμματιστές της Git ταυτόχρονα.
Η υποτροπή μπορεί να έχει μόνο ένα γραμμικό ιστορικό και η σύγχυση είναι πολύ εύκολη.
Αν εργάζεστε με μια ομάδα και κάποιοι χρησιμοποιούν το SVN και άλλοι χρησιμοποιούν το Git, βεβαιωθείτε ότι όλοι χρησιμοποιούν το διακομιστή SVN για να συνεργαστούν - αυτό θα κάνει τη ζωή σας ευκολότερη.

===== Ρύθμιση

Για να επιδείξετε αυτή τη λειτουργικότητα, χρειάζεστε έναν τυπικό χώρο αποθήκευσης SVN στον οποίο έχετε πρόσβαση εγγραφής.
Αν θέλετε να αντιγράψετε αυτά τα παραδείγματα, θα πρέπει να δημιουργήσετε ένα αντίγραφο της δοκιμαστικής μου αποθήκης.
Για να γίνει αυτό εύκολα, μπορείτε να χρησιμοποιήσετε ένα εργαλείο που ονομάζεται `svnsync` που συνοδεύει το Subversion.
Για αυτές τις δοκιμές δημιουργήσαμε ένα νέο αποθετήριο Subversion στον κώδικα Google το οποίο ήταν ένα μερικό αντίγραφο του έργου `protobuf`, το οποίο είναι ένα εργαλείο που κωδικοποιεί δομημένα δεδομένα για μετάδοση δικτύου.

Για να ακολουθήσετε, πρέπει πρώτα να δημιουργήσετε ένα νέο τοπικό αποθετήριο Subversion:

[πηγή, κονσόλα]
----
$ mkdir / tmp / test-svn
$ svnadmin δημιουργία / tmp / test-svn
----

Στη συνέχεια, επιτρέψτε σε όλους τους χρήστες να αλλάξουν revprops - ο εύκολος τρόπος είναι να προσθέσετε ένα σενάριο `pre-revprop-change` που πάντα βγαίνει από 0:

[πηγή, κονσόλα]
----
$ cat / tmp / test-svn / άγκιστρα / προ-αναθεώρηση-αλλαγή
#! / bin / sh
έξοδος 0?
$ chmod + x / tmp / test-svn / άγκιστρα / προ-αναθεώρηση αλλαγής
----

Τώρα μπορείτε να συγχρονίσετε αυτό το έργο με το τοπικό σας μηχάνημα καλώντας το `svnsync init` με τα από και προς τα αποθετήρια.

[πηγή, κονσόλα]
----
$ svnsync αρχείο init: /// tmp / test-svn \
  http://progit-example.googlecode.com/svn/
----

Αυτό ρυθμίζει τις ιδιότητες για την εκτέλεση του συγχρονισμού.
Στη συνέχεια, μπορείτε να κλωνοποιήσετε τον κώδικα εκτελώντας

[πηγή, κονσόλα]
----
$ svnsync αρχείο συγχρονισμού: /// tmp / test-svn
Αναληφθείσα αναθεώρηση 1.
Αντιγραφείσες ιδιότητες για αναθεώρηση 1.
Αποστολή δεδομένων αρχείου ............................. [...]
Αναληφθείσα αναθεώρηση 2.
Αντιγραφείσες ιδιότητες για αναθεώρηση 2.
[...]
----

Παρόλο που η λειτουργία αυτή μπορεί να διαρκέσει μόνο λίγα λεπτά, αν προσπαθήσετε να αντιγράψετε τον αρχικό χώρο αποθήκευσης σε άλλο απομακρυσμένο αποθετήριο αντί για ένα τοπικό αποθετήριο, η διαδικασία θα διαρκέσει περίπου μία ώρα, παρότι υπάρχουν λιγότερες από 100 δεσμεύσεις.
Η υποτροπή πρέπει να κλωνοποιήσει μια αναθεώρηση κάθε φορά και στη συνέχεια να την ωθήσει ξανά σε άλλο αποθετήριο - είναι γελοία ανεπαρκής, αλλά είναι ο μόνος εύκολος τρόπος για να το κάνετε αυτό.

===== Ξεκινώντας

Τώρα που έχετε ένα αποθετήριο Subversion στο οποίο έχετε πρόσβαση εγγραφής, μπορείτε να περάσετε από μια τυπική ροή εργασιών.
Θα ξεκινήσετε με την εντολή `git svn clone`, η οποία εισάγει ένα ολόκληρο αποθετήριο Subversion σε ένα τοπικό αποθετήριο Git.
Θυμηθείτε ότι αν εισάγετε από ένα πραγματικό φιλοξενούμενο υποκατάστημα Subversion, θα πρέπει να αντικαταστήσετε εδώ το `file: /// tmp / test-svn` με τη διεύθυνση URL του αποθετηρίου Subversion:

[πηγή, κονσόλα]
----
$ git svn αρχείο κλώνου: /// tmp / test-svn -T trunk -b κλάσεις -t ετικέτες
Αρχικό κενό αποθετήριο Git στο /private/tmp/progit/test-svn/.git/
r1 = dcbfb5891860124cc2e8cc616cded42624897125 (refs / remotes / προέλευση / κορμός)
    Ένα m4 / acx_pthread.m4
    Μ4 / stl_hash.m4
    Ένα αρχείο java / src / test / java / com / google / protobuf / UnknownFieldSetTest.java
    Ένα αρχείο java / src / test / java / com / google / protobuf / WireFormatTest.java
...
r75 = 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae (refs / remotes / προέλευση / t
Παρακολουθήσατε με επιτυχία τον γονέα
r76 = 0fb585761df569eaecd8146c71e58d70147460a2 (refs / remotes / προέλευση / my-calc-υποκατάστημα)
Έλεγχος HEAD:
  αρχείο: / / tmp / test-svn / trunk r75
----

Αυτό εκτελεί το ισοδύναμο δύο εντολών - `git svn init` ακολουθούμενη από` git svn fetch` - στη διεύθυνση URL που παρέχετε.
Αυτό μπορεί να διαρκέσει λίγο.
Το δοκιμαστικό έργο έχει μόνο περίπου 75 δεσμεύσεις και το codebase δεν είναι τόσο μεγάλο, αλλά το Git πρέπει να ελέγχει κάθε έκδοση, ένα κάθε φορά, και να το δεσμεύει ξεχωριστά.
Για ένα έργο με εκατοντάδες ή χιλιάδες δεσμεύσεις, αυτό μπορεί να πάρει κυριολεκτικά ώρες ή ακόμα και ημέρες για να τελειώσει.

Το τμήμα -T κορμού -b κλάδους -t ετικετών "λέει στο Git ότι αυτό το αποθετήριο Subversion ακολουθεί τις βασικές συμβάσεις διακλάδωσης και σήμανσης.
Εάν ονομάσετε διαφορετικά τον κορμό, τα υποκαταστήματα ή τις ετικέτες, μπορείτε να αλλάξετε αυτές τις επιλογές.
Επειδή αυτό είναι τόσο συνηθισμένο, μπορείτε να αντικαταστήσετε ολόκληρο αυτό το τμήμα με `-s`, που σημαίνει τυποποιημένη διάταξη και υπονοεί όλες αυτές τις επιλογές.
Η ακόλουθη εντολή είναι ισοδύναμη:

[πηγή, κονσόλα]
----
$ git svn αρχείο κλώνου: /// tmp / test-svn -s
----

Σε αυτό το σημείο, θα πρέπει να έχετε έναν έγκυρο αποθετήριο Git που έχει εισαγάγει τα υποκαταστήματα και τις ετικέτες σας:

[πηγή, κονσόλα]
----
Υποκατάστημα $ git -a
* πλοίαρχος
  remotes / προέλευση / my-calc-υποκατάστημα
  απομακρυσμένα / προέλευση / ετικέτες / 2.0.2
  απομακρυσμένα / προέλευση / ετικέτες / απελευθέρωση-2.0.1
  απομακρυσμένα / προέλευση / ετικέτες / απελευθέρωση-2.0.2
  remotes / προέλευση / ετικέτες / release-2.0.2rc1
  τηλεχειριστήρια / προέλευση / κορμό
----

Σημειώστε πώς το εργαλείο διαχειρίζεται τις ετικέτες Subversion ως remote refs.
(((εντολές git, show-ref)))
Ας ρίξουμε μια πιο προσεκτική ματιά με την εντολή `show-ref` της υδραυλικής εγκατάστασης Git:

[πηγή, κονσόλα]
----
$ git show-ref
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs / κεφάλια / κύρια
0fb585761df569eaecd8146c71e58d70147460a2 refs / απομακρυσμένες / προέλευση / my-calc-branch
bfd2d79303166789fc73af4046651a4b35c12f0b refs / remotes / προέλευση / ετικέτες / 2.0.2
285c2b2e36e467dd4d91c8e3c0c0e1750b3fe8ca refs / remotes / προέλευση / ετικέτες / release-2.0.1
cbda99cb45d9abcb9793db1d4f70ae562a969f1e refs / remotes / προέλευση / ετικέτες / release-2.0.2
a9f074aa89e826d6f9d30808ce5ae3ffe711feda refs / remotes / προέλευση / ετικέτες / release-2.0.2rc1
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs / remotes / προέλευση / κορμός
----

Το Git δεν το κάνει αυτό όταν κλωνοποιεί από ένα διακομιστή Git. εδώ είναι τι φαίνεται ένα αποθετήριο με ετικέτες μετά από έναν νέο κλώνο:

[πηγή, κονσόλα]
----
$ git show-ref
c3dcbe8488c6240392e8a5d7553bbffcb0f94ef0 refs / remotes / προέλευση / κύριο
32ef1d1c7cc8c603ab78416262cc421b80a8c2df αναφορές / απομακρυσμένα / προέλευση / κλάδος-1
75f703a3580a9b81ead89fe1138e6da858c5ba18 refs / remotes / προέλευση / κλάδος-2
23f8588dde934e8f33c263c6d8359b2ae095f863 refs / tags / v0.1.0
7064938bd5e7ef47bfd79a685a62c1e2649e2ce7 refs / tags / v0.2.0
6dcb09b5b57875f334f61aebed695e2e4193db5e refs / tags / v1.0.0
----

Το Git μεταφέρει τις ετικέτες κατευθείαν στο φάκελο `refs / tags ', αντί να τις επεξεργάζεται απομακρυσμένους κλάδους.

===== Δέσμευση Επιστροφή στην Subversion

Τώρα που έχετε ένα αποθετήριο εργασίας, μπορείτε να κάνετε κάποια εργασία στο έργο και να προωθήσετε τις δεσμεύσεις σας προς τα πάνω, χρησιμοποιώντας το Git αποτελεσματικά ως πελάτη SVN.
Εάν επεξεργαστείτε ένα από τα αρχεία και το δεσμεύσετε, έχετε μια δέσμευση που υπάρχει στο Git τοπικά που δεν υπάρχει στο διακομιστή Subversion:

[πηγή, κονσόλα]
----
$ git commit -am 'Προσθήκη εντολών git-svn στο README'
[master 4af61fd] Προσθήκη οδηγιών git-svn στο README
 1 αρχείο άλλαξε, 5 εισαγωγές (+)
----

Στη συνέχεια, πρέπει να ωθήσετε την αλλαγή σας προς τα πάνω.
Παρατηρήστε πώς αλλάζει ο τρόπος με τον οποίο εργάζεστε με το Subversion - μπορείτε να εκτελέσετε αρκετές δεσμεύσεις χωρίς σύνδεση και, στη συνέχεια, να τις μετακινήσετε ταυτόχρονα στο διακομιστή Subversion.
Για να πιέσετε σε ένα διακομιστή Subversion, εκτελείτε την εντολή `git svn dcommit`:

[πηγή, κονσόλα]
----
$ git svn dcommit
Δεσμευόμενη στο αρχείο: /// tmp / test-svn / trunk ...
    M README.txt
Δέσμευσε r77
    M README.txt
r77 = 95e0222ba6399739834380eb10afcd73e0670bc5 (refs / remotes / προέλευση / κορμός)
Δεν υπάρχουν αλλαγές μεταξύ του 4af61fd05045e07598c553167e0f31c84fd6ffe1 και του refs / remotes / origination / trunk
Επαναφορά στις τελευταίες συσκευές refs / remotes / origination / trunk
----

Αυτό λαμβάνει όλες τις δεσμεύσεις που κάνατε πάνω από τον κώδικα του διακομιστή Subversion, πραγματοποιείτε μια δέσμευση Subversion για κάθε μία και μετά ξαναγράφετε την τοπική σας δέσμευση Git για να συμπεριλάβετε ένα μοναδικό αναγνωριστικό.
Αυτό είναι σημαντικό επειδή σημαίνει ότι όλα τα SHA-1 checksum για τις δεσμεύσεις σας αλλάζουν.
Εν μέρει για αυτό το λόγο, η συνεργασία με τις απομακρυσμένες εκδόσεις Git που βασίζονται σε έργα σας ταυτόχρονα με ένα διακομιστή Subversion δεν είναι καλή ιδέα.
Αν κοιτάξετε την τελευταία δέσμευση, μπορείτε να δείτε το νέο git-svn-id που προστέθηκε:

[πηγή, κονσόλα]
----
$ git log -1
commit 95e0222ba6399739834380eb10afcd73e0670bc5
Συντάκτης: ben <ben @ 0b684db3-b064-4277-89d1-21af03df0a68>
Ημερομηνία: Thu Jul 24 03:08:36 2014 +0000

    Προσθήκη οδηγιών git-svn στο README

    git-svn-id: αρχείο: /// tmp / test-svn / trunk @ 77 0b684db3-b064-4277-89d1-21af03df0a68
----

Παρατηρήστε ότι το άθροισμα ελέγχου SHA-1 που ξεκίνησε αρχικά με το `4af61fd` όταν δεσμευθήκατε τώρα αρχίζει με` 95e0222`.
Αν θέλετε να σπρώξετε τόσο σε ένα διακομιστή Git όσο και σε ένα διακομιστή Subversion, πρέπει πρώτα να πιέσετε (`dcommit`) στο διακομιστή Subversion, επειδή η ενέργεια αυτή αλλάζει τα δεδομένα της δέσμευσής σας.

===== Τραβήξτε τις Νέες Αλλαγές

Εάν εργάζεστε με άλλους προγραμματιστές, τότε σε κάποιο σημείο ένας από εσάς θα πιέσει και τότε ο άλλος θα προσπαθήσει να προωθήσει μια αλλαγή που έρχεται σε σύγκρουση.
Η αλλαγή αυτή θα απορριφθεί μέχρι να συγχωνευθείτε στην εργασία τους.
Στο `git svn`, μοιάζει με αυτό:

[πηγή, κονσόλα]
----
$ git svn dcommit
Δεσμευόμενη στο αρχείο: /// tmp / test-svn / trunk ...

ΣΦΑΛΜΑ από το SVN:
Η συναλλαγή είναι ξεχασμένη: Το αρχείο '/trunk/README.txt' είναι ξεπερασμένο
W: d5837c4b461b7c0e018b49d12398769d2bfc240a και refs / remotes / προέλευση / trunk διαφέρουν, χρησιμοποιώντας rebase:
: 100644 100644 f414c433af0fd6734428cf9d2a9fd8ba00ada145 c80b6127dd04f5fcda218730ddf3a2da4eb39138 ΑΝΑΚΟΙΝΩΣΗ.txt
Ο τρέχων κύριος κλάδος είναι ενημερωμένος.
Σφάλμα: Δεν έγιναν όλες οι αλλαγές στο SVN, ωστόσο οι δεσμεύσεις
αυτά (αν υπάρχουν) φαίνεται να ενσωματώνονται με επιτυχία στο δέντρο εργασίας.
Ανατρέξτε στα παραπάνω μηνύματα για λεπτομέρειες.
----

Για να επιλύσετε αυτήν την κατάσταση, μπορείτε να εκτελέσετε το `git svn rebase`, το οποίο καταργεί οποιεσδήποτε αλλαγές στο διακομιστή που δεν έχετε ακόμα και αναβαθμίζει οποιαδήποτε εργασία έχετε πάνω από αυτό που βρίσκεται στον server:

[πηγή, κονσόλα]
----
$ git svn rebase
Δεσμευόμενη στο αρχείο: /// tmp / test-svn / trunk ...

ΣΦΑΛΜΑ από το SVN:
Η συναλλαγή είναι ξεχασμένη: Το αρχείο '/trunk/README.txt' είναι ξεπερασμένο
W: eaa029d99f87c5c822c5c29039d19111ff32ef46 και refs / remotes / προέλευση / trunk διαφέρουν, χρησιμοποιώντας rebase:
: 100644 100644 65536c6e30d263495c17d781962cfff12422693a b34372b25ccf4945fe5658fa381b075045e7702a M README.txt
Αρχικά, επανατοποθετήστε το κεφάλι για να επαναλάβετε την εργασία σας πάνω από το ...
Εφαρμόζοντας: ενημέρωση για
Χρήση πληροφοριών δείκτη για την ανακατασκευή ενός δέντρου βάσης ...
M README.txt
Πέφτει πίσω στη βάση επιδιόρθωσης και συγχώνευση 3 δρόμων ...
Αυτόματη συγχώνευση του README.txt
Σφάλμα: Δεν έγιναν όλες οι αλλαγές στο SVN, ωστόσο οι δεσμεύσεις
αυτά (αν υπάρχουν) φαίνεται να ενσωματώνονται με επιτυχία στο δέντρο εργασίας.
Ανατρέξτε στα παραπάνω μηνύματα για λεπτομέρειες.
----

Τώρα, όλη η δουλειά σας είναι πάνω από αυτό που βρίσκεται στο διακομιστή Subversion, έτσι ώστε να μπορείτε να `dcommit` με επιτυχία:

[πηγή, κονσόλα]
----
$ git svn dcommit
Δεσμευόμενη στο αρχείο: /// tmp / test-svn / trunk ...
    M README.txt
Δέσμευσε r85
    M README.txt
r85 = 9c29704cc0bbbed7bd58160cfb66cb9191835cd8 (refs / remotes / προέλευση / κορμό)
Δεν υπάρχουν αλλαγές μεταξύ 5762f56732a958d6cfda681b661d2a239cc53ef5 και refs / remotes / προέλευσης / κορμού
Επαναφορά στις τελευταίες συσκευές refs / remotes / origination / trunk
----

Σημειώστε ότι αντίθετα με το Git, το οποίο απαιτεί να συγχωνεύσετε την ανάντη εργασία που δεν έχετε ακόμα τοπικά προτού μπορέσετε να προωθήσετε, το `git svn` σας κάνει να το κάνετε αυτό μόνο αν οι αλλαγές συγκρούονται (όπως ακριβώς λειτουργεί το Subversion).
Αν κάποιος άλλος πιέσει μια αλλαγή σε ένα αρχείο και στη συνέχεια πιέσετε μια αλλαγή σε άλλο αρχείο, το `dcommit` σας θα λειτουργήσει καλά:

[πηγή, κονσόλα]
----
$ git svn dcommit
Δεσμευόμενη στο αρχείο: /// tmp / test-svn / trunk ...
    M configure.ac
Δέσμευσε r87
    Μ autogen.sh
r86 = d8450bab8a77228a644b7dc0e95977ffc61adff7 (refs / remotes / προέλευση / κορμός)
    M configure.ac
r87 = f3653ea40cb4e26b6281cec102e35dcba1fe17c4 (refs / remotes / προέλευση / κορμός)
W: a0253d06732169107aa020390d9fefd2b1d92806 και refs / remotes / προέλευση / trunk διαφέρουν, χρησιμοποιώντας rebase:
: 100755 100755 efa5a59965fbbb5b2b0a12890f1b351bb5493c18 e757b59a9439312d80d5d43bb65d4a7d0389ed6d Όνομα χρήστη M autogen.sh
Αρχικά, επανατοποθετήστε το κεφάλι για να επαναλάβετε την εργασία σας πάνω από το ...
----

Αυτό είναι σημαντικό να θυμάστε, επειδή το αποτέλεσμα είναι μια κατάσταση έργου που δεν υπήρχε σε κανέναν από τους υπολογιστές σας όταν ώθησατε.
Εάν οι αλλαγές είναι ασυμβίβαστες αλλά δεν έρχονται σε σύγκρουση, μπορεί να λάβετε ζητήματα που είναι δύσκολο να διαγνωστούν.
Αυτό είναι διαφορετικό από τη χρήση ενός διακομιστή Git - στο Git, μπορείτε να ελέγξετε πλήρως την κατάσταση στο σύστημα πελάτη πριν δημοσιεύσετε, ενώ στο SVN, δεν μπορείτε ποτέ να είστε σίγουροι ότι τα κράτη αμέσως πριν από τη δέσμευση και μετά από τη δέσμευση είναι πανομοιότυπα.

Θα πρέπει επίσης να εκτελέσετε αυτήν την εντολή για να τραβήξετε αλλαγές από το διακομιστή Subversion, ακόμη και αν δεν είστε έτοιμοι να δεσμευθείτε.
Μπορείτε να εκτελέσετε το `git svn fetch` για να τραβήξετε τα νέα δεδομένα, αλλά` git svn rebase` κάνει το fetch και στη συνέχεια ενημερώνει τις τοπικές δεσμεύσεις σας.

[πηγή, κονσόλα]
----
$ git svn rebase
    Μ autogen.sh
r88 = c9c5f83c64bd755368784b444bc7a0216cc1e17b (refs / remotes / προέλευση / κορμός)
Αρχικά, επανατοποθετήστε το κεφάλι για να επαναλάβετε την εργασία σας πάνω από το ...
Γρήγορη μεταβίβαση κύριου σε αναφορές / απομακρυσμένες / προέλευση / κορμό.
----

Το τρέξιμο της `git svn rebase` κάθε φορά σε μια στιγμή διασφαλίζει ότι ο κωδικός σας είναι πάντα ενημερωμένος.
Πρέπει να είστε σίγουροι ότι ο κατάλογος εργασίας σας είναι καθαρός όταν εκτελείτε αυτό, αν και.
Αν έχετε τοπικές αλλαγές, πρέπει είτε να αποθηκεύσετε την εργασία σας είτε να τη δεσμεύσετε προσωρινά πριν εκτελέσετε το `git svn rebase` - διαφορετικά, η εντολή θα σταματήσει εάν διαπιστώσει ότι η επαναφορά θα οδηγήσει σε σύγκρουση συγχώνευσης.

===== Θέματα διακλάδωσης Git

Όταν εξοικειωθείτε με μια ροή εργασίας Git, πιθανότατα θα δημιουργήσετε κλάδους θεμάτων, θα εργαστείτε σε αυτά και, στη συνέχεια, θα τα συγχωνεύσετε.
Αν πιέζετε σε ένα διακομιστή Subversion μέσω του `git svn`, ίσως θελήσετε να αναδιοργανώσετε την εργασία σας σε ένα κλάδο κάθε φορά αντί να συγχωνεύσετε τα υποκαταστήματα.
Ο λόγος για τον οποίο προτιμάτε την επαναχρησιμοποίηση είναι ότι το Subversion έχει γραμμικό ιστορικό και δεν ασχολείται με συγχώνευση όπως το Git, έτσι `git svn` ακολουθεί μόνο τον πρώτο γονέα όταν μετατρέπει τα στιγμιότυπα σε δεσμεύσεις Subversion.

Ας υποθέσουμε ότι η ιστορία σας μοιάζει με την ακόλουθη: δημιουργήσατε ένα υποκατάστημα `πειράματος ', κάνατε δύο δεσμεύσεις και στη συνέχεια τους συγχωνεύσατε ξανά σε` master`.
Όταν κάνετε `dcommit`, βλέπετε έξοδο έτσι:

[πηγή, κονσόλα]
----
$ git svn dcommit
Δεσμευόμενη στο αρχείο: /// tmp / test-svn / trunk ...
    M CHANGES.txt
Δεσμευμένη r89
    M CHANGES.txt
r89 = 89d492c884ea7c834353563d5d913c6adf933981 (refs / remotes / προέλευση / κορμός)
    M COPYING.txt
    M INSTALL.txt
Δεσμευμένη r90
    M INSTALL.txt
    M COPYING.txt
r90 = cb522197870e61467473391799148f6721bcf9a0 (αναφορές / απομακρυσμένα / προέλευση / κορμό)
Δεν υπάρχουν αλλαγές μεταξύ 71af502c214ba13123992338569f4669877f55fd και refs / remotes / προέλευσης / κορμού
Επαναφορά στις τελευταίες συσκευές refs / remotes / origination / trunk
----

Η εκτέλεση του `dcommit 'σε ένα υποκατάστημα με συγχωνευμένη ιστορία λειτουργεί καλά, εκτός από το ότι όταν εξετάζετε το ιστορικό του έργου Git, δεν έχει ξαναγράψει καμία από τις δεσμεύσεις που κάνατε στο κλάδο` experiment' - αντί να εμφανίζονται όλες αυτές οι αλλαγές στο Η έκδοση SVN της δέσμευσης ενιαίας συγχώνευσης.

Όταν κάποιος άλλος κλωνοποιεί αυτό το έργο, το μόνο που βλέπουν είναι ότι η συγχώνευση δεσμεύεται με όλη τη δουλειά που τσακίζεται σε αυτό, σαν να τρέξατε "git merge --squash". δεν βλέπουν τα στοιχεία σχετικά με το από πού προήλθαν ή πότε έγινε.

===== Διακλάδωση υποτροπής

Η διαίρεση στην Subversion δεν είναι η ίδια με τη διακλάδωση στο Git. αν μπορείτε να αποφύγετε να το χρησιμοποιήσετε πολύ, αυτό είναι πιθανώς καλύτερο.
Ωστόσο, μπορείτε να δημιουργήσετε και να δεσμευθείτε σε υποκαταστήματα στο Subversion χρησιμοποιώντας το git svn.

===== Δημιουργία νέου υποκαταστήματος SVN

Για να δημιουργήσετε ένα νέο υποκατάστημα στο Subversion, εκτελέστε το `git svn branch [branchname]`:

[πηγή, κονσόλα]
----
$ git svn όπερα υποκαταστήματος
Αντιγραφή αρχείου: /// tmp / test-svn / trunk στο r90 σε αρχείο: /// tmp / test-svn / branches / opera ...
Βρήκε πιθανό σημείο κατανομής: αρχείο: /// tmp / test-svn / trunk => αρχείο: /// tmp / test-svn / branches / όπερα, 90
Βρέθηκε γονέας υποκαταστήματος: (refs / remotes / προέλευση / όπερα) cb522197870e61467473391799148f6721bcf9a0
Μετά το γονέα με do_switch
Παρακολουθήσατε με επιτυχία τον γονέα
r91 = f1b64a3855d3c8dd84ee0ef10fa89d27f1584302 (refs / remotes / προέλευση / όπερα)
----

Αυτό ισοδυναμεί με την εντολή `svn copy trunk / opera 'στην Subversion και λειτουργεί στο διακομιστή Subversion.
Είναι σημαντικό να σημειωθεί ότι δεν σας ελέγχει σε αυτό το υποκατάστημα. εάν δεσμευτείτε σε αυτό το σημείο, αυτή η δέσμευση θα μεταβεί στον «κορμό» του διακομιστή, όχι στην «όπερα».

===== Μεταγωγή ενεργών κλάδων

Το Git υπολογίζει σε ποια υποκατηγορία πηγαίνουν τα σχόλια σας αναζητώντας την άκρη οποιουδήποτε υποκαταστήματος Subversion στην ιστορία σας - θα πρέπει να έχετε μόνο ένα και θα πρέπει να είναι το τελευταίο με ένα git-svn-id στον τρέχοντα κατάλογό σας ιστορία.

Εάν θέλετε να εργαστείτε ταυτόχρονα σε περισσότερα από ένα υποκατάστημα, μπορείτε να ρυθμίσετε τοπικούς κλάδους για να `dcommit` σε συγκεκριμένα υποκαταστήματα Subversion ξεκινώντας από την εισαγόμενη δέσμευση Subversion για αυτό το υποκατάστημα.
Αν θέλετε ένα υποκατάστημα `opera 'που μπορείτε να εργαστείτε ξεχωριστά, μπορείτε να τρέξετε

[πηγή, κονσόλα]
----
$ git υποκαταστήματα / πηγή προέλευσης / όπερας
----

Τώρα, εάν θέλετε να συγχωνεύσετε τον κλάδο `opera 'σας σε` trunk` (τον κύριο κλάδο σας), μπορείτε να το κάνετε με μια κανονική' συγχώνευση git '.
Αλλά πρέπει να δώσετε ένα περιγραφικό μήνυμα δέσμευσης (μέσω `-m`), ή η συγχώνευση θα λέει` `Merge branch opera '' αντί για κάτι χρήσιμο.

Θυμηθείτε ότι παρόλο που χρησιμοποιείτε το `git merge 'για να κάνετε αυτή τη λειτουργία και η συγχώνευση πιθανόν θα είναι πολύ πιο εύκολη από ό, τι θα ήταν στην Subversion (επειδή το Git θα ανιχνεύσει αυτόματα την κατάλληλη βάση συγχώνευσης για εσάς), αυτό δεν είναι κανονικό Συνεισφορά συγχώνευσης Git.
Πρέπει να σπρώξετε αυτά τα δεδομένα πίσω σε ένα διακομιστή Subversion που δεν μπορεί να χειριστεί μια δέσμευση που παρακολουθεί περισσότερους από έναν γονείς. οπότε, αφού τον πιέσετε, θα μοιάζει με μια ενιαία δέσμευση που σβήνει σε όλη τη δουλειά ενός άλλου υποκαταστήματος κάτω από μια ενιαία δέσμευση.
Αφού συγχωνεύσετε ένα υποκατάστημα σε άλλο, δεν μπορείτε εύκολα να επιστρέψετε και να συνεχίσετε να εργάζεστε σε αυτό το υποκατάστημα, όπως συνήθως μπορείτε στο Git.
Η εντολή `dcommit` που τρέχετε σβήνει κάθε πληροφορία που λέει σε ποιο υποκατάστημα συγχωνεύθηκε, έτσι οι μεταγενέστεροι υπολογισμοί βάσης συγχώνευσης θα είναι λανθασμένοι - το dcommit κάνει το αποτέλεσμα` git merge 'να μοιάζει σαν να τρέξατε `git merge - squash`.
Δυστυχώς, δεν υπάρχει καλός τρόπος για να αποφύγετε αυτή την κατάσταση - η Subversion δεν μπορεί να αποθηκεύσει αυτές τις πληροφορίες, έτσι θα παρασυρθείτε πάντα από τους περιορισμούς της ενώ την χρησιμοποιείτε ως διακομιστή σας.
Για να αποφύγετε προβλήματα, πρέπει να διαγράψετε τον τοπικό κλάδο (στην περίπτωση αυτή, `opera ') αφού συγχωνεύσετε τον κορμό.

===== Εντολές Subversion

Το σύνολο εργαλείων `git svn` παρέχει πολλές εντολές για να διευκολύνει τη μετάβαση στο Git παρέχοντας κάποια λειτουργικότητα παρόμοια με αυτή που είχατε στο Subversion.
Ακολουθούν μερικές εντολές που σας δίνουν τι συνήθιζε η Subversion.

====== Ιστορικό στυλ SVN

Αν είστε συνηθισμένοι στο Subversion και θέλετε να δείτε το ιστορικό σας σε στυλ εξόδου SVN, μπορείτε να εκτελέσετε το `git svn log` για να δείτε το ιστορικό των εργασιών σας σε μορφή SVN:


4489/5000
[πηγή, κονσόλα]
----
$ git svn αρχείο καταγραφής
-------------------------------------------------- ----------------------
r87 | schacon | 2014-05-02 16:07:37 -0700 (Σάβ, 02 Μαΐου 2014) | 2 γραμμές

αυτόνομη αλλαγή

-------------------------------------------------- ----------------------
r86 | schacon | 2014-05-02 16:00:21 -0700 (Σάβ, 02 Μαΐου 2014) | 2 γραμμές

Συγχώνευση υποκαταστήματος "πειράματος"

-------------------------------------------------- ----------------------
r85 | schacon | 2014-05-02 16:00:09 -0700 (Σάβ, 02 Μαΐου 2014) | 2 γραμμές

ενημέρωσε τον changelog
----

Θα πρέπει να γνωρίζετε δύο σημαντικά πράγματα για το `git svn log`.
Πρώτον, λειτουργεί εκτός σύνδεσης, σε αντίθεση με την πραγματική εντολή `svn log`, η οποία ζητάει από τον διακομιστή Subversion τα δεδομένα.
Δεύτερον, δείχνει μόνο δεσμεύσεις που έχουν δεσμευτεί μέχρι το διακομιστή Subversion.
Τοπικό Git δεσμεύεται ότι δεν έχετε dcommited δεν εμφανίζονται? ούτε δεσμεύεται ότι οι άνθρωποι έχουν κάνει στο διακομιστή Subversion στο μεταξύ.
Είναι περισσότερο όπως η τελευταία γνωστή κατάσταση των δεσμεύσεων στο διακομιστή Subversion.

====== Σχολιασμός SVN

Καθώς η εντολή `git svn log` προσομοιώνει την εντολή` svn log` εκτός σύνδεσης, μπορείτε να πάρετε το ισοδύναμο του `svn annotate 'εκτελώντας το` git svn blame [FILE] `.
Η έξοδος μοιάζει ως εξής:

[πηγή, κονσόλα]
----
$ git svn κατηγορεί README.txt
 2 temporal Buffers πρωτοκόλλου - μορφή ανταλλαγής δεδομένων της Google
 2 temporal Copyright 2008 Google Inc.
 2 χρονικές http://code.google.com/apis/protocolbuffers/
 2 χρονικό
22 προσωρινή εγκατάσταση C ++ - Unix
22 temporal =======================
 2 χρονικό
79 schacon Δέσμευση στο git-svn.
78 schacon
 2 temporal Για να δημιουργήσετε και να εγκαταστήσετε το πρωτόκολλο χρόνου εκτέλεσης buffer C ++ και το πρωτόκολλο
 2 temporal Μεταγλωττιστής Buffer (πρωτόκολλο) εκτελεί τα ακόλουθα:
 2 χρονικό
----

Και πάλι, δεν δείχνει δεσμεύσεις ότι κάνατε τοπικά στο Git ή που έχουν ωθηθεί στο Subversion εν τω μεταξύ.

====== Πληροφορίες διακομιστή SVN

Μπορείτε επίσης να αποκτήσετε το ίδιο είδος πληροφορίας που σας δίνει `svn info`, τρέχοντας` git svn info`:

[πηγή, κονσόλα]
----
$ git svn info
Διαδρομή:.
URL: https://schacon-test.googlecode.com/svn/trunk
Ρίζα αποθετηρίου: https://schacon-test.googlecode.com/svn
Αποθήκη UUID: 4c93b258-373f-11de-be05-5f7a86268029
Αναθεώρηση: 87
Κατάλογος κόμβων Kind: directory
Πρόγραμμα: κανονικό
Τελευταία αλλαγή Συγγραφέας: schacon
Τελευταία Αλλαγή Rev: 87
Τελευταία Αλλαγή ημερομηνίας: 2009-05-02 16:07:37 -0700 (Σάβ, 02 Μαΐου 2009)
----

Αυτό είναι σαν να 'φταίει' και 'log' στο ότι εκτελείται χωρίς σύνδεση και είναι ενημερωμένο μόνο από την τελευταία φορά που επικοινωνήσατε με το διακομιστή Subversion.

====== Παράβλεψη της παραβίασης της υποτροπής

Αν κλωνοποιήσετε ένα αποθετήριο Subversion που έχει τις ιδιότητες `svn: ignore` που ορίζετε οπουδήποτε, πιθανότατα θέλετε να ορίσετε αντίστοιχα αρχεία` .gitignore` έτσι ώστε να μην δεσμεύσετε τυχαία αρχεία που δεν θα έπρεπε.
Το `git svn` έχει δύο εντολές για να βοηθήσει με αυτό το ζήτημα.
Το πρώτο είναι το `git svn create-ignore`, το οποίο δημιουργεί αυτόματα τα αντίστοιχα αρχεία` .gitignore` για εσάς, έτσι ώστε η επόμενη δέσμευση να τα συμπεριλάβει.

Η δεύτερη εντολή είναι `git svn show-ignore`, η οποία εκτυπώνει σε stdout τις γραμμές που πρέπει να βάλετε σε ένα αρχείο .gitignore ώστε να μπορείτε να ανακατευθύνετε την έξοδο στο project exclude file:

[πηγή, κονσόλα]
----
$ git svn Εμφάνιση-αγνοήστε> .git / info / exclude
----

Με αυτόν τον τρόπο, δεν μεταφέρετε το έργο με αρχεία .gitignore.
Αυτή είναι μια καλή επιλογή αν είστε ο μόνος χρήστης Git σε μια ομάδα Subversion και οι συμπαίκτες σας δεν θέλουν αρχεία `.gitignore` στο έργο.

===== Περίληψη Git-Svn

Τα εργαλεία `git svn` είναι χρήσιμα αν είστε κολλημένοι με ένα διακομιστή Subversion ή διαφορετικά βρίσκονται σε περιβάλλον ανάπτυξης που απαιτεί την εκτέλεση διακομιστή Subversion.
Θα πρέπει να το θεωρήσετε παρωχημένο το Git, ωστόσο, ή θα χτυπήσετε ζητήματα σε μετάφραση που μπορεί να σας προκαλέσουν σύγχυση με εσάς και τους συνεργάτες σας.
Για να αποφύγετε προβλήματα, προσπαθήστε να ακολουθήσετε αυτές τις οδηγίες:

* Διατηρήστε ένα γραμμικό ιστορικό Git που δεν περιέχει συγχώνευση συγχώνευσης από το `git merge '.
  Επεξεργαστείτε κάθε εργασία που κάνετε έξω από το υποκατάστημα της κύριας σας γραμμής. μην το συγχωνεύσετε.
* Μη ρυθμίζετε και συνεργάζεστε σε ξεχωριστό server Git.
  Ενδεχομένως να έχετε έναν για να επιταχύνετε τους κλώνους για νέους προγραμματιστές, αλλά μην πιέζετε τίποτα σε αυτό που δεν έχει καταχώρηση `git-svn-id`.
  Ίσως θελήσετε να προσθέσετε ένα άγκιστρο `pre-receive 'που ελέγχει κάθε μήνυμα αποστολής για ένα` git-svn-id` και απορρίπτει πιέσεις που περιέχουν δεσμεύσεις χωρίς αυτό.

Εάν ακολουθήσετε αυτές τις οδηγίες, η συνεργασία με ένα διακομιστή Subversion μπορεί να είναι πιο ανεκτή.
Ωστόσο, αν είναι δυνατό να μετακινηθείτε σε έναν πραγματικό διακομιστή Git, αυτό μπορεί να κερδίσει την ομάδα σας πολύ περισσότερο.



Ενότητα 9.1.2.

==== Git και Mercurial

(((Διασύνδεση με άλλα VCS, Mercurial)))
(((Αστατος)))
Το σύμπαν DVCS είναι μεγαλύτερο από το Git.
Στην πραγματικότητα, υπάρχουν πολλά άλλα συστήματα σε αυτό το διάστημα, το καθένα με τη δική του γωνία για το πώς να κάνει κατανεμημένο έλεγχο έκδοσης σωστά.
Εκτός από το Git, το πιο δημοφιλές είναι το Mercurial, και τα δύο είναι πολύ παρόμοια από πολλές απόψεις.

Τα καλά νέα, αν προτιμάτε τη συμπεριφορά του πελάτη Git αλλά εργάζεστε με ένα έργο του οποίου ο πηγαίος κώδικας ελέγχεται με το Mercurial, είναι ότι υπάρχει ένας τρόπος να χρησιμοποιήσετε το Git ως πελάτη για ένα αποθετήριο που φιλοξενείται από το Mercurial.
Δεδομένου ότι ο τρόπος με τον οποίο ο Git μιλάει με αποθήκες διακομιστών μέσω απομακρυσμένων συσκευών, δεν πρέπει να αποτελεί έκπληξη ότι αυτή η γέφυρα υλοποιείται ως απομακρυσμένος βοηθός.
Το όνομα του έργου είναι git-remote-hg και μπορεί να βρεθεί στο https://github.com/felipec/git-remote-hg [].

===== git-remote-hg

Πρώτον, πρέπει να εγκαταστήσετε το git-remote-hg.
Αυτό ουσιαστικά συνεπάγεται την πτώση του αρχείου κάπου στο μονοπάτι σας, όπως έτσι:

[πηγή, κονσόλα]
----
$ curl -o ~ / bin / git-remote-hg \
  https://raw.githubusercontent.com/felipec/git-remote-hg/master/git-remote-hg
$ chmod + x ~ / bin / git-remote-hg
----

... υποθέτοντας ότι το ~ ~ / bin είναι στο '$ PATH' σας.
Το Git-remote-hg έχει μια άλλη εξάρτηση: τη βιβλιοθήκη `mercurial` για την Python.
Εάν έχετε εγκαταστήσει Python, αυτό είναι τόσο απλό όσο:

[πηγή, κονσόλα]
----
$ pip εγκαταστήστε μερικοί
----

(Εάν δεν έχετε εγκαταστήσει Python, επισκεφτείτε τη διεύθυνση https://www.python.org/ [] και αποκτήστε την πρώτη σας πρόσβαση.)

Το τελευταίο πράγμα που θα χρειαστείτε είναι ο πελάτης Mercurial.
Μεταβείτε στη διεύθυνση http://mercurial.selenic.com/ [] και εγκαταστήστε την αν δεν το έχετε ήδη κάνει.

Τώρα είστε έτοιμοι να ροκάρει.
Το μόνο που χρειάζεστε είναι ένα αποθετήριο Mercurial στο οποίο μπορείτε να ωθήσετε.
Ευτυχώς, κάθε αποθετήριο Mercurial μπορεί να ενεργήσει με αυτό τον τρόπο, οπότε θα χρησιμοποιήσουμε μόνο το χώρο αποθήκευσης "hello world" που όλοι χρησιμοποιούν για να μάθουν Mercurial:

[πηγή, κονσόλα]
----
$ hg κλώνος http://selenic.com/repo/hello/tmp/ γεια
----

===== Ξεκινώντας

Τώρα που έχουμε έναν κατάλληλο αποθετήριο `` server-side '', μπορούμε να περάσουμε από μια τυπική ροή εργασίας.
Όπως θα δείτε, αυτά τα δύο συστήματα είναι αρκετά παρόμοια ώστε δεν υπάρχει μεγάλη τριβή.

Όπως πάντα με το Git, αρχικά κλωνοποιούμε:

[πηγή, κονσόλα]
----
$ git κλώνος hg :: / tmp / hello / tmp / hello-git
$ cd / tmp / hello-git
$ git log --online --graph - αποσαφήνιση
* ac7955c (HEAD, προέλευση / κύριος, προέλευση / υποκαταστήματα / προεπιλογή, προέλευση / HEAD, refs / hg / προέλευση / υποκαταστήματα / προεπιλογή, refs / hg / origin / bookmarks / master, master)
* 65bb417 Δημιουργήστε ένα πρότυπο πρόγραμμα "hello, world"
----

Θα παρατηρήσετε ότι η εργασία με ένα αποθετήριο Mercurial χρησιμοποιεί την τυπική εντολή `git clone`.
Αυτό συμβαίνει επειδή το git-remote-hg λειτουργεί σε αρκετά χαμηλό επίπεδο, χρησιμοποιώντας έναν παρόμοιο μηχανισμό με τον τρόπο με τον οποίο υλοποιείται το πρωτόκολλο HTTP / S του Git (απομακρυσμένοι βοηθοί).
Δεδομένου ότι οι Git και Mercurial έχουν σχεδιαστεί για να έχουν κάθε πελάτη πλήρες αντίγραφο της ιστορίας του αποθετηρίου, αυτή η εντολή κάνει έναν πλήρη κλώνο, συμπεριλαμβανομένου ολόκληρου του ιστορικού του έργου, και το κάνει αρκετά γρήγορα.

Η εντολή καταγραφής δείχνει δύο δεσμεύσεις, το τελευταίο από το οποίο υποδεικνύεται από μια ολόκληρη σειρά από αναφορές.
Αποδεικνύεται ότι κάποια από αυτά δεν είναι πραγματικά εκεί.
Ας ρίξουμε μια ματιά στο τι είναι πραγματικά στον κατάλογο `.git`:

[πηγή, κονσόλα]
----
$ δέντρο .git / refs
.git / refs
├α κεφάλια
│ └── master
├── hg
│ └── προέλευση
│ ├──δεδομένα
│ │ └── πλοίαρχος
│ └──────
│ └── default
├── σημειώσεις
│ └── hg
├── τηλεχειριστήρια
│ └── προέλευση
│ └── HEAD
Ετικέτες └──

9 καταλόγους, 5 αρχεία
----

Το Git-remote-hg προσπαθεί να κάνει τα πράγματα πιο idiomatically Git-esque, αλλά κάτω από την κουκούλα διαχειρίζεται την εννοιολογική χαρτογράφηση μεταξύ δύο ελαφρώς διαφορετικών συστημάτων.
Ο κατάλογος "refs / hg" είναι εκεί όπου αποθηκεύονται οι πραγματικοί απομακρυσμένοι ανασυνδυασμοί.
Για παράδειγμα, το αρχείο `refs / hg / origin / branches / default` είναι ένα αρχείο ref Git που περιέχει το SHA-1 που αρχίζει με το` `ac7955c ''.
Έτσι, ο κατάλογος `refs / hg` είναι σαν ένα ψεύτικο` refs / remotes / προέλευση`, αλλά έχει την πρόσθετη διάκριση μεταξύ σελιδοδεικτών και υποκαταστημάτων.

Το αρχείο `notes / hg` είναι το σημείο εκκίνησης για τον τρόπο με τον οποίο οι git-remote-hg χάρτες Git δεσμεύουν τα hashes με τα αναγνωριστικά της Mercurial changeset.
Ας εξερευνήσουμε λίγο:

[πηγή, κονσόλα]
----
$ γάτα σημειώσεις / hg
d4c10386 ...

$ git γάτα-αρχείο -p d4c10386 ...
δέντρο 1781c96 ...
συγγραφέας απομακρυσμένης-hg <> 1408066400 -0800
committer απομακρυσμένη-hg <> 1408066400 -0800

Σημειώσεις για τον κύριο

$ git ls-tree 1781c96 ...
100644 blob ac9117f ... 65bb417 ...
100644 blob 485e178 ... ac7955c ...

$ git γάτα-αρχείο -p ac9117f
0a04b987be5ae354b710cefeba0e2d9de7ad41a9
----

Επομένως, το `refs / notes / hg` δείχνει σε ένα δέντρο, το οποίο στη βάση δεδομένων αντικειμένων Git είναι μια λίστα με άλλα αντικείμενα με ονόματα.
Το `git ls-tree` εξάγει τη λειτουργία, τον τύπο, το hash αντικειμένου και το όνομα αρχείου για τα στοιχεία μέσα σε ένα δέντρο.
Μόλις σκάψουμε σε ένα από τα στοιχεία του δέντρου, διαπιστώνουμε ότι μέσα του είναι ένα blob που ονομάζεται `` ac9117f '' (το SHA-1 hash του commit που υποδεικνύεται από τον 'master`), με τα περιεχόμενα `` 0a04b98' ' που είναι το αναγνωριστικό της ομάδας Mercurial changeset στην κορυφή του κλάδου `default ').

Τα καλά νέα είναι ότι δεν χρειάζεται να ανησυχούμε για όλα αυτά.

Η τυπική ροή εργασίας δεν θα είναι πολύ διαφορετική από τη δουλειά με ένα τηλεχειριστήριο Git.

Υπάρχει ένα ακόμα πράγμα που πρέπει να παρακολουθήσουμε πριν συνεχίσουμε: αγνοεί.
Το Mercurial και το Git χρησιμοποιούν έναν πολύ παρόμοιο μηχανισμό για αυτό, αλλά είναι πιθανό ότι δεν θέλετε να δεσμευτείτε πραγματικά ένα αρχείο .gitignore σε ένα αποθετήριο Mercurial.
Ευτυχώς, ο Git έχει έναν τρόπο να αγνοήσει τα αρχεία που είναι τοπικά σε ένα χώρο αποθήκευσης στο δίσκο και η μορφή Mercurial είναι συμβατή με το Git, οπότε απλά πρέπει να το αντιγράψετε:

[πηγή, κονσόλα]
----
$ cp .hgignore .git / info / εξαιρέστε
----

Το αρχείο `.git / info / exclude` λειτουργεί ακριβώς όπως` .gitignore`, αλλά δεν περιλαμβάνεται στις δεσμεύσεις.


===== Ροή εργασίας

Ας υποθέσουμε ότι έχουμε κάνει κάποια εργασία και κάναμε κάποιες δεσμεύσεις στο υποκατάστημα `master` και είστε έτοιμοι να το σπρώξετε στο απομακρυσμένο αποθετήριο.
Εδώ φαίνεται το αποθετήριο μας:

[πηγή, κονσόλα]
----
$ git log --online --graph - αποσαφήνιση
* ba04a2a (HEAD, master) Ενημερώστε το makefile
* d25d16f Αντίο
* ac7955c (προέλευση / κύριος, προέλευση / υποκαταστήματα / προεπιλογή, προέλευση / HEAD, refs / hg / προέλευση / υποκαταστήματα / προεπιλογή, refs / hg / origin / bookmarks / master)
* 65bb417 Δημιουργήστε ένα πρότυπο πρόγραμμα "hello, world"
----

Ο κλάδος `master` είναι δύο δεσμεύσεις μπροστά από την αρχή / master, αλλά αυτές οι δύο δεσμεύσεις υπάρχουν μόνο στο τοπικό μας μηχάνημα.
Ας δούμε αν κάποιος άλλος έχει κάνει σημαντικό έργο την ίδια στιγμή:

[πηγή, κονσόλα]
----
$ git fetch
Από το hg :: / tmp / hello
   ac7955c..df85e87 master -> προέλευση / κύριο
   ac7955c..df85e87 υποκαταστήματα / προεπιλογή -> προέλευση / υποκαταστήματα / προεπιλογή
$ git log --online --graph --decorate - όλα
* 7b07969 (refs / notes / hg) Σημειώσεις για προεπιλογή
* d4c1038 Σημειώσεις για τον πλοίαρχο
* df85e87 (προέλευση / αρχηγός, προέλευση / υποκαταστήματα / προεπιλογή, προέλευση / HEAD, refs / hg / προέλευση / υποκαταστήματα / προεπιλογή, refs / hg / origin / bookmarks / master)
| * ba04a2a (HEAD, master) Ενημερώστε το makefile
| * d25d16f Αντίο
| /
* ac7955c Δημιουργήστε ένα makefile
* 65bb417 Δημιουργήστε ένα πρότυπο πρόγραμμα "hello, world"
----

Εφόσον χρησιμοποιήσαμε τη σημαία `--all`, βλέπουμε τις παραπομπές` `notes '' που χρησιμοποιούνται εσωτερικά από το git-remote-hg, αλλά μπορούμε να τις αγνοήσουμε.
Τα υπόλοιπα είναι αυτά που περιμέναμε. Η αρχή "master / master" έχει προχωρήσει με μία δέσμευση και η ιστορία μας έχει αποκλίνει τώρα.
Σε αντίθεση με τα άλλα συστήματα με τα οποία εργαζόμαστε σε αυτό το κεφάλαιο, το Mercurial είναι ικανό να χειριστεί τις συγχωνεύσεις, οπότε δεν πρόκειται να κάνουμε τίποτα φανταχτερό.

[πηγή, κονσόλα]
----
$ git συγχώνευση προέλευσης / κύριος
Αυτόματη συγχώνευση hello.c
Συγχώνευση από την «αναδρομική» στρατηγική.
 hello.c | 2 + -
 1 αρχείο άλλαξε, 1 εισαγωγή (+), 1 διαγραφή (-)
$ git log --online --graph - αποσαφήνιση
* 0c64627 (HEAD, master) Συγχώνευση υποκαταστήματος απομακρυσμένης παρακολούθησης 'προέλευση / κύριο'
| \
| * df85e87 (προέλευση / αρχηγός, προέλευση / υποκαταστήματα / προεπιλογή, προέλευση / HEAD, refs / hg / προέλευση / υποκαταστήματα / προεπιλογή, refs / hg / origin / bookmarks / master)
* | ba04a2a Ενημέρωση του makefile
* | d25d16f Αντίο
| /
* ac7955c Δημιουργήστε ένα makefile
* 65bb417 Δημιουργήστε ένα πρότυπο πρόγραμμα "hello, world"
----

Τέλειος.
Εκτελούμε τις δοκιμές και όλα περνούν, οπότε είμαστε έτοιμοι να μοιραστούμε το έργο μας με την υπόλοιπη ομάδα:

[πηγή, κονσόλα]
----
$ git push
Σε hg :: / tmp / γεια
   df85e87..0c64627 master -> πλοίαρχος
----

Αυτό είναι!
Εάν ρίξετε μια ματιά στο αποθετήριο Mercurial, θα δείτε ότι αυτό έκανε αυτό που θα περίμενε κανείς:

[πηγή, κονσόλα]
----
$ hg log -G - στυλ συμπαγής
o 5 [συμβουλή]: 4,2 dc8fa4f932b8 2014-08-14 19:33 -0700 ben
| \ Συγχώνευση υποκαταστήματος απομακρυσμένης παρακολούθησης "προέλευση / κύριο"
| |
| o 4 64f27bcefc35 2014-08-14 19:27 -0700 Μπεν
| | Ενημερώστε το makefile
| |
| o 3: 1 4256fc29598f 2014-08-14 19:27 -0700 Μπεν
| | Αντιο σας
| |
@ | 2 7db0b4848b3c 2014-08-14 19:30 -0700 Μπεν
| / Προσθέστε κάποια τεκμηρίωση
|
o 1 82e55d328c8c 2005-08-26 01:21 -0700 mpm
| Δημιουργήστε ένα makefile
|
o 0 0a04b987be5a 2005-08-26 01:20 -0700 mpm
     Δημιουργήστε ένα πρότυπο πρόγραμμα "hello, world"
----

Το σύνολο των αλλαγών που έγιναν _2_ έγινε από την Mercurial και οι αλλαγέςets αριθμημένες _3_ και _4_ έγιναν από το git-remote-hg, πιέζοντας τις δεσμεύσεις που έγιναν με το Git.

===== Υποκαταστήματα και Σελιδοδείκτες

Το Git έχει μόνο ένα είδος υποκαταστήματος: μια αναφορά που μετακινείται όταν γίνονται δεσμεύσεις.
Στο Mercurial, αυτό το είδος μίας αναφοράς ονομάζεται «σελιδοδείκτης», και συμπεριφέρεται με τον ίδιο τρόπο όπως ένας κλάδος Git.

Η έννοια του Mercurial ενός `` υποκαταστήματος '' είναι πιο βαρέων βαρών.
Το υποκατάστημα στο οποίο πραγματοποιείται ένα changeet καταγράφεται με το changeset_, το οποίο σημαίνει ότι θα βρίσκεται πάντα στο ιστορικό αποθετηρίου.
Ακολουθεί ένα παράδειγμα δέσμευσης που έγινε στον τομέα ανάπτυξης:

[πηγή, κονσόλα]
----
$ hg log -l 1
changeset: 6: 8f65e5e02793
κλάδος: ανάπτυξη
ετικέτα: άκρη
χρήστης: Ben Straub <ben@straub.cc>
ημερομηνία: Πέμπ. 14 Αυγ. 20:06:38 2014 -0700
Περίληψη: Περισσότερες τεκμηρίωση
----

Σημειώστε τη γραμμή που αρχίζει με `` branch ''.
Το Git δεν μπορεί να αναπαράγει αυτό το πράγμα (και δεν χρειάζεται να είναι και οι δύο τύποι υποκαταστημάτων μπορούν να αναπαρασταθούν ως Git ref), αλλά το git-remote-hg πρέπει να κατανοήσει τη διαφορά, επειδή το Mercurial ενδιαφέρεται.

Η δημιουργία των σελιδοδεικτών Mercurial είναι τόσο εύκολη όσο και η δημιουργία θυγατρικών Git.
Στην πλευρά Git:

[πηγή, κονσόλα]

----
$ git checkout -b χαρακτηριστικόA
Μετάβαση σε νέο υποκατάστημα 'featureA'
$ git push χαρακτηριστικό προέλευσηςA
Σε hg :: / tmp / γεια
 * [νέο υποκατάστημα] featureA -> featureA
----

Αυτό είναι το μόνο που υπάρχει σε αυτό.
Από την πλευρά Mercurial, μοιάζει με αυτό:

[πηγή, κονσόλα]
----
$ hg σελιδοδείκτες
   χαρακτηριστικό A 5: bd5ac26f11f9
$ hg log -style compact -G
@ 6 [άκρο] 8f65e5e02793 2014-08-14 20:06 -0700 ben
| Περισσότερα έγγραφα
|
o 5 [χαρακτηριστικόA]: 4,2 bd5ac26f11f9 2014-08-14 20:02 -0700 ben
| \ Συγχώνευση υποκαταστήματος απομακρυσμένης παρακολούθησης "προέλευση / κύριο"
| |
| o 4 0434aa6b91f 2014-08-14 20:01 -0700 Μπεν
| | ενημερώστε το makefile
| |
| o 3: 1 318914536c86 2014-08-14 20:00 -0700 Μπεν
| | αντιο σας
| |
o | 2 f098c7f45c4f 2014-08-14 20:01 -0700 ben
| / Προσθέστε κάποια τεκμηρίωση
|
o 1 82e55d328c8c 2005-08-26 01:21 -0700 mpm
| Δημιουργήστε ένα makefile
|
o 0 0a04b987be5a 2005-08-26 01:20 -0700 mpm
     Δημιουργήστε ένα πρότυπο πρόγραμμα "hello, world"
----

Σημειώστε τη νέα ετικέτα `[featureA]` στην αναθεώρηση 5.
Αυτά λειτουργούν ακριβώς όπως τα υποκαταστήματα Git στην πλευρά του Git, με μια εξαίρεση: δεν μπορείτε να διαγράψετε ένα σελιδοδείκτη από την πλευρά του Git (αυτό είναι ένας περιορισμός των απομακρυσμένων βοηθών).

Μπορείτε να εργαστείτε σε ένα κλάδο `` βαρέων βαρών '' Mercurial επίσης: απλά βάλτε ένα υποκατάστημα στο χώρο namespace `branches ':

[πηγή, κονσόλα]
----
$ git checkout -b υποκαταστήματα / μόνιμα
Μετάβαση σε νέο υποκατάστημα 'branches / permanent'
$ vi Makefile
$ git commit -am 'Μια μόνιμη αλλαγή'
$ git ωθήστε καταστήματα προέλευσης / μόνιμα
Σε hg :: / tmp / γεια
 * [νέο υποκατάστημα] υποκαταστήματα / μόνιμα -> υποκαταστήματα / μόνιμα
----

Εδώ είναι αυτό που μοιάζει με την πλευρά Mercurial:

[πηγή, κονσόλα]
----
$ hg υποκαταστήματα
μόνιμη 7: a4529d07aad4
ανάπτυξη 6: 8f65e5e02793
προεπιλογή 5: bd5ac26f11f9 (ανενεργό)
$ hg log -G
o αλλαγέςset: 7: a4529d07aad4
| υποκατάστημα: μόνιμο
| ετικέτα: άκρη
| γονέας: 5: bd5ac26f11f9
| χρήστης: Ben Straub <ben@straub.cc>
| ημερομηνία: Πέμπ. 14 Αυγ. 20:21:09 2014 -0700
| Περίληψη: Μια μόνιμη αλλαγή
|
| @ changeset: 6: 8f65e5e02793
| / υποκατάστημα: ανάπτυξη
| χρήστης: Ben Straub <ben@straub.cc>
| ημερομηνία: Πέμπ. 14 Αυγ. 20:06:38 2014 -0700
| Περίληψη: Περισσότερες τεκμηρίωση
|
o αλλαγέςset: 5: bd5ac26f11f9
| \ bookmark: featureA
| | γονέας: 4: 0434aa6b91f
| | γονέας: 2: f098c7f45c4f
| | χρήστης: Ben Straub <ben@straub.cc>
| | ημερομηνία: Πέμ. 14 Αυγ. 20:02:21 2014 -0700
| | σύνοψη: Συγχώνευση υποκαταστήματος απομακρυσμένης παρακολούθησης "προέλευση / κύριο"
[...]
----

Το όνομα υποκαταστήματος `` μόνιμο '' καταγράφηκε με το changeet σημειωμένο _7_.

Από την πλευρά του Git, η συνεργασία με οποιοδήποτε από αυτά τα στυλ υποκαταστήματος είναι ίδια: απλώς ελέγξτε, διεκπεραιώστε, φέρετε, συγχωνεύστε, τραβήξτε και πιέστε όπως θα κάνατε κανονικά.
Ένα πράγμα που πρέπει να ξέρετε είναι ότι το Mercurial δεν υποστηρίζει την επανεγγραφή ιστορικού, προσθέτοντας μόνο σε αυτό.
Ακολουθεί η εμφάνιση του Mercurial αποθετηρίου μας μετά από μια διαδραστική αναζωογόνηση και μια ώθηση:

[πηγή, κονσόλα]
----
$ hg log -style compact -G
o 10 [άκρη] 99611176cbc9 2014-08-14 20:21 -0700 Μπεν
| Μια μόνιμη αλλαγή
|
o 9 f23e12f939c3 2014-08-14 20:01 -0700 Μπεν
| Προσθέστε κάποια τεκμηρίωση
|
o 8: 1 c16971d33922 2014-08-14 20:00 -0700 Μπεν
| αντιο σας
|
| o 7: 5 a4529d07aad4 2014-08-14 20:21 -0700 Μπεν
| | Μια μόνιμη αλλαγή
| |
| | @ 6 8f65e5e02793 2014-08-14 20:06 -0700 Μπεν
| / Περισσότερες τεκμηρίωση
| |
| o 5 [χαρακτηριστικόA]: 4,2 bd5ac26f11f9 2014-08-14 20:02 -0700 ben
| | \ Συγχώνευση υποκαταστήματος απομακρυσμένης παρακολούθησης "προέλευση / κύριο"
| | |
| | o 4 0434aa6b91f 2014-08-14 20:01 -0700 Μπεν
| | | ενημερώστε το makefile
| | |
+ --- o 3: 1 318914536c86 2014-08-14 20:00 -0700 Μπεν
| | αντιο σας
| |
| o 2 f098c7f45c4f 2014-08-14 20:01 -0700 Μπεν
| / Προσθέστε κάποια τεκμηρίωση
|
o 1 82e55d328c8c 2005-08-26 01:21 -0700 mpm
| Δημιουργήστε ένα makefile
|
o 0 0a04b987be5a 2005-08-26 01:20 -0700 mpm
     Δημιουργήστε ένα πρότυπο πρόγραμμα "hello, world"
----

Οι αλλαγές_8_, _9_ και _10_ έχουν δημιουργηθεί και ανήκουν στον «μόνιμο» κλάδο, αλλά οι παλιές αλλαγές είναι ακόμα εκεί.
Αυτό μπορεί να είναι * πολύ * σύγχυση για τους συμπαίκτες σας που χρησιμοποιούν Mercurial, οπότε προσπαθήστε να το αποφύγετε.


===== Περίληψη Mercurial

Τα Git και Mercurial είναι αρκετά παρόμοια ώστε η εργασία πέρα ​​από τα όρια είναι αρκετά ανώδυνη.
Εάν αποφύγετε να αλλάξετε την ιστορία που έχει αφήσει το μηχάνημά σας (όπως συνήθως συνιστάται), ίσως να μην γνωρίζετε καν ότι το άλλο άκρο είναι Mercurial.



Ενότητα 9.1.3.

Git and bazaar?????





Ενότητα 9.1.4.

==== Git και Perforce

(((Διαλειτουργικότητα με άλλα VCS, Perforce)))
(((Αναγκαστικά)))
Το Perforce είναι ένα πολύ δημοφιλές σύστημα ελέγχου εκδόσεων σε εταιρικά περιβάλλοντα.
Έχει περάσει από το 1995, γεγονός που το καθιστά το παλαιότερο σύστημα που καλύπτεται σε αυτό το κεφάλαιο.
Ως εκ τούτου, έχει σχεδιαστεί με τους περιορισμούς της ημέρας του. υποθέτει ότι είστε πάντα συνδεδεμένοι σε έναν κεντρικό διακομιστή και ότι διατηρείται μόνο μία έκδοση στον τοπικό δίσκο.
Βεβαίως, τα χαρακτηριστικά και οι περιορισμοί του είναι κατάλληλα για αρκετά συγκεκριμένα προβλήματα, αλλά υπάρχουν πολλά έργα που χρησιμοποιούν το Perforce όπου το Git θα λειτουργούσε πραγματικά καλύτερα.

Υπάρχουν δύο επιλογές αν θέλετε να συνδυάσετε τη χρήση του Perforce και του Git.
Ο πρώτος που θα καλύψουμε είναι η γέφυρα `` Git Fusion '' από τους κατασκευαστές του Perforce, που σας επιτρέπει να εκθέτετε τα subtrees της αποθήκης Perforce ως αποθετήρια Git read-write.
Το δεύτερο είναι το git-p4, μια γέφυρα από την πλευρά του πελάτη, που σας επιτρέπει να χρησιμοποιήσετε το Git ως πελάτη Perforce, χωρίς να απαιτήσετε επανασύνταξη του διακομιστή Perforce.

[[_p4_git_fusion]]
===== Git Fusion

(((Perforce, Git Fusion)))
Το Perforce παρέχει ένα προϊόν που ονομάζεται Git Fusion (διαθέσιμο στο http://www.perforce.com/git-fusion []), το οποίο συγχρονίζει έναν διακομιστή Perforce με αποθετήρια Git στην πλευρά του διακομιστή.

====== Ρύθμιση

Για τα παραδείγματα μας, θα χρησιμοποιήσουμε την πιο εύκολη μέθοδο εγκατάστασης για το Git Fusion, το οποίο μεταφορτώνει μια εικονική μηχανή που τρέχει το δαίμονα Perforce και το Git Fusion.
Μπορείτε να πάρετε την εικόνα της εικονικής μηχανής από το http://www.perforce.com/downloads/Perforce/20-User [], και μόλις ολοκληρωθεί η λήψη, εισαγάγετε το στο αγαπημένο σας λογισμικό εικονικοποίησης (θα χρησιμοποιήσουμε το VirtualBox).

Με την πρώτη εκκίνηση του μηχανήματος, σας ζητά να προσαρμόσετε τον κωδικό πρόσβασης για τρεις χρήστες Linux (`root`,` perforce` και `git`) και να δώσετε ένα όνομα στιγμιότυπου, το οποίο μπορεί να χρησιμοποιηθεί για να διακρίνει αυτή την εγκατάσταση από άλλους στο ίδιο δίκτυο.
Όταν όλα αυτά ολοκληρωθούν, θα δείτε τα εξής:

.Η οθόνη εκκίνησης εικονικής μηχανής Git Fusion.
image :: images / git-fusion-boot.png [Η οθόνη εκκίνησης εικονικής μηχανής Git Fusion.]

Θα πρέπει να λάβετε υπόψη τη διεύθυνση IP που εμφανίζεται εδώ, θα τη χρησιμοποιήσουμε αργότερα.
Στη συνέχεια, θα δημιουργήσουμε έναν χρήστη Perforce.
Επιλέξτε την επιλογή `` Login '' στο κάτω μέρος και πατήστε enter (ή SSH στο μηχάνημα) και συνδεθείτε ως `root '.
Στη συνέχεια, χρησιμοποιήστε αυτές τις εντολές για να δημιουργήσετε έναν χρήστη:

[πηγή, κονσόλα]
----
$ p4 -p localhost: 1666 -u super user -f john
$ p4 -p localhost: 1666 -u john passwd
$ exit
----

Ο πρώτος θα ανοίξει έναν επεξεργαστή VI για να προσαρμόσει τον χρήστη, αλλά μπορείτε να αποδεχτείτε τις προεπιλογές πληκτρολογώντας `: wq` και πατώντας enter.
Η δεύτερη θα σας ζητήσει να εισαγάγετε έναν κωδικό πρόσβασης δύο φορές.
Αυτό είναι όλο που πρέπει να κάνουμε με μια προτροπή κελύφους, οπότε βγείτε από τη συνεδρία.

Το επόμενο πράγμα που πρέπει να κάνετε για να ακολουθήσετε είναι να πείτε στο Git να μην επαληθεύει τα πιστοποιητικά SSL.
Η εικόνα Git Fusion έρχεται με ένα πιστοποιητικό, αλλά είναι για έναν τομέα που δεν ταιριάζει με τη διεύθυνση IP της εικονικής μηχανής σας, οπότε ο Git θα απορρίψει τη σύνδεση HTTPS.
Εάν πρόκειται να γίνει μόνιμη εγκατάσταση, συμβουλευτείτε το εγχειρίδιο Perforce Git Fusion για να εγκαταστήσετε ένα διαφορετικό πιστοποιητικό. για τους σκοπούς των παραδειγμάτων μας, αυτό αρκεί:

[πηγή, κονσόλα]
----
Εξαγωγή $ GIT_SSL_NO_VERIFY = αληθής
----

Τώρα μπορούμε να δοκιμάσουμε ότι όλα λειτουργούν.

[πηγή, κονσόλα]
----
$ git κλώνος https://10.0.1.254/Talkhouse
Κλωνοποίηση σε 'Talkhouse' ...
Όνομα χρήστη για 'https://10.0.1.254': john
Κωδικός πρόσβασης για το "https: //john@10.0.1.254":
απομακρυσμένη: Μέτρηση αντικειμένων: 630, τελειωμένο.
απομακρυσμένη: Συμπίεση αντικειμένων: 100% (581/581), τελείωσε.
απομακρυσμένη: Σύνολο 630 (δέλτα 172), επαναχρησιμοποίηση 0 (δέλτα 0)
Λήψη αντικειμένων: 100% (630/630), 1,22 MiB | 0 byte / s, τελείωσε.
Επίλυση των δελτίων: 100% (172/172), τελείωσε.
Έλεγχος συνδεσιμότητας ... γίνεται.
----

Η εικόνα εικονικής μηχανής έρχεται εξοπλισμένη με ένα δείγμα έργου που μπορείτε να κλωνοποιήσετε.
Εδώ κλωνοποιούμε το HTTPS, με τον χρήστη `john` που δημιουργήσαμε παραπάνω. Το Git ζητά πιστοποιήσεις για αυτήν τη σύνδεση, αλλά η μνήμη cache των διαπιστευτηρίων θα μας επιτρέψει να παραλείψουμε αυτό το βήμα για τυχόν μεταγενέστερα αιτήματα.

====== Ρύθμιση συγχώνευσης

Μόλις εγκαταστήσετε το Git Fusion, θα χρειαστεί να τροποποιήσετε τη διαμόρφωση.
Αυτό είναι πραγματικά αρκετά εύκολο να κάνει χρησιμοποιώντας το αγαπημένο πελάτη Perforce σας? απλά χαρτογραφήστε τον κατάλογο `// .git-fusion` στον διακομιστή Perforce στον χώρο εργασίας σας.
Η δομή του αρχείου φαίνεται έτσι:

[πηγή, κονσόλα]
----
$ tree
.
├── αντικείμενα
│ ├── repos
│ │ └── [...]
│ └── δέντρα
│ └── [...]
│
├── p4gf_config
├── repos
│ └── Talkhouse
│ └── p4gf_config
└── χρήστες
    └── p4gf_usermap

498 καταλόγους, 287 αρχεία
----

Ο κατάλογος των αντικειμένων χρησιμοποιείται εσωτερικά από το Git Fusion για να χαρτογραφήσει τα αντικείμενα Perforce στο Git και το αντίστροφο, δεν θα χρειαστεί να χάσετε τίποτα εκεί.
Υπάρχει ένα παγκόσμιο αρχείο `p4gf_config` σε αυτόν τον κατάλογο, καθώς και ένα για κάθε αποθετήριο - αυτά είναι τα αρχεία ρυθμίσεων που καθορίζουν τον τρόπο συμπεριφοράς του Git Fusion.
Ας ρίξουμε μια ματιά στο αρχείο στη ρίζα:

[πηγή, ini]
----
[δημιουργία επαναγοράς]
charset = utf8

[git-to-force]
ιδιοκτήτης αλλαγής = συγγραφέας
enable-git-branch-creation = ναι
enable-swarm-reviews = y

ignore-author-permissions = όχι
read-permission-check = κανένα
git-συγχώνευση-αποφυγή-μετά-αλλαγή-num = 12107

[επίλυση-προς-git]
http-url = κανένα
ssh-url = κανένα

[@χαρακτηριστικά]
εισαγωγές = ψευδές
chunked-push = Λάθος
matrix2 = Λάθος
παράλληλη ώθηση = ψευδής

[αυθεντικοποίηση]
ευαισθησία σε περίπτωση ηλεκτρονικού ταχυδρομείου = όχι
----

Δεν θα πάμε εδώ στις σημασίες αυτών των σημαιών, αλλά σημειώστε ότι αυτό είναι μόνο ένα αρχείο κειμένου μορφοποιημένο σε μορφή INI, όπως ακριβώς χρησιμοποιεί η Git για τη διαμόρφωση.
Αυτό το αρχείο καθορίζει τις γενικές επιλογές, οι οποίες μπορούν στη συνέχεια να αντικατασταθούν από συγκεκριμένα αρχεία ρυθμίσεων αποθετηρίου, όπως `repos / Talkhouse / p4gf_config`.
Εάν ανοίξετε αυτό το αρχείο, θα δείτε μια ενότητα `[@repo]` με ορισμένες ρυθμίσεις που διαφέρουν από τις καθολικές προεπιλογές.
Θα δείτε επίσης τμήματα που μοιάζουν με αυτά:

[πηγή, ini]
----
[Talkhouse-master]
git-branch-name = master
προβολή = // αποθήκη / Talkhouse / main-dev / ... ...
----

Πρόκειται για χαρτογράφηση μεταξύ υποκαταστήματος Perforce και υποκαταστήματος Git.
Η ενότητα μπορεί να ονομαστεί ό, τι θέλετε, αρκεί το όνομα να είναι μοναδικό.
`git-branch-name` σας επιτρέπει να μετατρέψετε μια διαδρομή αποθήκης που θα ήταν περίπλοκη κάτω από το Git σε ένα πιο φιλικό όνομα.
Η ρύθμιση "προβολή" ελέγχει τον τρόπο χαρτογράφησης των αρχείων Perforce στο αποθετήριο Git χρησιμοποιώντας τη σύνταξη χαρτογράφησης τυπικής προβολής.
Μπορούν να καθοριστούν περισσότερες από μία χαρτογραφήσεις, όπως σε αυτό το παράδειγμα:

[πηγή, ini]
----
[χαρτογράφηση πολλαπλών έργων]
git-branch-name = master
προβολή = // αποθήκη / project1 / main / ... project1 / ...
       // αποθήκη / project2 / mainline / ... project2 / ...
----

Με αυτό τον τρόπο, εάν η κανονική χαρτογράφηση του χώρου εργασίας σας περιλαμβάνει αλλαγές στη δομή των καταλόγων, μπορείτε να το αναπαράγετε με ένα αποθετήριο Git.

Το τελευταίο αρχείο που θα συζητήσουμε είναι `users / p4gf_usermap`, το οποίο χαρτώνει τους χρήστες Perforce στους χρήστες του Git και ίσως δεν χρειάζεται καν.
Κατά τη μετατροπή από μια σειρά αλλαγών Perforce σε μια δέσμευση Git, η προεπιλεγμένη συμπεριφορά του Git Fusion είναι να αναζητήσει τον χρήστη Perforce και να χρησιμοποιήσει τη διεύθυνση ηλεκτρονικού ταχυδρομείου και το πλήρες όνομα που έχει αποθηκευτεί εκεί για το πεδίο συγγραφέα / εντολέα στο Git.
Κατά τη μετατροπή του άλλου τρόπου, η προεπιλογή είναι να αναζητήσετε τον χρήστη Perforce με τη διεύθυνση ηλεκτρονικού ταχυδρομείου που είναι αποθηκευμένη στο πεδίο συγγραφέα της δέσμευσης Git και να υποβάλετε το set changeset ως αυτόν τον χρήστη (με την εφαρμογή των δικαιωμάτων).
Στις περισσότερες περιπτώσεις, αυτή η συμπεριφορά θα κάνει μια χαρά, αλλά εξετάστε το ακόλουθο αρχείο χαρτογράφησης:

[πηγή]
----
john john@example.com "John Doe"
john johnny@appleseed.net "John Doe"
bob employeeX@example.com "Anon X. Mouse"
joe employeeY@example.com "Anon Y. Mouse"
----

Κάθε γραμμή έχει τη μορφή `<user> <email>" <full name> "και δημιουργεί μία μόνο χαρτογράφηση χρήστη.
Οι δύο πρώτες γραμμές αντιστοιχούν δύο διαφορετικές διευθύνσεις ηλεκτρονικού ταχυδρομείου στον ίδιο λογαριασμό χρήστη Perforce.
Αυτό είναι χρήσιμο αν έχετε δημιουργήσει δεσμεύσεις Git κάτω από πολλές διαφορετικές διευθύνσεις ηλεκτρονικού ταχυδρομείου (ή να αλλάξετε διευθύνσεις ηλεκτρονικού ταχυδρομείου), αλλά θέλετε να αντιστοιχιστούν στον ίδιο χρήστη Perforce.
Κατά τη δημιουργία μιας δέσμευσης Git από ένα σύνολο αλλαγών Perforce, η πρώτη γραμμή που ταιριάζει με τον χρήστη Perforce χρησιμοποιείται για τις πληροφορίες συγγραφέων Git.

Οι τελευταίες δύο γραμμές καλύπτουν τα πραγματικά ονόματα και τις διευθύνσεις ηλεκτρονικού ταχυδρομείου του Bob και του Joe από τις δεσμεύσεις του Git που δημιουργούνται.
Αυτό είναι ωραίο αν θέλετε να ανοίξετε ένα εσωτερικό έργο, αλλά δεν θέλετε να δημοσιεύσετε τον κατάλογο των υπαλλήλων σας σε ολόκληρο τον κόσμο.
Σημειώστε ότι οι διευθύνσεις ηλεκτρονικού ταχυδρομείου και τα πλήρη ονόματα θα πρέπει να είναι μοναδικά, εκτός αν θέλετε όλες οι δεσμεύσεις του Git να αποδοθούν σε ένα μόνο φανταστικό συγγραφέα.

====== Ροή εργασιών

Το Perforce Git Fusion είναι μια αμφίδρομη γέφυρα μεταξύ του ελέγχου της έκδοσης Perforce και Git.
Ας ρίξουμε μια ματιά στο πώς αισθάνεται να εργάζεται από την πλευρά του Git.
Υποθέτουμε ότι έχουμε χαρτογραφήσει το έργο `` Jam '' χρησιμοποιώντας ένα αρχείο διαμόρφωσης όπως φαίνεται παραπάνω, τον οποίο μπορούμε να κλωνοποιήσουμε ως εξής:

[πηγή, κονσόλα]
----
$ git κλώνος https://10.0.1.254/Jam
Κλωνοποίηση σε 'Jam' ...
Όνομα χρήστη για 'https://10.0.1.254': john
Κωδικός πρόσβασης για το "https: //ben@10.0.1.254":
απομακρυσμένη: Μετρώντας αντικείμενα: 2070, τελείωσε.
απομακρυσμένη: Συμπίεση αντικειμένων: 100% (1704/1704), τελείωσε.
Λήψη αντικειμένων: 100% (2070/2070), 1,21 MiB | 0 byte / s, τελείωσε.
απομακρυσμένη: Σύνολο 2070 (δέλτα 1242), επαναχρησιμοποίηση 0 (δέλτα 0)
Επίλυση των δελτίων: 100% (1242/1242).
Έλεγχος συνδεσιμότητας ... γίνεται.
Υποκατάστημα $ git -a
* πλοίαρχος
  τηλεχειριστήρια / προέλευση / HEAD -> προέλευση / κύριο
  τηλεχειριστήρια / προέλευση / κύριο
  remotes / προέλευση / rel2.1
$ git log --online --decorate --graph - όλα
* 0a38c33 (προέλευση / rel2.1) Δημιουργία θυρίδας κυκλοφορίας Jam 2.1.
| * d254865 (HEAD, προέλευση / πλοίαρχος, προέλευση / HEAD, master) Αναβαθμίστε τα τελευταία μηχανήματα στο Beos - το Intel.
| * bd2f54a Βάλτε την επιδιόρθωση για τη διαρροή λαβής NT της μαρμελάδας.
| * c0f29e7 Διόρθωση διεύθυνσης URL σε έγγραφο εμπλοκής
| * cc644ac Λύκος λυγισμού Radstone.
[...]
----

Την πρώτη φορά που το κάνετε αυτό, ίσως χρειαστεί λίγος χρόνος.
Αυτό που συμβαίνει είναι ότι το Git Fusion μετατρέπει όλες τις εφαρμοστέες αλλαγές στο ιστορικό Perforce σε Git δεσμεύσεις.
Αυτό συμβαίνει τοπικά στο διακομιστή, επομένως είναι σχετικά γρήγορο, αλλά αν έχετε πολλή ιστορία, μπορεί να χρειαστεί λίγος χρόνος.
Οι μεταγενέστερες προσθήκες πραγματοποιούν αυξημένη μετατροπή, έτσι θα αισθανθείτε σαν τη μητρική ταχύτητα του Git.

Όπως μπορείτε να δείτε, το αποθετήριό μας μοιάζει ακριβώς όπως οποιοδήποτε άλλο αποθετήριο Git με το οποίο μπορείτε να εργαστείτε.

Υπάρχουν τρία υποκαταστήματα και ο Git δημιούργησε ένα τοπικό υποκατάστημα «master» που εντοπίζει «προέλευση / κύριο».
Ας κάνουμε λίγο δουλειά και δημιουργούμε μερικές νέες δεσμεύσεις:

[πηγή, κονσόλα]
----
# ...
$ git log --online --decorate --graph - όλα
* cfd46ab (HEAD, master) Προσθέστε τεκμηρίωση για νέα λειτουργία
* a730d77
* d254865 (προέλευση / πλοίαρχος, προέλευση / HEAD) Αναβαθμίστε τα τελευταία μηχανήματα στο Beos - το Intel.
* bd2f54a Βάλτε την επιδιόρθωση για τη διαρροή λαβής NT της μαρμελάδας.
[...]
----

Έχουμε δύο νέες δεσμεύσεις.
Τώρα ας ελέγξουμε αν κάποιος άλλος δουλεύει:

[πηγή, κονσόλα]
----
$ git fetch
απομακρυσμένη: Μετρώντας τα αντικείμενα: 5, τελειωμένο.
απομακρυσμένη: Συμπίεση αντικειμένων: 100% (3/3), τελείωσε.
απομακρυσμένη: Σύνολο 3 (δέλτα 2), επαναχρησιμοποίηση 0 (δέλτα 0)
Αποσυμπιέστε αντικείμενα: 100% (3/3), τελείωσε.
Από https://10.0.1.254/Jam
   d254865..6afeb15 master -> προέλευση / κύριο
$ git log --online --decorate --graph - όλα
* 6afeb15 (προέλευση / πλοίαρχος, προέλευση / HEAD) Ενημέρωση πνευματικών δικαιωμάτων
| * cfd46ab (HEAD, master) Προσθέστε τεκμηρίωση για νέα λειτουργία
| * a730d77
| /
* d254865 Αναβάθμιση σε τελευταίες metrowerks στον Beos - το Intel.
* bd2f54a Βάλτε την επιδιόρθωση για τη διαρροή λαβής NT της μαρμελάδας.
[...]
----

Μοιάζει με κάποιον!
Δεν θα το γνωρίζατε από αυτήν την άποψη, αλλά η δέσμευση `6afeb15` δημιουργήθηκε στην πραγματικότητα χρησιμοποιώντας έναν πελάτη Perforce.
Απλώς μοιάζει με μια άλλη δέσμευση από την άποψη του Git, που είναι ακριβώς το σημείο.
Ας δούμε πώς αντιμετωπίζει ο διακομιστής Perforce μια δέσμευση συγχώνευσης:

[πηγή, κονσόλα]
----
$ git συγχώνευση προέλευσης / κύριος
Αυτόματη συγχώνευση του README
Συγχώνευση από την «αναδρομική» στρατηγική.
 README | 2 + -
 1 αρχείο άλλαξε, 1 εισαγωγή (+), 1 διαγραφή (-)
$ git push
Μετρώντας αντικείμενα: 9, τελείωσε.
Συμπίεση Delta χρησιμοποιώντας έως και 8 νήματα.
Συμπίεση αντικειμένων: 100% (9/9), τελείωσε.
Γράψιμο αντικειμένων: 100% (9/9), 917 bytes 0 byte / s, τελείωσε.
Σύνολο 9 (δέλτα 6), επαναχρησιμοποίηση 0 (δέλτα 0)
απομακρυσμένο: Perforce: 100% (3/3) Φόρτωση δέντρου εμπιστοσύνης στη μνήμη ...
απομακρυσμένη: Περίπτωση: 100% (5/5) Βρίσκοντας παιδί δεσμεύεται ...
απομακρυσμένη: Perforce: Running git fast-export ...
απομακρυσμένη: Επιτόπια: 100% (3/3) Ο έλεγχος δεσμεύεται ...
απομακρυσμένη: Η επεξεργασία θα συνεχιστεί ακόμη και αν η σύνδεση είναι κλειστή.
απομακρυσμένη: Περίπτωση: 100% (3/3) Αλλαγή καταλόγων αντιγραφής ...
απομακρυσμένο: Perforce: Υποβολή νέων αντικειμένων Git commit σε Perforce: 4
Για να https://10.0.1.254/Jam
   Master 6afeb15..89cba2b master
----

Ο Git νομίζει ότι λειτούργησε.
Ας ρίξουμε μια ματιά στο ιστορικό του αρχείου `README` από την άποψη της Perforce, χρησιμοποιώντας το χαρακτηριστικό γράφου αναθεώρησης του` p4v`:

.Κατάλληλο γράφημα αναθεώρησης που προκύπτει από την ώθηση Git.
image :: images / git-fusion-perforce-graph.png [Σχετικό γράφημα αναθεώρησης που προκύπτει από την ώθηση Git.]

Εάν δεν έχετε δει ποτέ αυτήν την άποψη πριν, μπορεί να φαίνεται συγκεχυμένη, αλλά δείχνει τις ίδιες έννοιες με έναν γραφικό θεατή για την ιστορία του Git.
Εξετάζουμε την ιστορία του αρχείου `README`, έτσι ώστε το δέντρο καταλόγων στο πάνω αριστερό μέρος δείχνει μόνο αυτό το αρχείο καθώς επιτίθεται σε διάφορους κλάδους.
Στην επάνω δεξιά στήλη, έχουμε ένα οπτικό γράφημα για το πώς σχετίζονται οι διαφορετικές αναθεωρήσεις του αρχείου και η προβολή μεγάλης εικόνας αυτού του γραφήματος βρίσκεται στο κάτω δεξιά μέρος.
Η υπόλοιπη προβολή δίνεται στην προβολή λεπτομερειών για την επιλεγμένη αναθεώρηση ("2" σε αυτή την περίπτωση).

Ένα πράγμα που πρέπει να παρατηρήσετε είναι ότι το γράφημα μοιάζει ακριβώς με το ιστορικό του Git.
Η Perforce δεν είχε όνομα υποκαταστήματος για να αποθηκεύσει τις δεσμεύσεις `1` και` 2`, έτσι έκανε ένα «ανώνυμο» κατάστημα στον κατάλογο `.git-fusion` για να το κρατήσει.
Αυτό θα συμβεί επίσης για τα ονόματα θυγατρικών Git που δεν αντιστοιχούν σε ένα όνομα κλάδο Perforce (και μπορείτε αργότερα να τα αντιστοιχίσετε σε υποκατάστημα Perforce χρησιμοποιώντας το αρχείο διαμόρφωσης).

Τα περισσότερα από αυτά συμβαίνουν πίσω από τις σκηνές, αλλά το τελικό αποτέλεσμα είναι ότι ένα άτομο σε μια ομάδα μπορεί να χρησιμοποιεί το Git, άλλο μπορεί να χρησιμοποιεί το Perforce και κανένας από αυτούς δεν θα γνωρίζει την επιλογή του άλλου.

====== Περίληψη Git-Fusion

Εάν έχετε (ή μπορείτε να αποκτήσετε) πρόσβαση στο διακομιστή Perforce σας, το Git Fusion είναι ένας πολύ καλός τρόπος για να κάνετε το Git και το Perforce να μιλάνε ο ένας στον άλλο.
Υπάρχουν κάποιες ρυθμίσεις, αλλά η καμπύλη μάθησης δεν είναι πολύ απότομη.
Αυτή είναι μία από τις λίγες ενότητες αυτού του κεφαλαίου όπου δεν θα εμφανιστούν προειδοποιήσεις σχετικά με τη χρήση της πλήρους ισχύος του Git.
Αυτό δεν σημαίνει ότι η Perforce θα είναι ευχαριστημένη από όλα όσα ρίχνετε σε αυτήν - αν προσπαθήσετε να ξαναγράψετε την ιστορία που έχει ήδη ωθηθεί, η Git Fusion θα την απορρίψει - αλλά η Git Fusion προσπαθεί πολύ σκληρά να νιώσει τη μητρική της.
Μπορείτε ακόμα να χρησιμοποιήσετε τα υποσύνολα Git (αν και θα φαίνονται περίεργα στους χρήστες Perforce) και να συγχωνεύσετε κλάδους (αυτό θα καταγραφεί ως ενσωμάτωση στην πλευρά Perforce).

Εάν δεν μπορείτε να πείσετε τον διαχειριστή του διακομιστή σας να ρυθμίσει το Git Fusion, υπάρχει ακόμα ένας τρόπος να χρησιμοποιήσετε αυτά τα εργαλεία μαζί.

===== Git-p4

(((εντολές git, p4)))
Το Git-p4 είναι μια αμφίδρομη γέφυρα μεταξύ Git και Perforce.
Τρέχει εξ ολοκλήρου μέσα στο αποθετήριο Git, επομένως δεν θα χρειαστεί κανενός είδους πρόσβαση στο διακομιστή Perforce (διαφορετικά από τα διαπιστευτήρια χρήστη, φυσικά).
Το Git-p4 δεν είναι τόσο ευέλικτο ούτε ολοκληρωμένο ως λύση όπως το Git Fusion, αλλά σας επιτρέπει να κάνετε τα περισσότερα από όσα θέλετε να κάνετε χωρίς να εισχωρήσετε στο περιβάλλον διακομιστή.

[ΣΗΜΕΙΩΣΗ]
======
Θα χρειαστείτε το εργαλείο `p4` κάπου στο` PATH` για να εργαστείτε με το git-p4.
Από αυτή τη γραφή, είναι ελεύθερα διαθέσιμη στη διεύθυνση http://www.perforce.com/downloads/Perforce/20-User [].
======

====== Ρύθμιση

Για παράδειγμα, θα τρέχουμε τον διακομιστή Perforce από το Git Fusion OVA, όπως φαίνεται παραπάνω, αλλά θα παρακάμψουμε το διακομιστή Git Fusion και θα πάμε κατευθείαν στον έλεγχο έκδοσης Perforce.

Για να χρησιμοποιήσετε τον πελάτη γραμμής εντολών `p4` (από τον οποίο εξαρτάται το git-p4), θα χρειαστεί να ορίσετε μερικές μεταβλητές περιβάλλοντος:

[πηγή, κονσόλα]
----
$ εξαγωγή P4PORT = 10.0.1.254: 1666
$ export P4USER = john
----

====== Ξεκινώντας

Όπως και με οτιδήποτε στο Git, η πρώτη εντολή είναι να κλωνοποιήσετε:

[πηγή, κονσόλα]
----
$ git p4 κλώνος // αποθήκη / www / live www-ρηχά
Εισαγωγή από // depot / www / live σε www-ρηχά
Αρχικό κενό αποθετήριο Git στο /private/tmp/www-shallow/.git/
Πραγματοποιώντας την αρχική εισαγωγή του // depot / www / live / από την αναθεώρηση #head σε refs / remotes / p4 / master
----

Αυτό δημιουργεί ό, τι στους όρους Git είναι ένας «ρηχός» κλώνος. μόνο η τελευταία αναθεώρηση Perforce εισάγεται στο Git. θυμηθείτε, το Perforce δεν έχει σχεδιαστεί για να παρέχει κάθε αναθεώρηση σε κάθε χρήστη.
Αυτό αρκεί για να χρησιμοποιήσει το Git ως πελάτη Perforce, αλλά για άλλους σκοπούς δεν είναι αρκετό.

Μόλις τελειώσει, έχουμε έναν πλήρως λειτουργικό αποθετήριο Git:

[πηγή, κονσόλα]
----
$ cd myproject
$ git log --online --all --graph --decorate
* 70eaf78 (HEAD, p4 / master, p4 / HEAD, master) Αρχική εισαγωγή του // depot / www / live / από την πολιτεία στην έκδοση #head
----

Σημειώστε πως υπάρχει ένα απομακρυσμένο `` p4 '' για το διακομιστή Perforce, αλλά όλα όσα μοιάζουν με έναν πρότυπο κλώνο.
Στην πραγματικότητα, αυτό είναι λίγο παραπλανητικό. δεν υπάρχει πραγματικά ένα απομακρυσμένο εκεί.

[πηγή, κονσόλα]
----
$ git απομακρυσμένη -v
----

Δεν υπάρχουν απομακρυσμένες μονάδες σε αυτήν την αποθήκη καθόλου.
Το Git-p4 δημιούργησε κάποιους λόγους ώστε να αντιπροσωπεύει την κατάσταση του διακομιστή και μοιάζουν με απομακρυσμένες αναφορές στο `git log`, αλλά δεν διαχειρίζονται από το ίδιο το Git και δεν μπορείτε να τους σπρώξετε.

====== Ροή εργασιών

Εντάξει, ας δουλέψουμε.
Ας υποθέσουμε ότι έχετε σημειώσει κάποια πρόοδο σε ένα πολύ σημαντικό χαρακτηριστικό και είστε έτοιμοι να το δείξετε στην υπόλοιπη ομάδα σας.

[πηγή, κονσόλα]
----
$ git log --online --all --graph --decorate
* 018467c (HEAD, master) Αλλαγή τίτλου σελίδας
* c0fb617 Ενημέρωση συνδέσμου
* 70eaf78 (p4 / master, p4 / HEAD) Αρχική εισαγωγή του // depot / www / live / από το κράτος στην έκδοση #head
----

Έχουμε κάνει δύο νέες δεσμεύσεις ότι είμαστε έτοιμοι να υποβάλετε στο διακομιστή Perforce.
Ας ελέγξουμε αν κάποιος άλλος δούλευε σήμερα:

[πηγή, κονσόλα]
----
$ git p4 sync
git p4 sync
Πραγματοποίηση αυξητικής εισαγωγής σε κλάδους refs / remotes / p4 / master git
Διαδρομές αποθήκης: // depot / www / live /
Προορισμός εισαγωγής: refs / remotes / p4 / master
Εισαγωγή αναθεώρησης 12142 (100%)
$ git log --online --all --graph --decorate
* 75cd059 (p4 / master, p4 / HEAD) Ενημέρωση πνευματικών δικαιωμάτων
| * 018467c (HEAD, master) Αλλαγή τίτλου σελίδας
| * c0fb617 Ενημέρωση συνδέσμου
| /
* 70eaf78 Αρχική εισαγωγή του // depot / www / live / από το κράτος στην έκδοση #head
----

Φαίνεται ότι ήταν, και οι «master» και «p4 / master» έχουν αποκλίνει.
Το σύστημα διακλάδωσης της Perforce δεν είναι όπως το Git, οπότε η υποβολή δεσμεύσεων συγχώνευσης δεν έχει νόημα.
Το Git-p4 συνιστά να αναδιοργανώσετε τις δεσμεύσεις σας και έρχεται ακόμη και με μια συντόμευση για να το κάνετε:

[πηγή, κονσόλα]
----
$ git p4 rebase
Πραγματοποίηση αυξητικής εισαγωγής σε κλάδους refs / remotes / p4 / master git
Διαδρομές αποθήκης: // depot / www / live /
Δεν υπάρχουν αλλαγές στην εισαγωγή!
Επανεκκίνηση του τρέχοντος κλάδου σε remotes / p4 / master
Αρχικά, επανατοποθετήστε το κεφάλι για να επαναλάβετε την εργασία σας πάνω από το ...
Εφαρμογή: Σύνδεσμος ενημέρωσης
30 τη τη not not τη not τη not not not not τη30 year τη τη not not not not not not not not not not not not not not not30 τη30 not τη τη not not
 index.html | 2 + -
 1 αρχείο άλλαξε, 1 εισαγωγή (+), 1 διαγραφή (-)
----

Μπορεί πιθανώς να το πείτε από την έξοδο, αλλά το `git p4 rebase` είναι μια συντόμευση για το` git p4 sync` ακολουθούμενη από `git rebase p4 / master`.
Είναι λίγο πιο έξυπνο από αυτό, ειδικά όταν εργάζεστε με πολλαπλούς κλάδους, αλλά αυτό είναι μια καλή προσέγγιση.

Τώρα η ιστορία μας είναι και πάλι γραμμική και είμαστε έτοιμοι να συνεισφέρουμε τις αλλαγές μας στο Perforce.
Η εντολή `git p4 submit` θα προσπαθήσει να δημιουργήσει μια νέα έκδοση Perforce για κάθε διαπραγμάτευση Git μεταξύ` p4 / master 'και `master'.
Το τρέξιμο μας πέφτει στον αγαπημένο μας επεξεργαστή και το περιεχόμενο του αρχείου μοιάζει με αυτό:

[πηγή, κονσόλα]
----
# Μια προδιαγραφή αλλαγής.
# #
Τη τη3030 τη not3030 not30 τη not not not τη τη τη not τη τη τη τη not τη not not τη τη not not τη τη τη not not not τη τη not not 'νέο' σε νέο κατάλογο αλλαγών.
# Ημερομηνία: Η ημερομηνία τροποποίησης της τελευταίας αυτής παραμέτρου.
# Client: Ο πελάτης στον οποίο δημιουργήθηκε ο changelist. Μόνο για ανάγνωση.
# User: Ο χρήστης που δημιούργησε το changelist.
Αλλαγή: νέα

Πελάτης: john_bens-mbp_8487

Χρήστης: john

Κατάσταση: νέο

Περιγραφή:
   Ενημέρωση συνδέσμου

Αρχεία:
   //depot/www/live/index.html # επεξεργασία


######## git ο συντάκτης ben@straub.cc δεν ταιριάζει με τον λογαριασμό σας στο p4.
######## Χρησιμοποιήστε την επιλογή --preserve-user για να τροποποιήσετε την ιδιότητα του δημιουργού.
######## Μεταβλητή git-p4.skipUserNameCheck κρύβει αυτό το μήνυμα.
######## Τα πάντα κάτω από αυτή τη γραμμή είναι μόνο η διαφορά #######
--- //depot/www/live/index.html 2014-08-31 18: 26: 05.000000000 0000
+++ /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/index.html 2014-08-31 18: 26: 05.000000000 0000
@@ -60,7 +60,7 @@
 </ td>
 <td valign = κορυφή>
 Πηγή και τεκμηρίωση για
- <a href="http://www.perforce.com/jam/jam.html">
+ <a href="jam.html">
 Jam / MR </a>,
 ένα εργαλείο δημιουργίας λογισμικού.
 </ td>
----

Αυτό είναι ως επί το πλείστον το ίδιο περιεχόμενο που θα βλέπατε τρέχοντας `p4 submit ', εκτός από τα πράγματα στο τέλος που git-p4 έχει συμπεριληφθεί.
Το Git-p4 προσπαθεί να τιμά τις ρυθμίσεις Git και Perforce ξεχωριστά όταν πρέπει να παράσχει ένα όνομα για μια δέσμευση ή μια ομάδα αλλαγών, αλλά σε ορισμένες περιπτώσεις θέλετε να το αντικαταστήσετε.
Για παράδειγμα, εάν η δέσμευση Git που εισάγετε γράφτηκε από έναν συνεισφέροντα που δεν διαθέτει λογαριασμό χρήστη Perforce, ίσως θέλετε τα προκύπτοντα changeset να μοιάζουν με αυτά που γράφετε (και όχι εσείς).

Το Git-p4 εισήγαγε με προσοχή το μήνυμα από τη δέσμευση Git ως το περιεχόμενο αυτής της δέσμης αλλαγών Perforce, οπότε το μόνο που έχουμε να κάνουμε είναι να αποθηκεύσουμε και να το κόψουμε δύο φορές (μία φορά για κάθε δέσμευση).
Η προκύπτουσα έξοδος κελύφους θα φαίνεται κάπως έτσι:

[πηγή, κονσόλα]
----
Υποβολή $ git p4
Έλεγχος κατά την αποθήκη για αποθήκη διαδρομής // depot / www / live / που βρίσκεται στο / Χρήστες / ben / john_bens-mbp_8487 / john_bens-mbp_8487 / depot / www / live /
Συγχρονισμός πληρωμής p4 ...
... - αρχεία ενημερωμένα.
Εφαρμογή σύνδεσης dbac45b Update
//depot/www/live/index.html#4 - άνοιξε για επεξεργασία
Αλλαγή 12143 δημιουργήθηκε με 1 ανοιχτό αρχείο (ες).
Υποβολή αλλαγής 12143.
Κλείδωμα 1 αρχείων ...
επεξεργασία //depot/www/live/index.html#5
Αλλαγή 12143 υποβληθεί.
Εφαρμογή 905ec6a Αλλαγή τίτλου σελίδας
//depot/www/live/index.html#5 - άνοιξε για επεξεργασία
Αλλαγή 12144 δημιουργήθηκε με 1 ανοιχτό αρχείο (ες).
Υποβολή αλλαγής 12144.
Κλείδωμα 1 αρχείων ...
επεξεργασία //depot/www/live/index.html#6
Αλλαγή 12144 υποβληθεί.
Όλες οι δεσμεύσεις εφαρμόζονται!
Πραγματοποίηση αυξητικής εισαγωγής σε κλάδους refs / remotes / p4 / master git
Διαδρομές αποθήκης: // depot / www / live /
Προορισμός εισαγωγής: refs / remotes / p4 / master
Εισαγωγή αναθεώρησης 12144 (100%)
Επανεκκίνηση του τρέχοντος κλάδου σε remotes / p4 / master
Αρχικά, επανατοποθετήστε το κεφάλι για να επαναλάβετε την εργασία σας πάνω από το ...
$ git log --online --all --graph --decorate
* 775a46f (HEAD, p4 / master, p4 / HEAD, master) Αλλαγή τίτλου σελίδας
* 05f1ade Ενημέρωση σύνδεσμος
* 75cd059 Ενημέρωση πνευματικών δικαιωμάτων
* 70eaf78 Αρχική εισαγωγή του // depot / www / live / από το κράτος στην έκδοση #head
----

Το αποτέλεσμα είναι σαν να κάναμε ένα `git push ', το οποίο είναι η πιο κοντινή αναλογία με αυτό που πραγματικά συνέβη.

Λάβετε υπόψη ότι κατά τη διάρκεια αυτής της διαδικασίας, κάθε δέσμευση Git μετατρέπεται σε ένα σύνολο αλλαγών Perforce. αν θέλετε να τα καταρρίψετε σε ένα ενιαίο σύνολο αλλαγών, μπορείτε να το κάνετε αυτό με μια διαδραστική ανανέωση πριν τρέξετε το `git p4 submit`.
Επίσης, σημειώστε ότι οι SHA-1 hashes όλων των δεσμεύσεων που υποβλήθηκαν ως changesets έχουν αλλάξει. αυτό συμβαίνει επειδή το git-p4 προσθέτει μια γραμμή στο τέλος κάθε δέσμευσης που μετατρέπει:

[πηγή, κονσόλα]
----
$ git log -1
commit 775a46f630d8b46535fc9983cf3ebe6b9aa53145
Συντάκτης: John Doe <john@example.com>
Ημερομηνία: Κυρ 31 Αυγούστου 10:31:44 2014 -0800

    Αλλαγή τίτλου σελίδας

    [git-p4: αποθήκες-διαδρομές = "// αποθήκη / www / live /": change = 12144]
----

Τι θα συμβεί αν προσπαθήσετε να υποβάλετε μια δέσμευση συγχώνευσης;
Ας το δοκιμάσουμε.
Ακολουθεί η κατάσταση στην οποία βρισκόμαστε:

[πηγή, κονσόλα]
----
$ git log --online --all --graph --decorate
* 3be6fd8 (HEAD, master) Σωστή διεύθυνση ηλεκτρονικού ταχυδρομείου
* 1dcbf21 Συγχώνευση υποκαταστήματος απομακρυσμένης παρακολούθησης 'p4 / master'
| \
| * c4689fc (p4 / master, p4 / HEAD) Καθορισμός γραμματικής
* | cbacd0a Τραπέζια σύνορα: ναι παρακαλώ
* | b4959b6 Εμπορικό σήμα
| /
* 775a46f Αλλαγή τίτλου σελίδας
* 05f1ade Ενημέρωση σύνδεσμος
* 75cd059 Ενημέρωση πνευματικών δικαιωμάτων
* 70eaf78 Αρχική εισαγωγή του // depot / www / live / από το κράτος στην έκδοση #head
----

Η ιστορία Git και Perforce αποκλίνει μετά από 775a46f.
Η πλευρά του Git έχει δύο δεσμεύσεις, στη συνέχεια μια συγχώνευση δεσμεύεται με το κεφάλι Perforce, έπειτα ένα άλλο commit.
Θα προσπαθήσουμε να τα υποβάλουμε στην κορυφή μιας ενιαίας ομάδας αλλαγών στην πλευρά Perforce.
Ας δούμε τι θα συμβεί αν προσπαθήσουμε να υποβάλουμε τώρα:

[πηγή, κονσόλα]
----
$ git p4 υποβάλετε -n
Έλεγχος κατά την αποθήκη για αποθήκη διαδρομής // depot / www / live / που βρίσκεται στο / Χρήστες / ben / john_bens-mbp_8487 / john_bens-mbp_8487 / depot / www / live /
Θα συγχρονίζονταν το check p4 στο / Users / ben / john_bens-mbp_8487 / john_bens-mbp_8487 / depot / www / live /
Ισχύει
  b4959b6 Εμπορικό σήμα
  cbacd0a Τραπέζια σύνορα: ναι παρακαλώ
  3be6fd8 Σωστή διεύθυνση ηλεκτρονικού ταχυδρομείου
----

Η σημαία `-n` είναι σύντομη για το` --dry-run`, το οποίο προσπαθεί να αναφέρει τι θα συνέβαινε εάν η εντολή υποβολής εκτελέστηκε για πραγματική.
Σε αυτήν την περίπτωση, φαίνεται ότι θα δημιουργούσαμε τρία σύνολα αλλαγών Perforce, τα οποία αντιστοιχούν στις τρεις δεσμεύσεις μη συγχώνευσης που δεν υπάρχουν ακόμα στον διακομιστή Perforce.
Αυτό ακούγεται ακριβώς όπως θέλουμε, ας δούμε πώς αποδεικνύεται:

[πηγή, κονσόλα]
----
Υποβολή $ git p4
[...]
$ git log --online --all --graph --decorate
* dadbd89 (HEAD, p4 / master, p4 / HEAD, master) Σωστή διεύθυνση ηλεκτρονικού ταχυδρομείου
* 1b79a80 Τραπέζια σύνορα: ναι, παρακαλώ
* 0097235 Εμπορικό σήμα
* c4689fc Καθορισμός γραμματικής
* 775a46f Αλλαγή τίτλου σελίδας
* 05f1ade Ενημέρωση σύνδεσμος
* 75cd059 Ενημέρωση πνευματικών δικαιωμάτων
* 70eaf78 Αρχική εισαγωγή του // depot / www / live / από το κράτος στην έκδοση #head
----

Η ιστορία μας έγινε γραμμική, σαν να είχαμε ξεκαθαρίσει πριν υποβάλει (πράγμα που ακριβώς συνέβη ακριβώς).
Αυτό σημαίνει ότι μπορείτε να δημιουργήσετε, να εργαστείτε, να πετάξετε και να συγχωνεύσετε κλάδους στην πλευρά του Git χωρίς φόβο ότι η ιστορία σας θα γίνει κάπως ασυμβίβαστη με την Perforce.
Εάν μπορείτε να το επαναβάλετε, μπορείτε να το συμβάλλετε σε ένα διακομιστή Perforce.

[[_git_p4_branches]]
====== Διακλάδωση

Εάν το έργο Perforce σας έχει πολλαπλά υποκαταστήματα, δεν είστε τυχεροί. Το git-p4 μπορεί να το χειριστεί με τρόπο που το κάνει να νιώθει σαν το Git.
Ας υποθέσουμε ότι η αποθήκη σας Perforce έχει ως εξής:

[πηγή]
----
//αμαξοστάσιο
  └── project
      ├─ κύρια
      └── Dev
----

Και ας πούμε ότι έχετε ένα υποκατάστημα `dev`, το οποίο έχει ένα spec view που μοιάζει με αυτό:

[πηγή]
----
// depot / project / main / ... // αποθήκη / έργο / dev / ...
----

Το Git-p4 μπορεί να εντοπίσει αυτόματα την κατάσταση και να κάνει το σωστό:

[πηγή, κονσόλα]
----
$ git p4 κλώνος - εντοπισμός-καταστημάτων // depot / project @ all
Εισαγωγή από // depot / project @ all σε έργο
Αρχικό κενό αποθετήριο Git στο /private/tmp/project/.git/
Εισαγωγή αναθεώρησης 20 (50%)
    Εισαγωγή νέου σχεδίου υποκαταστήματος / dev

    Συνέχιση με αλλαγή 20
Εισαγωγή αναθεώρησης 22 (100%)
Ενημερώθηκαν υποκαταστήματα: main dev
$ cd project; git log --online --όλα --graph --απορρόφηση
* eae77ae (HEAD, p4 / master, p4 / HEAD, master) κύρια
| * 10d55fb (p4 / project / dev) dev
| * a43cfae Πληθυσμός // depot / project / main / ... // depot / project / dev / ....
| /
* 2b83451 Project init
----

Σημειώστε τον προδιαγραφέα `` @all '' στη διαδρομή αποθήκευσης. που λέει στο git-p4 να κλωνοποιήσει όχι μόνο το τελευταίο σύνολο αλλαγών για αυτό το δευτερεύον φύλλο, αλλά όλες τις αλλαγές που έχουν αγγίξει ποτέ αυτές τις διαδρομές.
Αυτό είναι πιο κοντά στην αντίληψη του Git για έναν κλώνο, αλλά αν εργάζεστε σε ένα έργο με μακρά ιστορία, θα μπορούσε να διαρκέσει λίγο.

Η σημαία `--detect-branches 'λέει στο git-p4 να χρησιμοποιήσει τις προδιαγραφές υποκαταστημάτων της Perforce για να χαρτογραφήσει τα υποκαταστήματα στο Git refs.
Εάν αυτές οι αντιστοιχίσεις δεν υπάρχουν στον εξυπηρετητή Perforce (ο οποίος είναι ένας απόλυτα έγκυρος τρόπος χρήσης του Perforce), μπορείτε να πείτε στο git-p4 ποιες είναι οι αντιστοιχίσεις κλάδων και έχετε το ίδιο αποτέλεσμα:

[πηγή, κονσόλα]
----
$ git init project
Αρχικό κενό αποθετήριο Git στο /tmp/project/.git/
$ cd project
$ git config git-p4.branchList κύρια: dev
$ git κλώνος - εντοπισμός-καταστημάτων // depot / project @ all.
----

Η ρύθμιση της μεταβλητής ρύθμισης `git-p4.branchList` στο` main: dev` λέει στο git-p4 ότι οι `` main '' και `` dev '' είναι και οι δύο κλάδοι και το δεύτερο είναι παιδί του πρώτου.

Αν τώρα βγάλουμε το check -b dev p4 / project / dev` και κάνουμε κάποιες δεσμεύσεις, το git-p4 είναι αρκετά έξυπνο για να στοχεύσει το δεξί υποκατάστημα όταν κάνουμε το `git p4 submit`.
Δυστυχώς, το git-p4 δεν μπορεί να αναμείξει ρηχικούς κλώνους και πολλαπλούς κλάδους. εάν έχετε ένα τεράστιο έργο και θέλετε να εργαστείτε σε περισσότερους από έναν κλάδους, θα πρέπει να «git p4 clone» μία φορά για κάθε υποκατάστημα στο οποίο θέλετε να υποβάλετε.

Για τη δημιουργία ή την ενοποίηση υποκαταστημάτων, θα πρέπει να χρησιμοποιήσετε έναν πελάτη Perforce.
Το Git-p4 μπορεί μόνο να συγχρονίζει και να υποβάλλεται σε υπάρχοντα υποκαταστήματα και μπορεί να το κάνει μόνο μία γραμμική αλλαγή ανά πάσα στιγμή.
Εάν συγχωνεύσετε δύο υποκαταστήματα στο Git και προσπαθήσετε να υποβάλετε τη νέα σειρά αλλαγών, όλα αυτά που θα καταγραφούν είναι μια δέσμη αλλαγών αρχείων. τα μεταδεδομένα σχετικά με τους κλάδους που εμπλέκονται στην ολοκλήρωση θα χαθούν.

===== Περίληψη Git και Περίληψη

Το Git-p4 καθιστά δυνατή τη χρήση μιας ροής εργασίας Git με ένα διακομιστή Perforce και είναι αρκετά καλό σε αυτό.
Ωστόσο, είναι σημαντικό να θυμάστε ότι η Perforce είναι υπεύθυνη για την πηγή και χρησιμοποιείτε μόνο Git για να εργαστείτε τοπικά.
Απλά να είστε πολύ προσεκτικοί σχετικά με την κοινή χρήση των δεσμεύσεων της Git. εάν διαθέτετε ένα απομακρυσμένο από άλλους χρήστες, μην προωθείτε δεσμεύσεις που δεν έχουν ήδη υποβληθεί στο διακομιστή Perforce.

Αν θέλετε να αναμίξετε ελεύθερα τη χρήση του Perforce και του Git ως πελάτες για τον έλεγχο πηγής και μπορείτε να πείσετε τον διαχειριστή του διακομιστή να το εγκαταστήσει, το Git Fusion κάνει χρήση του Git ως πελάτης ελέγχου έκδοσης πρώτης κατηγορίας για έναν διακομιστή Perforce.



Ενότητα 9.1.5.

==== Git και TFS

(((Διασύνδεση με άλλα VCS, TFS)))
(((TFS))) ((("TFVC", βλέπε = "TFS")))
Το Git γίνεται δημοφιλές στους προγραμματιστές των Windows και εάν γράφετε κώδικα στα Windows, υπάρχει μεγάλη πιθανότητα να χρησιμοποιείτε το Team Foundation Server (TFS) της Microsoft.
Το TFS είναι μια σουίτα συνεργασίας που περιλαμβάνει εντοπισμό ελαττωμάτων και αντικειμένων εργασίας, υποστήριξη επεξεργασίας για Scrum και άλλους, αναθεώρηση κώδικα και έλεγχο έκδοσης.
Υπάρχει μια μικρή σύγχυση: * TFS * είναι ο διακομιστής, ο οποίος υποστηρίζει τον έλεγχο του πηγαίου κώδικα χρησιμοποιώντας και το Git και το δικό του προσαρμοσμένο VCS, το οποίο έχουν μεταγλωττίσει * TFVC * (Team Foundation Version Control).
Υποστήριξη Git είναι μια κάπως νέα δυνατότητα για το TFS (αποστολή με την έκδοση 2013), έτσι όλα τα εργαλεία που προηγούνται που αναφέρονται στο τμήμα ελέγχου έκδοσης ως `` TFS '', αν και εργάζονται κυρίως με το TFVC.

Αν βρεθείτε σε μια ομάδα που χρησιμοποιεί το TFVC αλλά θα προτιμούσατε να χρησιμοποιήσετε το Git ως πελάτη ελέγχου έκδοσης, υπάρχει ένα έργο για εσάς.

===== Ποιο εργαλείο

(((git-tf))) (((git-tfs)))
Στην πραγματικότητα, υπάρχουν δύο: git-tf και git-tfs.

Το Git-tfs (που βρίσκεται στο https://github.com/git-tfs/git-tfs []) είναι ένα έργο .NET και (από αυτό το γράψιμο) τρέχει μόνο στα Windows.
Για να συνεργαστεί με τους χώρους αποθήκευσης Git, χρησιμοποιεί τις δεσμεύσεις .NET για libgit2, μια εφαρμογή Git που προσανατολίζεται στη βιβλιοθήκη, η οποία είναι εξαιρετικά αποδοτική και επιτρέπει μεγάλη ευελιξία με τα κόπρανα ενός αποθετηρίου Git.
Το Libgit2 δεν είναι μια ολοκληρωμένη εφαρμογή του Git, οπότε για να καλύψουμε τη διαφορά, το git-tfs θα καλέσει τον πελάτη Git της γραμμής εντολών για κάποιες λειτουργίες, έτσι δεν υπάρχουν τεχνητά όρια σε ό, τι μπορεί να κάνει με τα αποθετήρια Git.
Η υποστήριξη των χαρακτηριστικών του TFVC είναι πολύ ώριμη, αφού χρησιμοποιεί τα συγκροτήματα Visual Studio για εργασίες με διακομιστές.
Αυτό σημαίνει ότι θα χρειαστείτε πρόσβαση σε αυτές τις συναρμολογήσεις, πράγμα που σημαίνει ότι πρέπει να εγκαταστήσετε μια πρόσφατη έκδοση του Visual Studio (οποιαδήποτε έκδοση από την έκδοση 2010, συμπεριλαμβανομένου του Express από την έκδοση 2012) ή το Visual Studio SDK.

Το Git-tf (του οποίου το σπίτι βρίσκεται στο https://gittf.codeplex.com []) είναι ένα έργο Java και ως εκ τούτου τρέχει σε οποιονδήποτε υπολογιστή με περιβάλλον Java runtime.
Συνδέεται με τους χώρους αποθήκευσης Git μέσω του JGit (εφαρμογή JVM του Git), πράγμα που σημαίνει ότι δεν έχει ουσιαστικά κανένα περιορισμό όσον αφορά τις λειτουργίες Git.
Ωστόσο, η υποστήριξή του για το TFVC είναι περιορισμένη σε σύγκριση με το git-tfs - για παράδειγμα, δεν υποστηρίζει κλάδους.

Έτσι κάθε εργαλείο έχει πλεονεκτήματα και μειονεκτήματα και υπάρχουν πολλές καταστάσεις που ευνοούν το ένα πάνω στο άλλο.
Θα καλύψουμε τη βασική χρήση και των δύο σε αυτό το βιβλίο.

[ΣΗΜΕΙΩΣΗ]
====
Θα χρειαστείτε πρόσβαση σε ένα αποθετήριο με βάση το TFVC που θα ακολουθήσει μαζί με αυτές τις οδηγίες.
Αυτά δεν είναι τόσο άφθονα στην άγρια ​​φύση όσο τα αποθετήρια Git ή Subversion, οπότε μπορεί να χρειαστεί να δημιουργήσετε ένα δικό σας.
Το Codeplex (https://www.codeplex.com []) ή το Visual Studio Online (http://www.visualstudio.com []) είναι και οι δύο καλές επιλογές για αυτό.
====


===== Ξεκινώντας: `git-tf`

Το πρώτο πράγμα που κάνετε, όπως συμβαίνει με οποιοδήποτε πρόγραμμα Git, είναι ο κλώνος.
Εδώ είναι αυτό που μοιάζει με το `git-tf`:

[πηγή, κονσόλα]
----
$ git tf κλώνος https://tfs.codeplex.com:443/tfs/TFS13 $ / myproject / Κύριο project_git
----

Το πρώτο επιχείρημα είναι η διεύθυνση URL μιας συλλογής TFVC, η δεύτερη είναι της μορφής `$ / project / branch` και η τρίτη είναι η διαδρομή προς τον τοπικό αποθετήριο Git που πρόκειται να δημιουργηθεί (το τελευταίο είναι προαιρετικό).
Το Git-tf μπορεί να λειτουργήσει μόνο με ένα κλάδο κάθε φορά. εάν θέλετε να κάνετε checkins σε διαφορετικό κλάδο TFVC, θα πρέπει να κάνετε έναν νέο κλώνο από αυτόν τον κλάδο.

Αυτό δημιουργεί ένα πλήρως λειτουργικό αποθετήριο Git:

[πηγή, κονσόλα]
----
$ cd project_git
$ git log --all - online - αποκατάσταση
512e75a (HEAD, ετικέτα: TFS_C35190, origin_tfs / tfs, master) Έλεγχος μηνύματος
----

Αυτό ονομάζεται _shallow_ clone, πράγμα που σημαίνει ότι έχουν ληφθεί μόνο τα τελευταία updateset.
Το TFVC δεν έχει σχεδιαστεί για κάθε πελάτη να έχει ένα πλήρες αντίγραφο του ιστορικού, οπότε το git-tf έχει προεπιλεγεί για να πάρει μόνο την πιο πρόσφατη έκδοση, η οποία είναι πολύ πιο γρήγορη.

Αν έχετε κάποιο χρόνο, αξίζει τον κόπο να κλωνοποιήσετε ολόκληρο το ιστορικό του έργου, χρησιμοποιώντας την επιλογή `-deep`:

[πηγή, κονσόλα]
----
$ git tf κλώνος https://tfs.codeplex.com:443/tfs/TFS13 $ / myproject / Main \
  project_git --deep
Όνομα χρήστη: domain \ user
Κωδικός πρόσβασης:
Σύνδεση με το TFS ...
Κλωνοποίηση $ / myproject στο / tmp / project_git: 100%, τελείωσε.
Κλωνοποιήθηκαν 4 αλλαγές. Κλωνοποιήθηκε τελευταία αλλαγή 35190 ως d44b17a
$ cd project_git
$ git log --all - online - αποκατάσταση
d44b17a (HEAD, ετικέτα: TFS_C35190, origin_tfs / tfs, master) Αντίο
126aa7b (ετικέτα: TFS_C35189)
8f77431 (ετικέτα: TFS_C35178) ΠΡΩΤΟ
0745a25 (tag: TFS_C35177) Δημιούργησε το φάκελο ομάδας εργασίας $ / tfvctest μέσω του \
        Οδηγός δημιουργίας έργου ομάδας
----

Παρατηρήστε τις ετικέτες με ονόματα όπως `TFS_C35189`; αυτό είναι ένα χαρακτηριστικό που σας βοηθάει να ξέρετε ποιες δεσμεύσεις του Git σχετίζονται με τις αλλαγές των TFVC.
Αυτός είναι ένας καλός τρόπος για να την αντιπροσωπεύσετε, αφού μπορείτε να δείτε με μια απλή εντολή καταγραφής ποια από τις δεσμεύσεις σας σχετίζεται με ένα στιγμιότυπο που υπάρχει επίσης στο TFVC.
Δεν είναι απαραίτητες (και στην πραγματικότητα μπορείτε να τις απενεργοποιήσετε με το "git config git-tf.tag false"). - git-tf διατηρεί τις πραγματικές αντιστοιχίσεις commit-changeset στο αρχείο .git / git-tf.


===== Ξεκινώντας: `git-tfs`

Η κλωνοποίηση Git-tfs συμπεριφέρεται λίγο διαφορετικά.
Παρατηρώ:

[πηγή, powershell]
----
PS> git tfs κλώνος - με-υποκαταστήματα \
    https://username.visualstudio.com/DefaultCollection \
    $ / project / trunk project_git
Αρχικό κενό αποθετήριο Git στο C: /Users/ben/project_git/.git/
C15 = b75da1aba1ffb359d00e85c52acb261e4586b0c9
C16 = c403405f4989d73a2c3c119e79021cb2104ce44a
Tfs υποκαταστήματα βρέθηκαν:
- $ / tfvc-test / χαρακτηριστικόA
Το όνομα του τοπικού υποκαταστήματος θα είναι: χαρακτηριστικόA
C17 = d202b53f67bde32171d5078968c644e562f1c439
C18 = 44cd729d8df868a8be20438fdeeefb961958b674
----

Παρατηρήστε τη σημαία `--with-branches '.
Το Git-tfs είναι ικανό να χαρτογραφήσει κλάδους TFVC σε κλάδους Git και αυτή η σημαία του λέει να δημιουργήσει ένα τοπικό υποκατάστημα Git για κάθε υποκατάστημα TFVC.
Αυτό συστήνεται ιδιαίτερα αν έχετε διακλαδιστεί ή συγχωνευτεί σε TFS, αλλά δεν θα λειτουργήσει με διακομιστές παλαιότερους από το TFS 2010 - πριν από αυτή την έκδοση, τα `` branches '' ήταν απλά φάκελοι, οπότε το git-tfs δεν μπορεί να πει από τους κανονικούς φακέλους.

Ας ρίξουμε μια ματιά στο αποθετήριο Git που προκύπτει:

[πηγή, powershell]
----
PS> git log --γραμμήγραμμή --graph --decorate --όλα
* 44cd729 (tfs / χαρακτηριστικόA, χαρακτηριστικόA) Αντίο
* d202b53 Διακλαδισμένο από $ / tfvc-test / Trunk
* c403405 (HEAD, tfs / default, master) Γεια σας
* b75da1a Νέο έργο
PS> git log -1
commit c403405f4989d73a2c3c119e79021cb2104ce44a
Συντάκτης: Ben Straub <ben@straub.cc>
Ημερομηνία: Παρ 1 Αυγούστου 03:41:59 2014 +0000

    Χαίρετε

    git-tfs-id: [https://username.visualstudio.com/DefaultCollection]$/myproject/Trunk;C16
----

Υπάρχουν δύο τοπικοί κλάδοι, «master» και «featureA», που αντιπροσωπεύουν το αρχικό σημείο εκκίνησης του κλώνου («Trunk» στο TFVC) και ένα υποκατάστημα παιδιού (`featureA` στο TFVC).
Μπορείτε επίσης να δείτε ότι το `tfs`` `remote '' έχει και μερικούς λόγους refs:` default` και `featureA`, που αντιπροσωπεύουν κλάδους TFVC.
Το Git-tfs χαρτογραφεί το υποκατάστημα που έχετε κλωνοποιήσει από το `tfs / default`, και άλλοι παίρνουν τα δικά τους ονόματα.

Ένα άλλο πράγμα που πρέπει να παρατηρήσετε είναι οι γραμμές `git-tfs-id:` στα μηνύματα commit.
Αντί των ετικετών, το git-tfs χρησιμοποιεί αυτούς τους δείκτες για να συνδέσει τα σύνολα αλλαγών TFVC με τις δεσμεύσεις Git.
Αυτό έχει τις συνέπειες ότι το Git σας δεσμεύεται ότι θα έχει διαφορετικό hash SHA-1 πριν και αφού έχει ωθηθεί στο TFVC.

===== Git-tf [s] Ροή εργασιών

[ΣΗΜΕΙΩΣΗ]
====
Ανεξάρτητα από το εργαλείο που χρησιμοποιείτε, θα πρέπει να ορίσετε μερικές τιμές διαμόρφωσης Git για να αποφύγετε την εμφάνιση προβλημάτων.

[πηγή, κονσόλα]
----
$ git set config - τοπικό core.ignorecase = true
$ git set config - τοπικό core.autocrlf = false
----
====

Το προφανές επόμενο πράγμα που θα θελήσετε να κάνετε είναι να εργαστείτε στο έργο.
Το TFVC και το TFS έχουν διάφορα χαρακτηριστικά που μπορεί να προσθέτουν πολυπλοκότητα στη ροή εργασίας σας:

. Οι κλάδοι χαρακτηριστικών που δεν αντιπροσωπεύονται στο TFVC προσθέτουν μια μικρή πολυπλοκότητα.
  Αυτό έχει να κάνει με τους * πολύ * διαφορετικούς τρόπους με τους οποίους οι TFVC και Git αντιπροσωπεύουν υποκαταστήματα.
. Λάβετε υπόψη ότι το TFVC επιτρέπει στους χρήστες να "ελέγχουν" τα αρχεία από το διακομιστή, κλείνοντας τα έτσι ώστε κανένας άλλος να μην τα επεξεργάζεται.
  Αυτό προφανώς δεν θα σας εμποδίσει να τα επεξεργαστείτε στην τοπική αποθήκη σας, αλλά θα μπορούσε να πάρει τον δρόμο όταν έρχεται χρόνος για να ωθήσετε τις αλλαγές σας στον εξυπηρετητή TFVC.
. Το TFS έχει την έννοια των `` κλειστών '' checkins, όπου ένας κύκλος δοκιμής κατασκευής TFS πρέπει να ολοκληρωθεί με επιτυχία πριν επιτραπεί ο έλεγχος.
  Αυτό χρησιμοποιεί τη λειτουργία `` shelve '' στο TFVC, το οποίο δεν καλύπτουμε λεπτομερώς εδώ.
    Μπορείτε να το ψεύσετε αυτό με χειροκίνητο τρόπο με το git-tf και το git-tfs παρέχει την εντολή `checkinto` που είναι γνωστή στην πύλη.

Προς το συμφέρον της συντομίας, αυτό που θα καλύψουμε εδώ είναι το ευτυχισμένο μονοπάτι, το οποίο παρακάμπτει ή αποφεύγει τα περισσότερα από αυτά τα ζητήματα.

===== Ροή εργασίας: `git-tf`


Ας υποθέσουμε ότι έχετε κάνει κάποια εργασία, κάνατε μερικές δεσμεύσεις του Git στο master και είστε έτοιμοι να μοιραστείτε την πρόοδό σας στον εξυπηρετητή TFVC.
Εδώ είναι το αποθετήριο Git:

[πηγή, κονσόλα]
----
$ git log --online --graph --decorate - όλα
* 4178a82 (HEAD, master) κώδικα ενημέρωσης
* 9df2ae3 update readme
* d44b17a (ετικέτα: TFS_C35190, origin_tfs / tfs) Αντίο
* 126aa7b (ετικέτα: TFS_C35189)
* 8f77431 (tag: TFS_C35178) ΠΡΩΤΑ
* 0745a25 (tag: TFS_C35177) Δημιούργησε το φάκελο ομάδας εργασίας $ / tfvctest μέσω του \
          Οδηγός δημιουργίας έργου ομάδας
----

Θέλουμε να πάρουμε το στιγμιότυπο που βρίσκεται στο `4178a82` και να το προωθήσουμε στο διακομιστή TFVC.
Πρώτα τα πράγματα πρώτα: Ας δούμε αν οποιοιδήποτε από τους συμπαίκτες μας έκαναν κάτι από τότε που συνδέσαμε τελευταία:

[πηγή, κονσόλα]
----
$ git tf fetch
Όνομα χρήστη: domain \ user
Κωδικός πρόσβασης:
Σύνδεση με το TFS ...
Λαμβάνοντας $ / myproject στις τελευταίες αλλαγέςset: 100%, τελείωσε.
Λήψη αλλαγώνset 35320 ως commit 8ef06a8. Ενημερώθηκε FETCH_HEAD.
$ git log --online --graph --decorate - όλα
* 8ef06a8 (ετικέτα: TFS_C35320, origin_tfs / tfs) μόνο κάποιο κείμενο
| * 4178a82 (HEAD, master) κώδικα ενημέρωσης
| * 9df2ae3 update readme
Οδηγός δημιουργίας έργου ομάδας
----

Θέλουμε να πάρουμε το στιγμιότυπο που βρίσκεται στο `4178a82` και να το προωθήσουμε στο διακομιστή TFVC.
Πρώτα τα πράγματα πρώτα: Ας δούμε αν οποιοιδήποτε από τους συμπαίκτες μας έκαναν κάτι από τότε που συνδέσαμε τελευταία:

[πηγή, κονσόλα]
----
$ git tf fetch
Όνομα χρήστη: domain \ user
Κωδικός πρόσβασης:
Σύνδεση με το TFS ...
Λαμβάνοντας $ / myproject στις τελευταίες αλλαγέςset: 100%, τελείωσε.
Λήψη αλλαγώνset 35320 ως commit 8ef06a8. Ενημερώθηκε FETCH_HEAD.
$ git log --online --graph --decorate - όλα
* 8ef06a8 (ετικέτα: TFS_C35320, origin_tfs / tfs) μόνο κάποιο κείμενο
| * 4178a82 (HEAD, master) κώδικα ενημέρωσης
| * 9df2ae3 update readme
| /
* d44b17a (ετικέτα: TFS_C35190) Αντίο
* 126aa7b (ετικέτα: TFS_C35189)
* 8f77431 (tag: TFS_C35178) ΠΡΩΤΑ
* 0745a25 (tag: TFS_C35177) Δημιούργησε το φάκελο ομάδας εργασίας $ / tfvctest μέσω του \
          Οδηγός δημιουργίας έργου ομάδας
----

Φαίνεται ότι κάποιος άλλος εργάζεται επίσης, και τώρα έχουμε αποκλίνουσα ιστορία.
Αυτό είναι όπου Git λάμπει, αλλά έχουμε δύο επιλογές για το πώς να προχωρήσουμε:

. Κάνοντας μια commit commit αισθάνεται φυσική ως χρήστης του Git (μετά από όλα, αυτό είναι που κάνει το "git pull") και το git-tf μπορεί να το κάνει αυτό για σας με ένα απλό `git tf pull`.
  Να γνωρίζετε, ωστόσο, ότι το TFVC δεν σκέφτεται αυτόν τον τρόπο και αν πιέσετε συγχώνευση, το ιστορικό σας θα αρχίσει να φαίνεται διαφορετικό και στις δύο πλευρές, γεγονός που μπορεί να προκαλέσει σύγχυση.
  Ωστόσο, εάν σχεδιάζετε να υποβάλετε όλες τις αλλαγές σας ως ένα σύνολο αλλαγών, αυτή είναι ίσως η πιο εύκολη επιλογή.
. Η αναδιάρθρωση καθιστά το ιστορικό διαπραγμάτευσης γραμμικό, πράγμα που σημαίνει ότι έχουμε τη δυνατότητα να μετατρέψουμε κάθε μία από τις δεσμεύσεις μας Git σε μια σειρά αλλαγών TFVC.
  Δεδομένου ότι αυτό αφήνει τις περισσότερες επιλογές ανοικτές, σας συνιστούμε να το κάνετε αυτό τον τρόπο. Το git-tf σας διευκολύνει ακόμα και με το `git tf pull -rebase`.

Η επιλογή είναι δική σου.
Για αυτό το παράδειγμα, θα κάνουμε επανακατανομή:

[πηγή, κονσόλα]
----
$ git rebase FETCH_HEAD
Αρχικά, επανατοποθετήστε το κεφάλι για να επαναλάβετε την εργασία σας πάνω από το ...
Εφαρμογή: ενημέρωση readme
Εφαρμογή: κωδικός ενημέρωσης
$ git log --online --graph --decorate - όλα
* 5a0e25e (HEAD, master) κώδικα ενημέρωσης
* 6eb3eb5 update readme
* 8ef06a8 (ετικέτα: TFS_C35320, origin_tfs / tfs) μόνο κάποιο κείμενο
* d44b17a (ετικέτα: TFS_C35190) Αντίο
* 126aa7b (ετικέτα: TFS_C35189)
* 8f77431 (tag: TFS_C35178) ΠΡΩΤΑ
* 0745a25 (tag: TFS_C35177) Δημιούργησε το φάκελο ομάδας εργασίας $ / tfvctest μέσω του \
          Οδηγός δημιουργίας έργου ομάδας
----

Τώρα είμαστε έτοιμοι να κάνουμε checkin στο διακομιστή TFVC.
Το Git-tf σας δίνει τη δυνατότητα να δημιουργήσετε ένα ενιαίο σύνολο αλλαγών που αντιπροσωπεύει όλες τις αλλαγές από το τελευταίο (`--shallow`, το οποίο είναι το προεπιλεγμένο) και δημιουργώντας ένα νέο σύνολο αλλαγών για κάθε δέσμευση Git (` --deep`).
Για αυτό το παράδειγμα, θα δημιουργήσουμε μόνο ένα set changeset:

[πηγή, κονσόλα]
----
$ git tf checkin -m 'Ενημέρωση του readme και του κώδικα'
Όνομα χρήστη: domain \ user
Κωδικός πρόσβασης:
Σύνδεση με το TFS ...
Έλεγχος στο $ / myproject: 100%, τελείωσε.
Έλεγχος δέσμευσης 5a0e25e ως changeet 35348
$ git log --online --graph --decorate - όλα
* 5a0e25e (κώδικας ενημέρωσης HEAD, ετικέτα: TFS_C35348, orig_tfs / tfs, master)
* 6eb3eb5 update readme
* 8ef06a8 (ετικέτα: TFS_C35320) μόνο κάποιο κείμενο
* d44b17a (ετικέτα: TFS_C35190) Αντίο
* 126aa7b (ετικέτα: TFS_C35189)
* 8f77431 (tag: TFS_C35178) ΠΡΩΤΑ
* 0745a25 (tag: TFS_C35177) Δημιούργησε το φάκελο ομάδας εργασίας $ / tfvctest μέσω του \
          Οδηγός δημιουργίας έργου ομάδας
----

Υπάρχει μια νέα ετικέτα `TFS_C35348`, υποδεικνύοντας ότι το TFVC αποθηκεύει ακριβώς το ίδιο στιγμιότυπο με τη δέσμευση` 5a0e25e`.
Είναι σημαντικό να σημειώσουμε ότι δεν είναι απαραίτητο κάθε Git commit να έχει ένα ακριβές αντίγραφο στο TFVC. η δέσμευση `6eb3eb5`, για παράδειγμα, δεν υπάρχει σε κανένα σημείο του διακομιστή.

Αυτή είναι η κύρια ροή εργασίας.
Υπάρχουν μερικές άλλες σκέψεις που θα θέλατε να έχετε κατά νου:

* Δεν υπάρχει διακλάδωση.
  Το Git-tf μπορεί να δημιουργήσει μόνο αποθετήρια Git από έναν κλάδο TFVC κάθε φορά.
* Συνεργαστείτε χρησιμοποιώντας TFVC ή Git, αλλά όχι και τα δύο.
  Διαφορετικοί κλώνοι git-tf του ίδιου αποθετηρίου TFVC μπορεί να έχουν διαφορετικές δέσμες SHA-1, οι οποίες δεν θα προκαλέσουν τέλος πονοκεφάλων.
* Αν η ροή εργασίας της ομάδας σας περιλαμβάνει συνεργασία με το Git και συγχρονισμό με το TFVC περιοδικά, συνδεθείτε μόνο στο TFVC με ένα από τα αποθετήρια Git.


===== Ροή εργασιών: `git-tfs`

Ας περάσουμε από το ίδιο σενάριο χρησιμοποιώντας το git-tfs.
Ακολουθούν οι νέες δεσμεύσεις που έχουμε κάνει στο υποκατάστημα `master` στο αποθετήριο Git:

[πηγή, powershell]
----
PS> git log - γραμμής γραμμής - γραφική παράσταση - όλα - αποκατάσταση
* κώδικας ενημέρωσης c3bd3ae (HEAD, master)
* d85e5a2 ενημέρωση readme
| * 44cd729 (tfs / χαρακτηριστικόA, χαρακτηριστικόA) Αντίο
| * d202b53 Διακλαδισμένο από $ / tfvc-test / Trunk
| /
* c403405 (tfs / default) Γεια σας
* b75da1a Νέο έργο
----

Τώρα ας δούμε αν κάποιος άλλος έχει κάνει δουλειά ενώ είχαμε χάσει μακριά:

[πηγή, powershell]
----
PS> git tfs fetch
C19 = aea74a0313de0a391940c999e51c5c15c381d91d
PS> git log - όλα - online --graph - decode
* τεκμηρίωση ενημέρωσης aea74a0 (tfs / προεπιλογή)
| * κώδικας ενημέρωσης c3bd3ae (HEAD, master)
| * d85e5a2 ενημέρωση readme
| /
| * 44cd729 (tfs / χαρακτηριστικόA, χαρακτηριστικόA) Αντίο
| * d202b53 Διακλαδισμένο από $ / tfvc-test / Trunk
| /
* c403405 Γεια σας
* b75da1a Νέο έργο
----

Ναι, αποδεικνύεται ότι ο συνεργάτης μας έχει προσθέσει ένα νέο σύνολο αλλαγών TFVC, το οποίο εμφανίζεται με τη νέα δέσμευση `aea74a0` και μετακινήθηκε ο απομακρυσμένος κλάδος` tfs / default '.

Όπως και με το git-tf, έχουμε δύο θεμελιώδεις επιλογές για τον τρόπο επίλυσης αυτής της αποκλίνουσας ιστορίας:

. Rebase να διατηρήσει ένα γραμμικό ιστορικό.
. Συνεργαστείτε για να διατηρήσετε αυτό που πραγματικά συνέβη.

Σε αυτή την περίπτωση, θα κάνουμε ένα `` deep '' checkin, όπου κάθε commit Git θα γίνει ένα setoff των TFVC, οπότε θέλουμε να κάνουμε rebase.

[πηγή, powershell]
----
PS> git rebase tfs / προεπιλογή
Αρχικά, επανατοποθετήστε το κεφάλι για να επαναλάβετε την εργασία σας πάνω από το ...
Εφαρμογή: ενημέρωση readme
Εφαρμογή: κωδικός ενημέρωσης
PS> git log - όλα - online --graph - decode
* 10a75ac (HEAD, master) κώδικα ενημέρωσης
* 5cec4ab update readme
* τεκμηρίωση ενημέρωσης aea74a0 (tfs / προεπιλογή)
| * 44cd729 (tfs / χαρακτηριστικόA, χαρακτηριστικόA) Αντίο
| * d202b53 Διακλαδισμένο από $ / tfvc-test / Trunk
| /
* c403405 Γεια σας
* b75da1a Νέο έργο
----

Τώρα είμαστε έτοιμοι να ολοκληρώσουμε τη συνεισφορά μας ελέγχοντας τον κώδικα μας στον εξυπηρετητή TFVC.
Θα χρησιμοποιήσουμε εδώ την εντολή `rcheckin` για να δημιουργήσουμε ένα σύνολο αλλαγών TFVC για κάθε δέσμευση Git στη διαδρομή από HEAD στον πρώτο απομακρυσμένο κλάδο` tfs` που βρέθηκε (η εντολή `checkin` θα δημιουργούσε μόνο ένα changeet, όπως το squashing Git δεσμεύσεις).

[πηγή, powershell]
----
PS> git tfs rcheckin
Εργασία με τηλεχειριστήριο tfs: προεπιλογή
Ανάκτηση των αλλαγών από το TFS για ελαχιστοποίηση πιθανότητας καθυστερημένης σύγκρουσης ...
Ξεκινώντας τον έλεγχο του 5cec4ab4 'update readme'
 προσθέστε README.md
C20 = 71a5ddce274c19f8fdc322b4f165d93d89121017
Έγινε με 5cec4ab4b213c354341f66c80cd650ab98dcf1ed, επανατοποθέτηση ουράς σε νέο TFS-commit ...
Το Rebase έγινε με επιτυχία.
Έναρξη εκκίνησης του b1bf0f99 'κώδικα ενημέρωσης'
 επεξεργασία .git \ tfs \ default \ workspace \ ConsoleApplication1 / ConsoleApplication1 / Program.cs
C21 = ff04e7c35dfbe6a8f94e782bf5e0031cee8d103b
Ολοκληρώθηκε με b1bf0f9977b2d48bad611ed4a03d3738df05ea5d, αλλάζοντας την ουρά στο νέο TFS-commit ...
Το Rebase έγινε με επιτυχία.
Δεν χρειάζεται πλέον να ελέγξετε.
PS> git log - όλα - online --graph - decode
* κωδικός ενημέρωσης ff04e7c (HEAD, tfs / default, master)
* 71a5ddc update readme
* τεκμηρίωση ενημέρωσης aea74a0
| * 44cd729 (tfs / χαρακτηριστικόA, χαρακτηριστικόA) Αντίο
| * d202b53 Διακλαδισμένο από $ / tfvc-test / Trunk
| /
* c403405 Γεια σας
* b75da1a Νέο έργο
----

Παρατηρήστε πως μετά από κάθε επιτυχή checkin στο διακομιστή TFVC, το git-tfs επαναπροσδιορίζει το υπόλοιπο έργο σε αυτό που μόλις έκανε.
Αυτό συμβαίνει επειδή προσθέτει το πεδίο `git-tfs-id` στο κάτω μέρος των μηνυμάτων δέσμευσης, το οποίο αλλάζει τα SHA-1 hashes.
Αυτό είναι ακριβώς όπως έχει σχεδιαστεί και δεν υπάρχει τίποτα να ανησυχείτε, αλλά θα πρέπει να γνωρίζετε ότι συμβαίνει αυτό, ειδικά αν μοιράζεστε δεσμεύσεις Git με άλλους.

Το TFS έχει πολλά χαρακτηριστικά που ενσωματώνονται με το σύστημα ελέγχου έκδοσης του, όπως στοιχεία εργασίας, ορισθέντες αναθεωρητές, checkins και ούτω καθεξής.
Μπορεί να είναι δυσκίνητη η εργασία με αυτά τα χαρακτηριστικά χρησιμοποιώντας μόνο ένα εργαλείο γραμμής εντολών, αλλά ευτυχώς το git-tfs σας επιτρέπει να ξεκινήσετε ένα γραφικό εργαλείο checkin πολύ εύκολα:

[πηγή, powershell]
----
PS> git tfs checkintool
PS> git tfs ct
----

Μοιάζει λίγο σαν αυτό:

.Το εργαλείο git-tfs checkin.
image :: images / git-tfs-ct.png [Το εργαλείο ελέγχου git-tfs.]

Αυτό θα μοιάζει εξοικειωμένο με τους χρήστες του TFS, καθώς είναι ο ίδιος διάλογος που ξεκινάει μέσα από το Visual Studio.

Το Git-tfs σας επιτρέπει επίσης να ελέγχετε τα υποκαταστήματα TFVC από το αποθετήριο Git.
Για παράδειγμα, ας δημιουργήσουμε ένα:

[πηγή, powershell]
----
PS> git tfs υποκατάστημα $ / tfvc-test / featureBee
Το όνομα του τοπικού καταστήματος θα είναι: featureBee
C26 = 1d54865c397608c004a2cadce7296f5edc22a7e5
PS> git log --γραμμήγραμμή --graph --decorate --όλα
* 1d54865 (tfs / featureBee) Δημιουργία υποκαταστήματος $ / myproject / featureBee
* κωδικός ενημέρωσης ff04e7c (HEAD, tfs / default, master)
* 71a5ddc update readme
* τεκμηρίωση ενημέρωσης aea74a0
| * 44cd729 (tfs / χαρακτηριστικόA, χαρακτηριστικόA) Αντίο
| * d202b53 Διακλαδισμένο από $ / tfvc-test / Trunk
| /
* c403405 Γεια σας
* b75da1a Νέο έργο
----

Η δημιουργία ενός υποκαταστήματος στο TFVC σημαίνει την προσθήκη μιας σειράς αλλαγών όπου αυτό το υποκατάστημα υπάρχει τώρα και αυτό προβάλλεται ως δέσμευση Git.
Σημειώστε επίσης ότι το git-tfs * δημιούργησε * τον απομακρυσμένο κλάδο `tfs / featureBee`, αλλά το` HEAD` εξακολουθεί να δείχνει `master`.
Εάν θέλετε να εργαστείτε στο νεοσύστατο υποκατάστημα, θα θελήσετε να βασίσετε τις νέες δεσμεύσεις σας στη δέσμευση `1d54865`, ίσως δημιουργώντας ένα κλάδο θέματος από αυτή τη δέσμευση.


===== Περίληψη Git και TFS

Τα Git-tf και Git-tfs είναι και τα δύο εξαιρετικά εργαλεία για τη διασύνδεση με ένα διακομιστή TFVC.
Σας επιτρέπουν να χρησιμοποιείτε τη δύναμη του Git τοπικά, αποφεύγετε συνεχώς να ταξιδεύετε στο κεντρικό διακομιστή TFVC και να κάνετε τη ζωή σας ως προγραμματιστή πολύ πιο εύκολη, χωρίς να αναγκάζετε ολόκληρη την ομάδα σας να μεταναστεύσει στο Git.
Εάν εργάζεστε σε Windows (πιθανότατα αν η ομάδα σας χρησιμοποιεί το TFS), πιθανότατα θέλετε να χρησιμοποιήσετε το git-tfs, καθώς το σύνολο χαρακτηριστικών του είναι πιο πλήρες, αλλά αν εργάζεστε σε άλλη πλατφόρμα, θα χρησιμοποιεί git-tf, η οποία είναι πιο περιορισμένη.
Όπως συμβαίνει με τα περισσότερα εργαλεία αυτού του κεφαλαίου, θα πρέπει να επιλέξετε ένα από αυτά τα συστήματα ελέγχου έκδοσης να είναι κανονικά και να χρησιμοποιήσετε το άλλο με δευτερεύον τρόπο - είτε το Git είτε το TFVC θα πρέπει να είναι το κέντρο συνεργασίας, αλλά όχι και τα δύο



Ενότητα 9.2.0.




Ενότητα 9.2.1.

==== Εξαίρεση

(((Ανατροπή)))
(((Εισαγωγή, από Subversion)))
Αν διαβάσετε την προηγούμενη ενότητα σχετικά με τη χρήση του `git svn`, μπορείτε εύκολα να χρησιμοποιήσετε αυτές τις οδηγίες για να` git svn clone` ένα αποθετήριο. στη συνέχεια, σταματήστε να χρησιμοποιείτε το διακομιστή Subversion, πιέστε σε νέο διακομιστή Git και αρχίστε να το χρησιμοποιείτε.
Εάν θέλετε την ιστορία, μπορείτε να το ολοκληρώσετε όσο πιο γρήγορα μπορείτε να τραβήξετε τα δεδομένα από το διακομιστή Subversion (το οποίο μπορεί να διαρκέσει λίγο).

Ωστόσο, η εισαγωγή δεν είναι τέλεια. και επειδή θα διαρκέσει τόσο πολύ, μπορείτε να το κάνετε σωστά.
Το πρώτο πρόβλημα είναι οι πληροφορίες του δημιουργού.
Στο Subversion, κάθε άτομο που διαπράττεται έχει έναν χρήστη στο σύστημα που έχει καταγραφεί στις πληροφορίες commit.
Τα παραδείγματα στην προηγούμενη ενότητα δείχνουν `schacon` σε ορισμένα σημεία, όπως την έξοδο` fault 'και το `git svn log`.
Εάν θέλετε να αντιστοιχίσετε αυτό το αρχείο σε καλύτερα δεδομένα δημιουργού Git, χρειάζεστε μια αντιστοίχιση από τους χρήστες του Subversion στους συγγραφείς του Git.
Δημιουργήστε ένα αρχείο με όνομα `users.txt` που έχει αυτή τη χαρτογράφηση σε μορφή όπως αυτή:

[πηγή]
----
schacon = Scott Chacon <schacon@geemail.com>
selse = Someo Nelse <selse@geemail.com>
----

Για να αποκτήσετε μια λίστα με τα ονόματα συγγραφέων που χρησιμοποιεί το SVN, μπορείτε να το εκτελέσετε:

[πηγή, κονσόλα]
----
$ svn log - xml | grep συγγραφέας | sort -u | \
  perl -pe 's /.***************************** 1 = /
----

Αυτό δημιουργεί την έξοδο του αρχείου καταγραφής σε μορφή XML, διατηρεί μόνο τις γραμμές με πληροφορίες συγγραφέα, απορρίπτει διπλότυπα, απομακρύνει τις ετικέτες XML.
(Προφανώς αυτό λειτουργεί μόνο σε ένα μηχάνημα με `grep`,` sort` και `perl` εγκατεστημένο.)
Στη συνέχεια, ανακατευθύνετε την έξοδο στο αρχείο users.txt, ώστε να μπορείτε να προσθέσετε τα αντίστοιχα δεδομένα χρήστη Git δίπλα σε κάθε καταχώρηση.

Μπορείτε να δώσετε αυτό το αρχείο στο `git svn` για να το χαρτογραφήσετε με μεγαλύτερη ακρίβεια.
Μπορείτε επίσης να πείτε στο `git svn` να μην συμπεριλαμβάνονται τα μεταδεδομένα που κανονικά εισάγει το Subversion, μεταφέροντας` --no-metadata` στην εντολή `clone` ή` init`.
Αυτό κάνει την εντολή `import 'σας να μοιάζει με αυτή:

[πηγή, κονσόλα]
----
$ git svn κλώνος http://my-project.googlecode.com/svn/ \
      --authors-file = users.txt --no-metadata -s my_project
----

Τώρα θα πρέπει να έχετε μια ωρύτερη εισαγωγή Subversion στον κατάλογο `my_project`.
Αντί για δεσμεύσεις που μοιάζουν με αυτό

[πηγή]
----
commit 37efa680e8473b615de980fa935944215428a35a
Συντάκτης: schacon <schacon @ 4c93b258-373f-11de-be05-5f7a86268029>
Ημερομηνία: Κυρ 3 Μαΐου 00:12:22 2009 +0000

    σταθερή εγκατάσταση - πηγαίνετε στον κορμό

    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-
    be05-5f7a86268029
----

μοιάζουν με αυτό:

[πηγή]
----
commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2
Συντάκτης: Scott Chacon <schacon@geemail.com>
Ημερομηνία: Κυρ 3 Μαΐου 00:12:22 2009 +0000

    σταθερή εγκατάσταση - πηγαίνετε στον κορμό
----

Όχι μόνο το πεδίο του Συγγραφέα φαίνεται πολύ καλύτερα, αλλά το `git-svn-id` δεν είναι πλέον εκεί.

Θα πρέπει επίσης να κάνετε λίγο καθαρισμό μετά την εισαγωγή.
Για ένα πράγμα, θα πρέπει να καθαρίσετε τις περίεργες αναφορές που ορίσατε `git svn`.
Αρχικά θα μετακινήσετε τις ετικέτες έτσι ώστε να είναι πραγματικές ετικέτες και όχι περίεργα απομακρυσμένα υποκαταστήματα και, στη συνέχεια, θα μετακινήσετε τα υπόλοιπα κλάδους έτσι ώστε να είναι τοπικά.

Για να μετακινήσετε τις ετικέτες ως κατάλληλες ετικέτες Git, εκτελέστε

[πηγή, κονσόλα]
----
$ cp -Rf .git / refs / remotes / προέλευση / ετικέτες / * .git / refs / tags /
$ rm -Rf .git / refs / remotes / προέλευση / ετικέτες
----

Αυτό παίρνει τις παραπομπές που ήταν απομακρυσμένα κλάδους που ξεκίνησαν με `remotes / origin / tags /` και τα κάνει πραγματικές (ελαφρές) ετικέτες.

Στη συνέχεια, μετακινήστε τις υπόλοιπες αναφορές στο φάκελο "refs / remotes" για τοπικούς κλάδους:

[πηγή, κονσόλα]
----
$ cp -Rf .git / refs / remotes / * .git / refs / κεφαλές /
$ rm -Rf .git / refs / remotes
----

Τώρα όλοι οι παλιοί κλάδοι είναι πραγματικοί κλάδοι Git και όλες οι παλιές ετικέτες είναι πραγματικές ετικέτες Git.
Το τελευταίο πράγμα που πρέπει να κάνετε είναι να προσθέσετε τον νέο σας διακομιστή Git ως απομακρυσμένο και να τον σπρώξετε.
Ακολουθεί ένα παράδειγμα προσθήκης του διακομιστή σας ως τηλεχειριστηρίου:

[πηγή, κονσόλα]
----
$ git απομακρυσμένη προσθήκη προέλευσης git @ my-git-server: myrepository.git
----

Επειδή θέλετε να ανεβαίνουν όλα τα υποκαταστήματα και οι ετικέτες σας, μπορείτε τώρα να εκτελέσετε αυτήν την ενέργεια:

[πηγή, κονσόλα]
----
$ git ώθηση προέλευσης - όλα
----

Όλα τα υποκαταστήματά σας και οι ετικέτες σας θα πρέπει να βρίσκονται στο νέο σας διακομιστή Git σε μια ωραία και καθαρή εισαγωγή.




Ενότητα 9.2.2.

==== Mercurial

(((Mercurial))) (((Εισαγωγή, από την Mercurial)))
Δεδομένου ότι τα μοντέλα Mercurial και Git έχουν αρκετά παρόμοια μοντέλα για εκδόσεις που αντιπροσωπεύουν και καθώς το Git είναι λίγο πιο ευέλικτο, η μετατροπή ενός αποθετηρίου από το Mercurial σε Git είναι αρκετά απλή, χρησιμοποιώντας ένα εργαλείο που ονομάζεται "hg-fast-export" αντίγραφο από:

[πηγή, κονσόλα]
----
$ git κλώνος http://repo.or.cz/r/fast-export.git / tmp / γρήγορη εξαγωγή
----

Το πρώτο βήμα της μετατροπής είναι να αποκτήσετε έναν πλήρη κλώνο του αποθετηρίου Mercurial που θέλετε να μετατρέψετε:

[πηγή, κονσόλα]
----
$ hg κλώνος <απομακρυσμένη διεύθυνση URL repo> / tmp / hg-repo
----

Το επόμενο βήμα είναι να δημιουργήσετε ένα αρχείο χαρτογράφησης συγγραφέων.
Το Mercurial είναι λίγο πιο συγχωριασμένο από το Git για αυτό που θα θέσει στο πεδίο συγγραφέων για αλλαγές, γι 'αυτό είναι μια καλή στιγμή για να καθαρίσετε το σπίτι.
Δημιουργώντας αυτό είναι μια εντολή μιας γραμμής σε ένα κέλυφος `bash`:

[πηγή, κονσόλα]
----
$ cd / tmp / hg-repo
$ hg log | grep χρήστης: | είδος | uniq | sed 's / χρήστης: * //'> ../authors
----

Αυτό θα διαρκέσει μερικά δευτερόλεπτα, ανάλογα με το πόσο χρόνο είναι το ιστορικό του έργου σας και μετά το αρχείο `/ tmp / authors 'θα μοιάζει με αυτό:

[πηγή]
----
βαρίδι
bob @ localhost
bob <bob@company.com>
bob jones <bob <AT> εταιρεία <DOT> com>
Bob Jones <bob@company.com>
Joe Smith <joe@company.com>
----

Σε αυτό το παράδειγμα, το ίδιο άτομο (Bob) δημιούργησε ομάδες αλλαγών κάτω από τέσσερα διαφορετικά ονόματα, ένα από τα οποία φαίνεται πραγματικά σωστό και ένα από τα οποία θα ήταν εντελώς άκυρο για μια δέσμευση Git.
Hg-γρήγορη εξαγωγή μας επιτρέπει να διορθώσουμε αυτό προσθέτοντας `= {νέο όνομα και διεύθυνση ηλεκτρονικού ταχυδρομείου}` στο τέλος κάθε γραμμής που θέλουμε να αλλάξουμε και αφαιρώντας τις γραμμές για όλα τα ονόματα χρήστη που θέλουμε να αφήσουμε μόνα τους.
Αν όλα τα ονόματα χρηστών φαίνονται ωραία, δεν θα χρειαστεί καθόλου αυτό το αρχείο.
Σε αυτό το παράδειγμα, θέλουμε το αρχείο μας να μοιάζει με αυτό:

[πηγή]
----
bob = Bob Jones <bob@company.com>
bob @ localhost = Bob Jones <bob@company.com>
bob jones <bob <AT> εταιρεία <DOT> com> = Bob Jones <bob@company.com>
bob <bob@company.com> = Bob Jones <bob@company.com>
----

Το επόμενο βήμα είναι να δημιουργήσουμε το νέο μας αποθετήριο Git και να εκτελέσουμε το script εξαγωγής:

[πηγή, κονσόλα]
----
$ git init / tmp / μετατροπή
$ cd / tmp / μετατροπή
$ /tmp/fast-export/hg-fast-export.sh -r / tmp / hg-repo -Α / tmp / συγγραφείς
----

Η σημαία `-r` λέει hg-fast-export όπου θα βρούμε το Mercurial repository που θέλουμε να μετατρέψουμε και η σημαία` -A` λέει από πού θα βρει το αρχείο χαρτογράφησης συγγραφέων.
Το σενάριο αναλύει τα Mercurial changesets και τα μετατρέπει σε μια δέσμη ενεργειών για τη λειτουργία "γρήγορης εισαγωγής" του Git (η οποία θα συζητηθεί λεπτομερώς λίγο αργότερα).
Αυτό παίρνει λίγο (αν και είναι πολύ πιο γρήγορα από ό, τι θα ήταν πάνω από το δίκτυο), και η παραγωγή είναι αρκετά λεπτομερή:

[πηγή, κονσόλα]
----
$ /tmp/fast-export/hg-fast-export.sh -r / tmp / hg-repo -Α / tmp / συγγραφείς
Φορτώθηκαν 4 συγγραφείς
master: Εξαγωγή πλήρους αναθεώρησης 1/22208 με 13/0/0 προστιθέμενα / αλλαγμένα / αφαιρούμενα αρχεία
master: Εξαγωγή απλής αναθεώρησης δέλτα 2/22208 με αρχεία 1/1/0 που έχουν προστεθεί / αλλάξει / αφαιρεθεί
master: Εξαγωγή απλής αναθεώρησης δέλτα 3/22208 με αρχεία 0/1/0 που έχουν προστεθεί / αλλάξει / αφαιρεθεί
[...]
master: Εξαγωγή απλής αναθεώρησης δέλτα 22206/22208 με αρχεία 0/4/0 προστιθέμενα / αλλαγμένα / αφαιρεθέντα
master: Εξαγωγή απλής αναθεώρησης δέλτα 22207/22208 με αρχεία 0/2/0 προστιθέμενα / αλλαγμένα / αφαιρούμενα
master: Εξαγωγή λεπτομερούς αναθεώρησης δέλτα 22208/22208 με 3/213/0 πρόσθετα / αλλαγμένα / αφαιρούμενα αρχεία
Εξαγωγή ετικέτας [0.4c] σε [hg r9] [git: 10]
Εξαγωγή ετικέτας [0.4d] σε [hg r16] [git: 17]
[...]
Εξαγωγή ετικέτας [3.1-rc] στο [hg r21926] [git: 21927]
Εξαγωγή ετικέτας [3.1] στο [hg r21973] [git: 21974]
Εκδόθηκαν εντολές 22315
git-fast-imports statistics:
-------------------------------------------------- -------------------
Alloc'd αντικείμενα: 120000
Σύνολο αντικειμένων: 115032 (208171 αντίγραφα)
      blobs: 40504 (205320 αντίγραφα 26117 δελτία από 39602 απόπειρες)
      δέντρα: 52320 (2851 αντίγραφα 47467 δελτία από 47599 απόπειρες)
      δεσμεύει: 22208 (0 αντίγραφα 0 δελτία των 0 απόπειρων)
      ετικέτες: 0 (0 αντίγραφα 0 δελτία από 0 απόπειρες)
Συνολικοί κλάδοι: 109 (2 φορτία)
      σημάδια: 1048576 (22208 μοναδικά)
      άτομα: 1952
Συνολική μνήμη: 7860 KiB
       πισίνες: 2235 KiB
     αντικείμενα: 5625 KiB
-------------------------------------------------- -------------------
pack_report: getpagesize () = 4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit = 8589934592
pack_report: pack_used_ctr = 90430
pack_report: pack_mmap_calls = 46771
pack_report: pack_open_windows = 1/1
pack_report: pack_mapped = 340852700/340852700
-------------------------------------------------- -------------------

$ git shortlog -sn
   369 Bob Jones
   365 Joe Smith
----

Αυτό είναι σχεδόν όλα όσα υπάρχουν σε αυτό.
Όλες οι ετικέτες Mercurial έχουν μετατραπεί σε ετικέτες Git και τα υποκαταστήματα Mercurial και οι σελιδοδείκτες έχουν μετατραπεί σε υποκαταστήματα Git.
Τώρα είστε έτοιμοι να σπρώξετε το αποθετήριο μέχρι το νέο σπίτι του στο διακομιστή:

[πηγή, κονσόλα]
----
$ git απομακρυσμένη προσθήκη προέλευσης git @ my-git-server: myrepository.git
$ git ώθηση προέλευσης - όλα
----




Ενότητα 9.2.3.

Bazaar?????



Ενότητα 9.2.4.

[[_perforce_import]]
==== Perforce

(((Perforce)))) (((Εισαγωγή, από την Perforce)))
Το επόμενο σύστημα στο οποίο θα εξετάσετε την εισαγωγή είναι το Perforce.
Όπως συζητήσαμε παραπάνω, υπάρχουν δύο τρόποι να αφήσουμε τους Git και Perforce να μιλήσουν μεταξύ τους: git-p4 και Perforce Git Fusion.

===== Η Perforce Git Fusion

Το Git Fusion καθιστά αυτή τη διαδικασία αρκετά ανώδυνη.
Απλώς ρυθμίστε τις ρυθμίσεις του έργου, τις αντιστοιχίσεις χρηστών και τα υποκαταστήματά σας χρησιμοποιώντας ένα αρχείο ρυθμίσεων (όπως αναλύθηκε στο << _ p4_git_fusion >>) και κλωνοποιήστε το αποθετήριο.
Το Git Fusion σας αφήνει με αυτό που μοιάζει με ένα εγγενές αποθετήριο Git, το οποίο είναι έτοιμο να σπρώξει σε έναν εγγενή Git host εάν το επιθυμείτε.
Θα μπορούσατε ακόμη και να χρησιμοποιήσετε το Perforce ως το host σας Git, αν θέλετε.

[[_git_p4]]
===== Git-p4

Το Git-p4 μπορεί επίσης να λειτουργήσει ως εργαλείο εισαγωγής.
Για παράδειγμα, θα εισαγάγουμε το έργο Jam από το Perforce Public Depot.
Για να ρυθμίσετε τον πελάτη σας, πρέπει να εξαγάγετε τη μεταβλητή περιβάλλοντος P4PORT για να δείξετε την αποθήκη Perforce:

[πηγή, κονσόλα]
----
$ εξαγωγή P4PORT = public.perforce.com: 1666
----

[ΣΗΜΕΙΩΣΗ]
====
Προκειμένου να ακολουθήσετε, θα χρειαστείτε μια αποθήκη Perforce για να συνδεθείτε.
Θα χρησιμοποιήσουμε τη δημόσια αποθήκη στο public.perforce.com για τα παραδείγματα μας, αλλά μπορείτε να χρησιμοποιήσετε οποιαδήποτε αποθήκη στην οποία έχετε πρόσβαση.
====

(((εντολές git, p4)))
Εκτελέστε την εντολή 'git p4 clone' για να εισάγετε το έργο Jam από τον διακομιστή Perforce, παρέχοντας τη διαδρομή και την διαδρομή έργου και τη διαδρομή στην οποία θέλετε να εισαγάγετε το έργο:

[πηγή, κονσόλα]
----
$ git-p4 κλώνος // guest / perforce_software / jam @ all p4import
Εισαγωγή από // guest / perforce_software / jam @ all σε p4import
Αρχικό κενό αποθετήριο Git στο /private/tmp/p4import/.git/
Προορισμός εισαγωγής: refs / remotes / p4 / master
Εισαγωγή αναθεώρησης 9957 (100%)
----

Αυτό το συγκεκριμένο έργο έχει μόνο ένα κλάδο, αλλά αν έχετε υποκαταστήματα που έχουν διαμορφωθεί με προβολές κλάδων (ή απλώς ένα σύνολο καταλόγων), μπορείτε να χρησιμοποιήσετε τη σημαία `--detect-branches 'στο` git p4 clone' για να εισάγετε όλες τις τα υποκαταστήματα του έργου.
Βλέπε << _ git_p4_branches >> για λίγο περισσότερες λεπτομέρειες σχετικά με αυτό.

Σε αυτό το σημείο είστε σχεδόν έτοιμοι.
Εάν μεταβείτε στον κατάλογο `p4import` και εκτελέσετε το` git log`, μπορείτε να δείτε την εργασία που εισήγατε:

[πηγή, κονσόλα]
----
$ git log -2
commit e5da1c909e5db3036475419f6379f2c73710c4e6
Συγγραφέας: giles <giles @ giles @ perforce.com>
Ημερομηνία: Τετ Φεβ 8 03:13:27 2012 -0800

    Διόρθωση στη γραμμή 355. αλλαγή </ UL> σε </ OL>.

    [git-p4: αποθήκες-διαδρομές = "// public / jam / src /": change = 8068]

commit aa21359a0a135dda85c50a7f7cf249e4f7b8fd98
Συντάκτης: kwirth <kwirth@perforce.com>
Ημερομηνία: Τρι 07 Ιουλίου 01:35:51 2009 -0800

    Αντιμετώπιση σφάλματος ορθογραφίας στη σελίδα doc Jam (συσσωρευτική -> αθροιστική).

    [git-p4: αποθήκες-διαδρομές = "// public / jam / src /": change = 7304]
----

Μπορείτε να δείτε ότι το `git-p4` έχει αφήσει ένα αναγνωριστικό σε κάθε μήνυμα αποστολής.
Είναι καλό να διατηρήσετε αυτό το αναγνωριστικό εκεί, σε περίπτωση που χρειάζεται να αναφερθείτε αργότερα στον αριθμό αλλαγής Perforce.
Ωστόσο, αν θέλετε να καταργήσετε το αναγνωριστικό, τώρα είναι η κατάλληλη στιγμή - προτού αρχίσετε να εργάζεστε στο νέο αποθετήριο.
(((εντολές git, φίλτρο-υποκατάστημα)))
Μπορείτε να χρησιμοποιήσετε το `git filter-branch` για να αφαιρέσετε τις σειρές αναγνωριστικών en masse:

[πηγή, κονσόλα]
----
$ git filter-branch -msg-φίλτρο 'sed -e' / ^ \ [git-p4: / d "'
Επανασυνδέστε e5da1c909e5db3036475419f6379f2c73710c4e6 (125/125)
Οι αναφορές 'refs / heads / master' επαναδιατυπώθηκαν
----

Αν εκτελέσετε το `git log`, μπορείτε να δείτε ότι όλα τα SHA-1 checksums για τις δεσμεύσεις έχουν αλλάξει αλλά οι συμβολοσειρές` git-p4` δεν βρίσκονται πλέον στα μηνύματα commit:

[πηγή, κονσόλα]
----
$ git log -2
commit b17341801ed838d97f7800a54a6f9b95750839b7
Συγγραφέας: giles <giles @ giles @ perforce.com>
Ημερομηνία: Τετ Φεβ 8 03:13:27 2012 -0800

    Διόρθωση στη γραμμή 355. αλλαγή </ UL> σε </ OL>.

commit 3e68c2e26cd89cb983eb52c024ecdfba1d6b3fff
Συντάκτης: kwirth <kwirth@perforce.com>
Ημερομηνία: Τρι 07 Ιουλίου 01:35:51 2009 -0800

    Αντιμετώπιση σφάλματος ορθογραφίας στη σελίδα doc Jam (συσσωρευτική -> αθροιστική).
----

Η εισαγωγή σας είναι έτοιμη να ωθήσει τον νέο σας διακομιστή Git.





Ενότητα 9.2.5.

[[_git_tfs]]
==== TFS

(((TFS)))) (((Εισαγωγή, από την TFS)))
Αν η ομάδα σας μετατρέπει τον έλεγχο πηγής από το TFVC στο Git, θα θελήσετε να έχετε την πιο πιστή μετατροπή που μπορείτε να αποκτήσετε.
Αυτό σημαίνει ότι, ενώ καλύψαμε και τα git-tfs και git-tf για το τμήμα interop, θα καλύπτουμε μόνο το git-tfs για αυτό το μέρος, επειδή το git-tfs υποστηρίζει τα κλαδιά και αυτό είναι απαγορευτικά δύσκολο χρησιμοποιώντας το git-tf.

[ΣΗΜΕΙΩΣΗ]
====
Πρόκειται για μια μονόδρομη μετατροπή.
Το αποθετήριο Git που προκύπτει δεν θα μπορεί να συνδεθεί με το αρχικό έργο TFVC.
====

Το πρώτο πράγμα που πρέπει να κάνετε είναι να αντιστοιχίσετε ονόματα χρηστών.
Το TFVC είναι αρκετά φιλελεύθερο με αυτό που πηγαίνει στο πεδίο συγγραφέων για αλλαγές, αλλά ο Git θέλει ένα αναγνωρίσιμο από το χρήστη όνομα και διεύθυνση ηλεκτρονικού ταχυδρομείου.
Μπορείτε να λάβετε αυτές τις πληροφορίες από τον client-line `tf`, όπως π.χ.:

[πηγή, powershell]
----
PS> tf ιστορικό $ / myproject -recursive> AUTHORS_TMP
----

Αυτό προσελκύει όλα τα changesets στο ιστορικό του έργου και το βάζουμε στο αρχείο AUTHORS_TMP που θα επεξεργαστούμε για την εξαγωγή των δεδομένων της στήλης "Χρήστης" (2η).
Ανοίξτε το αρχείο και βρείτε ποιοι χαρακτήρες ξεκινούν και τελειώνουν τη στήλη και αντικαταστήστε στην ακόλουθη γραμμή εντολών τις παραμέτρους «11-20» της εντολής `cut` με τις εντολές που βρέθηκαν:

[πηγή, powershell]
----
PS> γάτα AUTHORS_TMP | αποκοπή -β 11-20 | ουρά -η + 3 | uniq | sort> AUTHORS
----

Η εντολή `cut 'διατηρεί μόνο τους χαρακτήρες μεταξύ 11 και 20 από κάθε γραμμή.
Η εντολή `tail 'παραλείπει τις δύο πρώτες γραμμές, οι οποίες είναι επικεφαλίδες πεδίων και υπογραμμίζει ASCII-art.
Το αποτέλεσμα όλων αυτών οδηγείται σε `uniq` για να εξαλείψει τα διπλότυπα και αποθηκεύεται σε ένα αρχείο που ονομάζεται` AUTHORS`.
Το επόμενο βήμα είναι χειροκίνητο. για να μπορέσει η git-tfs να χρησιμοποιήσει αποτελεσματικά αυτό το αρχείο, κάθε γραμμή πρέπει να είναι σε αυτή τη μορφή:

[πηγή, κείμενο]
----
DOMAIN \ username = Όνομα χρήστη <email@address.com>
----

Το τμήμα στα αριστερά είναι το πεδίο `` Χρήστη '' από το TFVC και το τμήμα στη δεξιά πλευρά του σημείου ισότητας είναι το όνομα χρήστη που θα χρησιμοποιηθεί για τις δεσμεύσεις Git.

Μόλις έχετε αυτό το αρχείο, το επόμενο πράγμα που πρέπει να κάνετε είναι να κάνετε έναν πλήρη κλώνο του έργου TFVC που σας ενδιαφέρει:

[πηγή, powershell]
----
PS> git tfs κλώνος --with-branches --authors = AUTHORS https://username.visualstudio.com/DefaultCollection $ / project / Trunk project_git
----

Στη συνέχεια, θα θέλετε να καθαρίσετε τις ενότητες `git-tfs-id` από το κάτω μέρος των μηνυμάτων δέσμευσης.
Η ακόλουθη εντολή θα το κάνει:

[πηγή, powershell]
----
PS> git filter-branch -f -msg-φίλτρο 'sed' s / ^ git-tfs-id:. * $ // g "'-
----

Αυτό χρησιμοποιεί την εντολή `sed` από το περιβάλλον Git-bash για να αντικαταστήσει οποιαδήποτε γραμμή ξεκινώντας με το` `git-tfs-id: '' με κενό, το οποίο το Git θα αγνοήσει.

Μόλις γίνει αυτό, είστε έτοιμοι να προσθέσετε ένα νέο τηλεχειριστήριο, να ωθήσετε όλα τα υποκαταστήματά σας και να αρχίσετε να εργάζεστε από το Git.



Ενότητα 9.2.6.

[[_custom_importer]]
==== Ένας εισαγωγέας προσαρμοσμένος

(((εντολές git, γρήγορη εισαγωγή)))
(((Εισαγωγή, από άλλους)))
Εάν το σύστημά σας δεν είναι ένα από τα παραπάνω, θα πρέπει να αναζητήσετε έναν εισαγωγέα σε απευθείας σύνδεση - οι εισαγωγείς ποιότητας είναι διαθέσιμοι για πολλά άλλα συστήματα, όπως CVS, Clear Case, Visual Source Safe, ακόμη και έναν κατάλογο αρχείων.
Εάν κανένα από αυτά τα εργαλεία δεν λειτουργεί για εσάς, έχετε πιο σκοτεινό εργαλείο ή διαφορετικά χρειάζεστε μια πιο προσαρμοσμένη διαδικασία εισαγωγής, θα πρέπει να χρησιμοποιήσετε το `git fast-import`.
Αυτή η εντολή διαβάζει απλές οδηγίες από το stdin για να γράψει συγκεκριμένα δεδομένα Git.
Είναι πολύ πιο εύκολο να δημιουργήσετε αντικείμενα Git με αυτόν τον τρόπο από το να εκτελέσετε τις πρώτες εντολές Git ή να προσπαθήσετε να γράψετε τα ακατέργαστα αντικείμενα (για περισσότερες πληροφορίες, δείτε το << _ git_internals >>).
Με αυτό τον τρόπο, μπορείτε να γράψετε ένα σενάριο εισαγωγής που διαβάζει τις απαραίτητες πληροφορίες από το σύστημα από το οποίο εισάγετε και εκτυπώνει απλές οδηγίες στο stdout.
Στη συνέχεια, μπορείτε να εκτελέσετε αυτό το πρόγραμμα και να διοχετεύσετε την έξοδό του μέσω του `git fast-import`.

Για να αποδείξετε γρήγορα, θα γράψετε έναν απλό εισαγωγέα.
Ας υποθέσουμε ότι εργάζεστε σε `τρέχοντα ', δημιουργείτε αντίγραφα ασφαλείας του έργου σας περιστασιακά αντιγράφοντας τον κατάλογο backup σε back_YYYY_MM_DD` και θέλετε να το εισαγάγετε στο Git.
Η δομή του καταλόγου σας μοιάζει με αυτό:

[πηγή, κονσόλα]
----
$ ls / opt / import_from
back_2014_01_02
back_2014_01_04
back_2014_01_14
back_2014_02_03
ρεύμα
----

Για να εισαγάγετε έναν κατάλογο Git, θα πρέπει να ελέγξετε τον τρόπο αποθήκευσης των δεδομένων του Git.
Όπως μπορεί να θυμάστε, το Git είναι βασικά μια συνδεδεμένη λίστα αντικειμένων δέσμευσης που υποδηλώνουν ένα στιγμιότυπο περιεχομένου.
Το μόνο που έχετε να κάνετε είναι να λέτε "γρήγορη εισαγωγή" τι είναι τα στιγμιότυπα περιεχομένου, ποια στοιχεία εμπλέκονται σε αυτά και ποια σειρά πηγαίνουν μέσα.
Η στρατηγική σας θα είναι να περάσετε τα στιγμιότυπα κάθε ένα και να δημιουργήσετε δεσμεύσεις με τα περιεχόμενα κάθε καταλόγου, συνδέοντας κάθε δέσμευση με την προηγούμενη.

Όπως κάναμε στο << _an_example_git_enforced_policy >>, θα το γράψουμε στο Ruby, επειδή είναι αυτό που γενικά δουλεύουμε και τείνει να είναι εύκολο να το διαβάσεις.
Μπορείτε να γράψετε αυτό το παράδειγμα αρκετά εύκολα σε οτιδήποτε είστε εξοικειωμένοι με - χρειάζεται μόνο να τυπώσετε τις κατάλληλες πληροφορίες στο `stdout`.
Και αν τρέχετε σε Windows, αυτό σημαίνει ότι θα πρέπει να προσέξετε να μην εισαγάγετε επιστροφές μεταφοράς στο τέλος των γραμμών σας - η γρήγορη εισαγωγή του git είναι πολύ συγκεκριμένη για την απλώς επιθυμητή τροφοδοσία γραμμής (LF), όχι τη γραμμή επιστροφής μεταφοράς (CRLF) που χρησιμοποιούν τα Windows.

Αρχικά, θα μεταβείτε στον κατάλογο στόχων και θα εντοπίσετε κάθε υποκατάλογο, το καθένα από τα οποία είναι ένα στιγμιότυπο που θέλετε να εισαγάγετε ως δέσμευση.
Θα αλλάξετε σε κάθε υποκατάλογο και θα εκτυπώσετε τις εντολές που είναι απαραίτητες για την εξαγωγή του.
Ο βασικός σας κύριος βρόχος μοιάζει με αυτό:

[πηγή, ρουμπίνι]
----
last_mark = μηδέν

# βρόχο μέσω των καταλόγων
Dir.chdir (ARGV [0]) κάνει
  Dir.glob ("*"), το καθένα κάνει | dir |
    επόμενο εάν το File.file (dir)

    # μετακίνηση στον κατάλογο στόχων
    Dir.chdir (dir) κάνουμε
      last_mark = print_export (dir, last_mark)
    τέλος
  τέλος
τέλος
----

Εκτελείτε το `print_export` μέσα σε κάθε κατάλογο, ο οποίος λαμβάνει το δηλωτικό και το σημάδι του προηγούμενου στιγμιότυπου και επιστρέφει το δηλωτικό και το σημάδι αυτού. Με αυτόν τον τρόπο, μπορείτε να τα συνδέσετε σωστά.
`` Mark '' είναι ο όρος `fast-import 'για ένα αναγνωριστικό που δίνετε σε μια δέσμευση. καθώς δημιουργείτε δεσμεύσεις, δίνετε στον καθένα ένα σήμα που μπορείτε να χρησιμοποιήσετε για να το συνδέσετε με άλλες δεσμεύσεις.
Έτσι, το πρώτο πράγμα που πρέπει να κάνετε στη μέθοδο `print_export` σας είναι να δημιουργήσετε ένα σημάδι από το όνομα του καταλόγου:

[πηγή, ρουμπίνι]
----
mark = convert_dir_to_mark (dir)
----

Θα το κάνετε αυτό δημιουργώντας μια σειρά από καταλόγους και χρησιμοποιώντας την τιμή του δείκτη ως σήμα, επειδή ένα σήμα πρέπει να είναι ένας ακέραιος αριθμός.
Η μέθοδος σας μοιάζει με αυτό:

[πηγή, ρουμπίνι]
----
$ marks = []
def convert_dir_to_mark (dir)
  εάν! $ marks.include; (dir)
    $ σημειώνει << dir
  τέλος
  ($ marks.index (dir) + 1) .to_s
τέλος
----

Τώρα που έχετε μια ολόκληρη αναπαράσταση της δέσμευσής σας, χρειάζεστε μια ημερομηνία για τα μεταδεδομένα δέσμευσης.
Επειδή η ημερομηνία εκφράζεται στο όνομα του καταλόγου, θα το αναλύσετε.
Η επόμενη γραμμή στο αρχείο `print_export` είναι

[πηγή, ρουμπίνι]
----
ημερομηνία = convert_dir_to_date (dir)
----

όπου `convert_dir_to_date` ορίζεται ως

[πηγή, ρουμπίνι]
----
def convert_dir_to_date (dir)
  αν dir == 'τρέχον'
    επιστροφή Time.now (). to_i
  αλλού
    dir = dir.gsub ('back_', '')
    (έτος, μήνας, ημέρα) = dir.split ('_')
    επιστροφή Time.local (έτος, μήνα, ημέρα) .to_i
  τέλος
τέλος
----

Αυτό επιστρέφει μια ακέραια τιμή για την ημερομηνία κάθε καταλόγου.
Το τελευταίο κομμάτι των μετα-πληροφοριών που χρειάζεστε για κάθε δέσμευση είναι τα δεδομένα του εντολέα, τα οποία έχετε κωδικοποιήσει σε μια παγκόσμια μεταβλητή:

[πηγή, ρουμπίνι]
----
$ author = 'John Doe <john@example.com>'
----

Τώρα είστε έτοιμοι να ξεκινήσετε να εκτυπώνετε τα στοιχεία της δέσμευσης για τον εισαγωγέα σας.
Η αρχική πληροφορία δηλώνει ότι ορίζετε ένα αντικείμενο δέσμευσης και ποια κλάση είναι, ακολουθούμενη από το σήμα που δημιουργήσατε, το μήνυμα της εντολής committer και τη δέσμευση και, στη συνέχεια, την προηγούμενη δέσμευση, αν υπάρχει.
Ο κώδικας μοιάζει με αυτό:

[πηγή, ρουμπίνι]
----
# εκτυπώστε τις πληροφορίες εισαγωγής
τοποθετεί 'commit refs / heads / master'
βάζει το "σημάδι:" + σημάδι
θέτει "committer # {$ author} # {date} -0700"
export_data ('εισήχθη από' + dir)
βάζει 'από:' + last_mark if last_mark
----

Μπορείτε hardcode τη ζώνη ώρας (-0700), διότι αυτό είναι εύκολο.
Αν εισάγετε από άλλο σύστημα, πρέπει να καθορίσετε τη ζώνη ώρας ως αντιστάθμιση.
Το μήνυμα δέσμευσης πρέπει να εκφράζεται σε ειδική μορφή:

[πηγή]
----
δεδομένα (μέγεθος) \ n (περιεχόμενο)
----

Η μορφή αποτελείται από τα δεδομένα λέξεων, το μέγεθος των προς ανάγνωση δεδομένων, μια νέα γραμμή και τελικά τα δεδομένα.
Επειδή πρέπει να χρησιμοποιήσετε την ίδια μορφή για να καθορίσετε αργότερα τα περιεχόμενα του αρχείου, δημιουργείτε μια μέθοδο βοήθειας, `export_data`:

[πηγή, ρουμπίνι]
----
def export_data (συμβολοσειρά)
  εκτυπώστε "δεδομένα # {string.size} \ n # {string}"
τέλος
----

Το μόνο που έχει απομείνει είναι να καθορίσετε τα περιεχόμενα του αρχείου για κάθε στιγμιότυπο.
Αυτό είναι εύκολο, επειδή έχετε ο καθένας σε έναν κατάλογο - μπορείτε να εκτυπώσετε την εντολή `deleteall` ακολουθούμενη από τα περιεχόμενα κάθε αρχείου στον κατάλογο.
Το Git θα καταγράψει στη συνέχεια κάθε στιγμιότυπο κατάλληλα:

[πηγή, ρουμπίνι]
----
βάζει 'deleteall'
Dir.glob ("** / *") κάθε αρχείο |
  next if File.file (αρχείο)
  inline_data (αρχείο)
τέλος
----

Σημείωση: Επειδή πολλά συστήματα σκέφτονται τις αναθεωρήσεις τους ως μεταβολές από μία δέσμευση σε άλλη, η γρήγορη εισαγωγή μπορεί επίσης να λάβει εντολές με κάθε δέσμευση να καθορίσει ποια αρχεία έχουν προστεθεί, αφαιρεθεί ή τροποποιηθεί και ποια είναι τα νέα περιεχόμενα.
Θα μπορούσατε να υπολογίσετε τις διαφορές μεταξύ των στιγμιότυπων και να δώσετε μόνο αυτά τα δεδομένα, αλλά αυτό είναι πιο περίπλοκο - μπορείτε επίσης να δώσετε στο Git όλα τα δεδομένα και να το αφήσετε να το καταλάβει.
Αν αυτό ταιριάζει καλύτερα με τα δεδομένα σας, ελέγξτε τη σελίδα "γρήγορης εισαγωγής" για λεπτομέρειες σχετικά με τον τρόπο παροχής των δεδομένων σας με αυτόν τον τρόπο.

Η μορφή εμφάνισης των νέων περιεχομένων του αρχείου ή προσδιορισμός ενός τροποποιημένου αρχείου με τα νέα περιεχόμενα έχει ως εξής:

[πηγή]
----
M 644 διαδρομή / προς / αρχείο
δεδομένα (μέγεθος)
(περιεχόμενα αρχείου)
----

Εδώ, ο 644 είναι ο τρόπος λειτουργίας (αν έχετε εκτελέσιμα αρχεία, θα πρέπει να ανιχνεύσετε και να προσδιορίσετε 755 αντ 'αυτού), και inline λέει ότι θα απαριθμήσετε το περιεχόμενο αμέσως μετά από αυτή τη γραμμή.
Η μέθοδος `inline_data` σας μοιάζει με αυτό:

[πηγή, ρουμπίνι]
----
def inline_data (αρχείο, κωδικός = 'M', mode = '644')
  content = File.read (αρχείο)
  θέτει "# {code} # {mode} inline # {file}"
  export_data (περιεχόμενο)
τέλος
----

Επαναχρησιμοποιείτε τη μέθοδο `export_data` που ορίσατε νωρίτερα, επειδή είναι ο ίδιος με τον τρόπο που καθορίσατε τα δεδομένα του μηνύματος αποστολής.

Το τελευταίο πράγμα που πρέπει να κάνετε είναι να επιστρέψετε το σημερινό σήμα ώστε να μπορεί να μεταβιβαστεί στην επόμενη επανάληψη:

[πηγή, ρουμπίνι]
----
επιστροφής
----

[ΣΗΜΕΙΩΣΗ]
====
Εάν τρέχετε σε Windows, θα πρέπει να βεβαιωθείτε ότι προσθέτετε ένα επιπλέον βήμα.
Όπως αναφέρθηκε προηγουμένως, τα Windows χρησιμοποιούν CRLF για νέους χαρακτήρες γραμμών ενώ το git fast-import αναμένει μόνο LF.
Για να αντιμετωπίσετε αυτό το πρόβλημα και να κάνετε ευτυχείς τη γρήγορη εισαγωγή του git, πρέπει να πείτε στο ρουμπίνι να χρησιμοποιήσει το LF αντί του CRLF:

[πηγή, ρουμπίνι]
----
$ stdout.binmode
----
====

Αυτό είναι.
Εδώ είναι το σενάριο στο σύνολό του:


[πηγή, ρουμπίνι]
----
#! / usr / bin / env ruby

$ stdout.binmode
$ author = "John Doe <john@example.com>"

$ marks = []
def convert_dir_to_mark (dir)
    εάν! $ marks.include; (dir)
        $ σημειώνει << dir
    τέλος
    ($ marks.index (dir) +1) .to_s
τέλος


def convert_dir_to_date (dir)
    αν dir == 'τρέχον'
        επιστροφή Time.now (). to_i
    αλλού
        dir = dir.gsub ('back_', '')
        (έτος, μήνας, ημέρα) = dir.split ('_')
        επιστροφή Time.local (έτος, μήνα, ημέρα) .to_i
    τέλος
τέλος

def export_data (συμβολοσειρά)
    εκτυπώστε "δεδομένα # {string.size} \ n # {string}"
τέλος

def inline_data (αρχείο, κωδικός = 'M', mode = '644')
    content = File.read (αρχείο)
    θέτει "# {code} # {mode} inline # {file}"
    export_data (περιεχόμενο)
τέλος

defex_export (dir, last_mark)
    ημερομηνία = convert_dir_to_date (dir)
    mark = convert_dir_to_mark (dir)

    τοποθετεί 'commit refs / heads / master'
    θέτει ": # {mark}"
    θέτει "committer # {$ author} # {date} -0700"
    export_data ("εισήχθη από # {dir}")
    θέτει "από: # {last_mark}" εάν last_mark

    βάζει 'deleteall'
    Dir.glob ("** / *") κάθε αρχείο |
        next if File.file (αρχείο)
        inline_data (αρχείο)
    τέλος
    σημάδι
τέλος


# Βγείτε από τους καταλόγους
last_mark = μηδέν
Dir.chdir (ARGV [0]) κάνει
    Dir.glob ("*"), το καθένα κάνει | dir |
        επόμενο εάν το File.file (dir)

        # μετακίνηση στον κατάλογο στόχων
        Dir.chdir (dir) κάνουμε
            last_mark = print_export (dir, last_mark)
        τέλος
    τέλος
τέλος
----

Αν εκτελέσετε αυτήν τη δέσμη ενεργειών, θα λάβετε περιεχόμενο που μοιάζει με αυτό:

[πηγή, κονσόλα]
----
$ ruby ​​import.rb / opt / import_from
δέσμευση refs / heads / master
σημάδι: 1
επικοινωνήστε με τον John Doe <john@example.com> 1388649600 -0700
δεδομένα 29
εισήχθη από back_2014_01_02deleteall
M 644 inline README.md
δεδομένα 28
# Χαίρετε

Αυτό είναι το readme μου.
δέσμευση refs / heads / master
σημάδι: 2
επικοινωνήστε με τον John Doe <john@example.com> 1388822400 -0700
δεδομένα 29
εισήχθη από back_2014_01_04from: 1
διαγραφή όλων
M 644 inline main.rb
δεδομένα 34
#! / bin / env ruby

βάζει "Hey there"
M 644 inline README.md
(...)
----

Για να εκτελέσετε τον εισαγωγέα, διοχετεύστε αυτή την έξοδο μέσω του `git fast import 'ενώ βρίσκεστε στον κατάλογο Git που θέλετε να εισαγάγετε.
Μπορείτε να δημιουργήσετε ένα νέο κατάλογο και, στη συνέχεια, να εκτελέσετε το `git init` σε αυτό για ένα σημείο εκκίνησης και στη συνέχεια να εκτελέσετε το σενάριο σας:

[πηγή, κονσόλα]
----
$ git init
Αρχικό κενό αποθετήριο Git στο /opt/import_to/.git/
$ ruby ​​import.rb / opt / import_from | γρήγορη εισαγωγή
git-fast-imports statistics:
-------------------------------------------------- -------------------
Alloc'd αντικείμενα: 5000
Σύνολο αντικειμένων: 13 (6 αντίγραφα)
      blobs: 5 (4 αντίγραφα 3 delta από 5 απόπειρες)
      δέντρα: 4 (1 αντίγραφο 0 δέλτα από 4 απόπειρες)
      δεσμεύει: 4 (1 αντίγραφα 0 δελτία από 0 απόπειρες)
      ετικέτες: 0 (0 αντίγραφα 0 δελτία από 0 απόπειρες)
Σύνολο κλάδων: 1 (1 φορτία)
      σημάδια: 1024 (5 μοναδικά)
      άτομα: 2
Συνολική μνήμη: 2344 KiB
       πισίνες: 2110 KiB
     αντικείμενα: 234 KiB
-------------------------------------------------- -------------------
pack_report: getpagesize () = 4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit = 8589934592
pack_report: pack_used_ctr = 10
pack_report: pack_mmap_calls = 5
pack_report: pack_open_windows = 2/2
pack_report: pack_mapped = 1457/1457
-------------------------------------------------- -------------------
----

Όπως μπορείτε να δείτε, όταν ολοκληρωθεί με επιτυχία, σας δίνει μια δέσμη στατιστικών για το τι έχει επιτύχει.
Σε αυτήν την περίπτωση, εισάγετε 13 αντικείμενα συνολικά για 4 δεσμεύσεις σε 1 υποκατάστημα.
Τώρα, μπορείτε να εκτελέσετε το `git log` για να δείτε το νέο σας ιστορικό:

[πηγή, κονσόλα]
----
$ git log -2
commit 3caa046d4aac682a55867132ccdfbe0d3fdee498
Συντάκτης: John Doe <john@example.com>
Ημερομηνία: Τρι Jul 29 19:39:04 2014 -0700

    εισάγονται από το ρεύμα

commit 4afc2b945d0d3c8cd00556fbe2e8224569dc9def
Συντάκτης: John Doe <john@example.com>
Ημερομηνία: Παρ 3 Φεβρουαρίου 01:00:00 2014 -0700

    εισήχθη από back_2014_02_03
----

Εκεί πηγαίνετε - ένα ωραίο, καθαρό αποθετήριο Git.
Είναι σημαντικό να σημειώσετε ότι τίποτα δεν έχει εξακριβωθεί - δεν έχετε πρώτα αρχεία στον κατάλογο εργασίας σας.
Για να τα πάρετε, πρέπει να επαναφέρετε το υποκατάστημά σας στο σημείο όπου είναι τώρα ο «κύριος»:

[πηγή, κονσόλα]
----
$ ls
$ git επαναφέρετε --hard master
Το HEAD είναι τώρα στο 3caa046 που εισάγεται από το τρέχον
$ ls
README.md main.rb
----

Μπορείτε να κάνετε πολλά περισσότερα με το εργαλείο γρήγορης εισαγωγής - να χειριστείτε διαφορετικούς τρόπους, δυαδικά δεδομένα, πολλαπλούς κλάδους και συγχωνεύσεις, ετικέτες, δείκτες προόδου και πολλά άλλα.
Ορισμένα παραδείγματα πιο σύνθετων σεναρίων είναι διαθέσιμα στον κατάλογο `contrib / fast-import 'του πηγαίου κώδικα Git.

