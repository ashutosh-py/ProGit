[[_objects]]
=== Αντικείμενα του Git

Το Git είναι ένα σύστημα αρχείων διευθυνσιοδοτούμενο από το περιεχόμενο.
Εξαιρετική.
Τι σημαίνει αυτό?
Σημαίνει ότι στον πυρήνα του Git είναι ένα απλό κατάστημα δεδομένων βασικών δεδομένων.
Μπορούμε να εισάγουμε οποιοδήποτε είδος περιεχομένου σε αυτό και θα μας δώσει πίσω ένα κλειδί που μπορούμε να χρησιμοποιήσουμε για να ανακτήσουμε ξανά το περιεχόμενο ξανά ανά πάσα στιγμή.
Για να αποδείξουμε, μπορούμε να χρησιμοποιήσουμε την εντολή υδραυλικών εγκαταστάσεων `hash-object`, η οποία λαμβάνει ορισμένα δεδομένα, αποθηκεύει τον στον κατάλογο `.git` και μας δίνει πίσω το κλειδί στο οποίο αποθηκεύονται τα δεδομένα.
Αρχικά, ξεκινάτε ένα νέο αποθετήριο Git και βεβαιωθούμε ότι δεν υπάρχει τίποτα στον κατάλογο `objects`:

Git is a content-addressable filesystem.
Great.
What does that mean?
It means that at the core of Git is a simple key-value data store.
You can insert any kind of content into it, and it will give you back a key that you can use to retrieve the content again at any time.
To demonstrate, you can use the plumbing command `hash-object`, which takes some data, stores it in your `.git` directory, and gives you back the key the data is stored as.
First, you initialize a new Git repository and verify that there is nothing in the `objects` directory:

[source,console]
----
$ git init test
Initialized empty Git repository in /tmp/test/.git/
$ cd test
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
$ find .git/objects -type f
----

Το Git έχει αρχικοποιήσει τον κατάλογο `objects` και έχει δημιουργήσει κλάδους `pack` και `info` σε αυτό, αλλά δεν υπάρχουν κανονικά αρχεία.
Τώρα, ας αποθηκεύσουμε κάποιο κείμενο στη βάση δεδομένων του Git:

Git has initialized the `objects` directory and created `pack` and `info` subdirectories in it, but there are no regular files.
Now, store some text in your Git database:

[source,console]
----
$ echo 'test content' | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4
----

Το `-w` λέει `hash-object` για να αποθηκεύσει το αντικείμενο· διαφορετικά, η εντολή απλά μας λέει ποιο θα είναι το κλειδί.
`--stdin` λέει στην εντολή να διαβάσει το περιεχόμενο από το stdin· αν δεν το καθορίσουμε αυτό, το `hash-object 'αναμένει μια διαδρομή αρχείου στο τέλος.
Η έξοδος από την εντολή είναι ένα hash ελέγχου 40 χαρακτήρων.
Αυτό είναι το SHA-1 hash --ένα άθροισμα ελέγχου του περιεχομένου που αποθηκεύουμε συν μια κεφαλίδα, την οποία θα μάθουμε λίγο.
Τώρα μπορούμε να δούμε πώς το Git έχει αποθηκεύσει τα δεδομένα μας:

The `-w` tells `hash-object` to store the object; otherwise, the command simply tells you what the key would be.
`--stdin` tells the command to read the content from stdin; if you don't specify this, `hash-object` expects a file path at the end.
The output from the command is a 40-character checksum hash.
This is the SHA-1 hash – a checksum of the content you're storing plus a header, which you'll learn about in a bit.
Now you can see how Git has stored your data:

[source,console]
----
$ find .git/objects -type f
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
----

You can see a file in the `objects` directory.
This is how Git stores the content initially – as a single file per piece of content, named with the SHA-1 checksum of the content and its header.
The subdirectory is named with the first 2 characters of the SHA-1, and the filename is the remaining 38 characters.

Μπορούμε να δούμε ένα αρχείο στον κατάλογο `objects`.
Αυτός είναι ο τρόπος με τον οποίο το Git αποθηκεύει αρχικά το περιεχόμενο --ως ένα αρχείο ανά τεμάχιο περιεχομένου, το οποίο ονομάζεται με το SHA-1 checksum του περιεχομένου και την κεφαλίδα του.
Ο υποκατάλογος ονομάζεται με τους πρώτους 2 χαρακτήρες του SHA-1 και το όνομα αρχείου είναι οι υπόλοιποι 38 χαρακτήρες.

Μπορούμε να τραβήξουμε το περιεχόμενο πίσω από το Git με την εντολή `cat-file`.
Αυτή η εντολή είναι ένα είδος ελβετικού μαχαίρι στρατού για την επιθεώρηση αντικειμένων Git.
Περνώντας το `-p` σε αυτό καθοδηγεί την εντολή` cat-file` για να καταλάβει τον τύπο του περιεχομένου και να την εμφανίσει ωραία για εσάς:

You can pull the content back out of Git with the `cat-file` command.
This command is sort of a Swiss army knife for inspecting Git objects.
Passing `-p` to it instructs the `cat-file` command to figure out the type of content and display it nicely for you:

[source,console]
----
$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content
----

Τώρα, μπορούμε να προσθέσουμε περιεχόμενο στο Git και να το τραβήξουμε πίσω ξανά.
Μπορούμε επίσης να το κάνουμε αυτό με περιεχόμενο σε αρχεία.
Για παράδειγμα, μπορούμε να κάνουμε κάποιο απλό έλεγχο έκδοσης σε ένα αρχείο.
Αρχικά, δημιουργήστε ένα νέο αρχείο και αποθηκεύστε τα περιεχόμενά του στη βάση δεδομένων μας:

Now, you can add content to Git and pull it back out again.
You can also do this with content in files.
For example, you can do some simple version control on a file.
First, create a new file and save its contents in your database:

[source,console]
----
$ echo 'version 1' > test.txt
$ git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30
----

Στη συνέχεια, γράψτε ένα νέο περιεχόμενο στο αρχείο και αποθηκεύστε το ξανά:

Then, write some new content to the file, and save it again:

[source,console]
----
$ echo 'version 2' > test.txt
$ git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
----

Η βάση δεδομένων μας περιέχει τις δύο νέες εκδόσεις του αρχείου καθώς και το πρώτο περιεχόμενο που αποθηκεύσαμε εκεί:

Your database contains the two new versions of the file as well as the first content you stored there:

[source,console]
----
$ find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
----

Τώρα μπορούμε να επαναφέρουμε το αρχείο πίσω στην πρώτη έκδοση

Now you can revert the file back to the first version

[source,console]
----
$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt
$ cat test.txt
version 1
----

ή τη δεύτερη έκδοση:

[source,console]
----
$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt
$ cat test.txt
version 2
----

Αλλά θυμηθούμε το κλειδί SHA-1 για κάθε έκδοση του αρχείου μας δεν είναι πρακτικό. Επιπλέον, δεν αποθηκεύουμε το όνομα αρχείου στο σύστημά μας - απλά το περιεχόμενο.
Αυτός ο τύπος αντικειμένου ονομάζεται "blob".
Μπορούμε να έχουμε το Git να μας πει τον τύπο αντικειμένου οποιουδήποτε αντικειμένου στο Git, δεδομένου του κλειδιού SHA-1, με το `cat-file -t`:

But remembering the SHA-1 key for each version of your file isn't practical; plus, you aren't storing the filename in your system – just the content.
This object type is called a blob.
You can have Git tell you the object type of any object in Git, given its SHA-1 key, with `cat-file -t`:

[source,console]
----
$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob
----

[[_tree_objects]]
==== Αντικείμενα δέντρων

Ο επόμενος τύπος που θα εξετάσουμε είναι το δέντρο, το οποίο λύνει το πρόβλημα της αποθήκευσης του ονόματος αρχείου και επίσης μας επιτρέπει να αποθηκεύσουμε μαζί μια ομάδα αρχείων.
Το Git αποθηκεύει περιεχόμενο με τρόπο παρόμοιο με ένα σύστημα αρχείων UNIX, αλλά λίγο απλοποιημένο.
Το σύνολο του περιεχομένου αποθηκεύεται ως αντικείμενα δέντρου και blob, με δέντρα που αντιστοιχούν σε καταχωρήσεις καταλόγου UNIX και blobs που αντιστοιχούν περισσότερο ή λιγότερο στις inodes ή τα περιεχόμενα του αρχείου.
Ένα μοναδικό αντικείμενο δέντρου περιέχει μία ή περισσότερες καταχωρίσεις δέντρων, κάθε μία από τις οποίες περιέχει δείκτη SHA-1 σε ένα μπλοκ ή ένα δευτερεύον φύλλο με τη σχετική λειτουργία, τύπο και όνομα αρχείου.
Για παράδειγμα, το πιο πρόσφατο δέντρο ενός έργου μπορεί να μοιάζει με αυτό:

The next type we'll look at is the tree, which solves the problem of storing the filename and also allows you to store a group of files together.
Git stores content in a manner similar to a UNIX filesystem, but a bit simplified.
All the content is stored as tree and blob objects, with trees corresponding to UNIX directory entries and blobs corresponding more or less to inodes or file contents.
A single tree object contains one or more tree entries, each of which contains a SHA-1 pointer to a blob or subtree with its associated mode, type, and filename.
For example, the most recent tree in a project may look something like this:

[source,console]
----
$ git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib
----

Η σύνταξη `master ^ {tree}` καθορίζει το αντικείμενο δέντρου που υποδεικνύεται από την τελευταία διεκπεραίωση στον κλάδο `master`.
Παρατηρήστε ότι ο υποκατάλογος `lib` δεν είναι ένα μπλοκ αλλά ένας δείκτης σε ένα άλλο δέντρο:

The `master^{tree}` syntax specifies the tree object that is pointed to by the last commit on your `master` branch.
Notice that the `lib` subdirectory isn't a blob but a pointer to another tree:

[source,console]
----
$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb
----

Εννοιολογικά, τα δεδομένα που αποθηκεύει το Git είναι κάτι σαν αυτό:

Conceptually, the data that Git is storing is something like this:

.Απλή εκδοχή του μοντέλου δεδομένων του Git.
image::images/data-model-1.png[Απλή εκδοχή του μοντέλου δεδομένων Git.]

Μπορούμε εύκολα να δημιουργήσουμε το δικό μας δέντρο.
Το Git δημιουργεί κανονικά ένα δέντρο λαμβάνοντας την κατάσταση της περιοχής αναμονής ή του ευρετηρίου και γράφοντας μια σειρά από δέντρα από αυτό.
Επομένως, για να δημιουργήσουμε ένα αντικείμενο δέντρου, πρέπει πρώτα να ορίσουμε ένα ευρετήριο τοποθετώντας κάποια αρχεία.
Για να δημιουργήσουμε ένα ευρετήριο με μια μοναδική καταχώρηση - την πρώτη έκδοση του αρχείου test.txt - μπορούμε να χρησιμοποιήσουμε την εντολή `updates-index` της υδραυλικής εγκατάστασης.
Χρησιμοποιούμε αυτήν την εντολή για την τεχνητή προσθήκη της παλαιότερης έκδοσης του αρχείου test.txt σε μια νέα περιοχή σταδιοποίησης.
Πρέπει να περάσουμε την επιλογή `--add` επειδή το αρχείο δεν υπάρχει ακόμη στην περιοχή σταδιοδρομίας μας (δεν έχουμε ακόμη δημιουργήσει μια περιοχή σταδιοποίησης) και` --cacheinfo` επειδή το αρχείο που προσθέτουμε δεν βρίσκεται στον κατάλογό μας αλλά βρίσκεται στη βάση δεδομένων μας.
Στη συνέχεια, καθορίζουμε τη λειτουργία SHA-1 και το όνομα αρχείου:

You can fairly easily create your own tree.
Git normally creates a tree by taking the state of your staging area or index and writing a series of tree objects from it.
So, to create a tree object, you first have to set up an index by staging some files.
To create an index with a single entry – the first version of your test.txt file – you can use the plumbing command `update-index`.
You use this command to artificially add the earlier version of the test.txt file to a new staging area.
You must pass it the `--add` option because the file doesn't yet exist in your staging area (you don't even have a staging area set up yet) and `--cacheinfo` because the file you're adding isn't in your directory but is in your database.
Then, you specify the mode, SHA-1, and filename:

[source,console]
----
$ git update-index --add --cacheinfo 100644 \
  83baae61804e65cc73a7201a7252750c76066a30 test.txt
----

In this case, you're specifying a mode of `100644`, which means it's a normal file.
Other options are `100755`, which means it's an executable file; and `120000`, which specifies a symbolic link.
The mode is taken from normal UNIX modes but is much less flexible – these three modes are the only ones that are valid for files (blobs) in Git (although other modes are used for directories and submodules).

Σε αυτήν την περίπτωση, καθορίζουμε έναν τρόπο λειτουργίας `100644`, που σημαίνει ότι είναι ένα κανονικό αρχείο.
Άλλες επιλογές είναι `100755`, πράγμα που σημαίνει ότι είναι ένα εκτελέσιμο αρχείο. και "120000", που καθορίζει έναν συμβολικό σύνδεσμο.
Η λειτουργία λαμβάνεται από κανονικές λειτουργίες UNIX, αλλά είναι πολύ λιγότερο ευέλικτη - αυτές οι τρεις λειτουργίες είναι οι μόνες που ισχύουν για τα αρχεία (blobs) στο Git (αν και άλλες μορφές χρησιμοποιούνται για καταλόγους και υπομονάδες).

Τώρα, μπορούμε να χρησιμοποιήσουμε την εντολή `γράψτε-δέντρο 'για να γράψουμε την περιοχή στάσης έξω σε ένα αντικείμενο δέντρου.
Δεν χρειάζεται επιλογή `-w` - η κλήση` write tree` δημιουργεί αυτόματα ένα αντικείμενο δέντρου από την κατάσταση του ευρετηρίου αν το δέντρο δεν υπάρχει ακόμα:

Now, you can use the `write-tree` command to write the staging area out to a tree object.
No `-w` option is needed – calling `write-tree` automatically creates a tree object from the state of the index if that tree doesn't yet exist:

[source,console]
----
$ git write-tree
d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt
----

Μπορούμε επίσης να επαληθεύσουμε ότι πρόκειται για ένα αντικείμενο δέντρου:

[source,console]
----
$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
tree
----

Θα δημιουργήσουμε τώρα ένα νέο δέντρο με τη δεύτερη έκδοση του test.txt και ένα νέο αρχείο:

[source,console]
----
$ echo 'new file' > new.txt
$ git update-index test.txt
$ git update-index --add new.txt
----

Η περιοχή σταδιοδρομίας μας διαθέτει τώρα τη νέα έκδοση του test.txt καθώς και το νέο αρχείο new.txt.
Γράψτε αυτό το δέντρο (καταγραφή της κατάστασης της περιοχής σταδιοποίησης ή ευρετηρίου σε ένα αντικείμενο δέντρου) και δούμε πώς φαίνεται:

Your staging area now has the new version of test.txt as well as the new file new.txt.
Write out that tree (recording the state of the staging area or index to a tree object) and see what it looks like:

[source,console]
----
$ git write-tree
0155eb4229851634a0f03eb265b69f5a2d56f341
$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
----

Παρατηρήστε ότι αυτό το δέντρο έχει καταχωρήσεις αρχείων και ότι το αρχείο test.txt SHA-1 είναι το `` version 2 '' SHA-1 από παλαιότερα (`1f7a7a`).
Ακριβώς για διασκέδαση, θα προσθέσουμε σε αυτό το πρώτο δέντρο ως υποκατάλογο.
Μπορούμε να διαβάσουμε τα δέντρα στην περιοχή σταδιοδρομίας μας καλώντας το "read-tree".
Σε αυτή την περίπτωση, μπορούμε να διαβάσουμε ένα υπάρχον δέντρο στην περιοχή σταδιοποίησης ως δευτερεύουσα διάταξη χρησιμοποιώντας την επιλογή `--prefix 'σε' read-tree ':

Notice that this tree has both file entries and also that the test.txt SHA-1 is the ``version 2'' SHA-1 from earlier (`1f7a7a`).
Just for fun, you'll add the first tree as a subdirectory into this one.
You can read trees into your staging area by calling `read-tree`.
In this case, you can read an existing tree into your staging area as a subtree by using the `--prefix` option to `read-tree`:

[source,console]
----
$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git write-tree
3c4e9cd789d88d8d89c1073707c3585e41b0e614
$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
----

Αν δημιουργήσαμε έναν κατάλογο εργασίας από το νέο δέντρο που μόλις γράψατε, θα έχουμε τα δύο αρχεία στο ανώτερο επίπεδο του καταλόγου εργασίας και έναν υποκατάλογο που ονομάζεται `bak` που περιέχει την πρώτη έκδοση του αρχείου test.txt.
Μπορούμε να σκεφτούμε τα δεδομένα που περιέχει το Git για αυτές τις δομές ως εξής:

..
image :: images / data-model-2.png [Η δομή περιεχομένου των τωρινών δεδομένων μας Git.]

If you created a working directory from the new tree you just wrote, you would get the two files in the top level of the working directory and a subdirectory named `bak` that contained the first version of the test.txt file.
You can think of the data that Git contains for these structures as being like this:

.Η δομή περιεχομένων των τωρινών δεδομένων μας στο Git.
image::images/data-model-2.png[Η δομή περιεχομένων των τωρινών δεδομένων μας στο Git.]

[[_git_commit_objects]]
==== Αντικείμενα υποβολής

You have three trees that specify the different snapshots of your project that you want to track, but the earlier problem remains: you must remember all three SHA-1 values in order to recall the snapshots.
You also don't have any information about who saved the snapshots, when they were saved, or why they were saved.
This is the basic information that the commit object stores for you.

Έχουμε τρία δέντρα που καθορίζουν τα διαφορετικά στιγμιότυπα του έργου μας που θέλουμε να παρακολουθήσουμε, αλλά το προηγούμενο πρόβλημα παραμένει: πρέπει να θυμάστε και τις τρεις τιμές SHA-1 για να ανακαλέσουμε τα στιγμιότυπα.
Επίσης, δεν έχουμε πληροφορίες σχετικά με το ποιος αποθηκεύτηκε τα στιγμιότυπα, όταν αποθηκεύτηκαν ή γιατί αποθηκεύτηκαν.
Αυτή είναι η βασική πληροφορία που αποθηκεύει το αντικείμενο υποβολής για εσάς.

Για να δημιουργήσουμε ένα αντικείμενο υποβολής, ονομάζουμε `commit-tree 'και καθορίζουμε ένα μόνο δέντρο SHA-1 και τα οποία δεσμεύουν αντικείμενα, αν υπάρχουν, αμέσως πριν από αυτό.
Ξεκινήστε με το πρώτο δέντρο που γράψατε:

To create a commit object, you call `commit-tree` and specify a single tree SHA-1 and which commit objects, if any, directly preceded it.
Start with the first tree you wrote:

[source,console]
----
$ echo 'first commit' | git commit-tree d8329f
fdf4fc3344e67ab068f836878b6c4951e3b15f3d
----

Τώρα μπορούμε να δούμε το νέο μας αντικείμενο υποβολής με την `cat-file`:

[source,console]
----
$ git cat-file -p fdf4fc3
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon <schacon@gmail.com> 1243040974 -0700
committer Scott Chacon <schacon@gmail.com> 1243040974 -0700

first commit
----

The format for a commit object is simple: it specifies the top-level tree for the snapshot of the project at that point; the author/committer information (which uses your `user.name` and `user.email` configuration settings and a timestamp); a blank line, and then the commit message.

Η μορφή ενός αντικειμένου υποβολής είναι απλή: καθορίζει το δέντρο κορυφής για το στιγμιότυπο του έργου σε εκείνο το σημείο. οι πληροφορίες συγγραφέα / εντολοδόχου (οι οποίες χρησιμοποιούν τις ρυθμίσεις διαμόρφωσης "user.name" και "user.email" και ένα timestamp). μια κενή γραμμή και στη συνέχεια το μήνυμα υποβολής.

Στη συνέχεια, θα γράψουμε τα άλλα δύο αντικείμενα υποβολής, καθένα από τα οποία αναφέρεται στην ακριβώς προηγούμενή του υποβολή:

[source,console]
----
$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3
cac0cab538b970a37ea1e769cbbde608743bc96d
$ echo 'third commit'  | git commit-tree 3c4e9c -p cac0cab
1a410efbd13591db07496601ebc7a059dd55cfe9
----

Κάθε ένα από τα τρία αντικείμενα υποβολής δείχνει σε ένα από τα τρία δέντρα στιγμιότυπων που δημιουργήσατε.
Πολύ περίεργα, έχουμε μια πραγματική ιστορία Git τώρα που μπορούμε να δούμε με την εντολή `git log`, αν την εκτελέσουμε στο τελευταίο SHA-1:

Each of the three commit objects points to one of the three snapshot trees you created.
Oddly enough, you have a real Git history now that you can view with the `git log` command, if you run it on the last commit SHA-1:

[source,console]
----
$ git log --stat 1a410e
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:15:24 2009 -0700

	third commit

 bak/test.txt | 1 +
 1 file changed, 1 insertion(+)

commit cac0cab538b970a37ea1e769cbbde608743bc96d
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:14:29 2009 -0700

	second commit

 new.txt  | 1 +
 test.txt | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:09:34 2009 -0700

    first commit

 test.txt | 1 +
 1 file changed, 1 insertion(+)
----

Καταπληκτικό.
Έχουμε κάνει τις λειτουργίες χαμηλού επιπέδου για να δημιουργήσουμε ένα ιστορικό Git χωρίς να χρησιμοποιήσουμε κάποια από τις εντολές του μπροστινού τέλους.
Αυτό είναι ουσιαστικά αυτό που κάνει το Git όταν τρέχουμε τις εντολές `git add` και` git commit` - αποθηκεύει τα blobs για τα αλλαγμένα αρχεία, ενημερώνει το ευρετήριο, γράφει δέντρα και γράφει δεσμεύει αντικείμενα που αναφέρονται στα δέντρα κορυφαίου επιπέδου και τις υποβολές που ήρθαν αμέσως μπροστά τους.
Αυτά τα τρία κύρια αντικείμενα Git --το blob, το δέντρο και η υποβολή-- αποθηκεύονται αρχικά ως ξεχωριστά αρχεία στον κατάλογο `.git / objects '.
Εδώ είναι όλα τα αντικείμενα στον κατάλογο παραδειγμάτων τώρα, σχολίασε με αυτό που αποθηκεύουν:

Amazing.
You've just done the low-level operations to build up a Git history without using any of the front end commands.
This is essentially what Git does when you run the `git add` and `git commit` commands – it stores blobs for the files that have changed, updates the index, writes out trees, and writes commit objects that reference the top-level trees and the commits that came immediately before them.
These three main Git objects – the blob, the tree, and the commit – are initially stored as separate files in your `.git/objects` directory.
Here are all the objects in the example directory now, commented with what they store:

[source,console]
----
$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1
----

Αν ακολουθήσουμε όλους τους εσωτερικούς δείκτες, παίρνουμε ένα γράφημα αντικειμένων περίπου σαν αυτό:

.Όλα τα αντικείμενα στον κατάλογό μας Git.
image::images/data-model-3.png[Όλα τα αντικείμενα στον κατάλογό μας Git.]

==== Αποθήκευση αντικειμένων

We mentioned earlier that a header is stored with the content.
Let's take a minute to look at how Git stores its objects.
You'll see how to store a blob object – in this case, the string ``what is up, doc?'' – interactively in the Ruby scripting language.

Αναφέρθηκε προηγουμένως ότι αποθηκεύεται μια κεφαλίδα με το περιεχόμενο.
Ας πάρουμε ένα λεπτό για να δούμε πώς το Git αποθηκεύει τα αντικείμενά του.
Θα δούμε πώς μπορούμε να αποθηκεύσουμε ένα αντικείμενο blob - στην περίπτωση αυτή, τη συμβολοσειρά ``what's up, doc?'' --διαδραστικά στη γλώσσα προγραμματισμού Ruby.

Μπορούμε να ξεκινήσουμε μία διαδραστική λειτουργία Ruby με την εντολή `irb`:

[source,console]
----
$ irb
>> content = "what is up, doc?"
=> "what is up, doc?"
----

Το Git κατασκευάζει μια κεφαλίδα που ξεκινάει με τον τύπο του αντικειμένου, στην περίπτωση αυτή ένα blob.
Στη συνέχεια, προσθέτει ένα κενό που ακολουθείται από το μέγεθος του περιεχομένου και τέλος ένα byte null:

[source,console]
----
>> header = "blob #{content.length}\0"
=> "blob 16\u0000"
----

Το Git συγκολλά την κεφαλίδα και το αρχικό περιεχόμενο και στη συνέχεια υπολογίζει το SHA-1 άθροισμα ελέγχου αυτού του νέου περιεχομένου.
Μπορούμε να υπολογίσουμε την τιμή SHA-1 μιας συμβολοσειράς στο Ruby συμπεριλαμβάνοντας τη βιβλιοθήκη digest SHA1 με την εντολή `require` και στη συνέχεια να καλέσουμε` Digest :: SHA1.hexdigest () `με τη συμβολοσειρά:

Git concatenates the header and the original content and then calculates the SHA-1 checksum of that new content.
You can calculate the SHA-1 value of a string in Ruby by including the SHA1 digest library with the `require` command and then calling `Digest::SHA1.hexdigest()` with the string:

[source,console]
----
>> store = header + content
=> "blob 16\u0000what is up, doc?"
>> require 'digest/sha1'
=> true
>> sha1 = Digest::SHA1.hexdigest(store)
=> "bd9dbf5aae1a3862dd1526723246b20206e5fc37"
----

Το Git συμπιέζει το νέο περιεχόμενο με το zlib, το οποίο μπορούμε να κάνουμε στο Ruby με τη βιβλιοθήκη zlib.
Πρώτον, πρέπει να απαιτήσουμε τη βιβλιοθήκη και στη συνέχεια να εκτελέσουμε το `Zlib :: Deflate.deflate ()` στο περιεχόμενο:

Git compresses the new content with zlib, which you can do in Ruby with the zlib library.
First, you need to require the library and then run `Zlib::Deflate.deflate()` on the content:

[source,console]
----
>> require 'zlib'
=> true
>> zlib_content = Zlib::Deflate.deflate(store)
=> "x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D"
----

Τέλος, θα γράψουμε το περιεχόμενό μας που έχει αποπληθωριστεί με zlib σε ένα αντικείμενο στο δίσκο.
Θα καθορίσουμε τη διαδρομή του αντικειμένου που θέλουμε να γράψουμε (οι δύο πρώτοι χαρακτήρες της τιμής SHA-1 είναι το όνομα του υποκαταλόγου και οι τελευταίοι 38 χαρακτήρες είναι το όνομα του αρχείου μέσα σε αυτόν τον κατάλογο).
Στο Ruby, μπορούμε να χρησιμοποιήσουμε τη συνάρτηση `FileUtils.mkdir_p ()` για να δημιουργήσουμε τον υποκατάλογο εάν δεν υπάρχει.
Στη συνέχεια, ανοίξτε το αρχείο με `File.open ()` και γράψτε το προηγούμενο zlib-συμπιεσμένο περιεχόμενο στο αρχείο με μια `write ()` κλήση στο αρχείο χειρισμού που προκύπτει:

Finally, you'll write your zlib-deflated content to an object on disk.
You'll determine the path of the object you want to write out (the first two characters of the SHA-1 value being the subdirectory name, and the last 38 characters being the filename within that directory).
In Ruby, you can use the `FileUtils.mkdir_p()` function to create the subdirectory if it doesn't exist.
Then, open the file with `File.open()` and write out the previously zlib-compressed content to the file with a `write()` call on the resulting file handle:

[source,console]
----
>> path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]
=> ".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"
>> require 'fileutils'
=> true
>> FileUtils.mkdir_p(File.dirname(path))
=> ".git/objects/bd"
>> File.open(path, 'w') { |f| f.write zlib_content }
=> 32
----

Αυτό είναι --έχουμε δημιουργήσει ένα έγκυρο αντικείμενο Git blob.
Όλα τα αντικείμενα Git αποθηκεύονται με τον ίδιο τρόπο, μόνο με διαφορετικούς τύπους - αντί για το στρώμα κηλίδας, η κεφαλίδα θα αρχίσει με commit ή tree.
Επίσης, παρόλο που το περιεχόμενο των κηλίδων μπορεί να είναι σχεδόν οτιδήποτε, το περιεχόμενο της υποβολής και του δέντρου είναι πολύ συγκεκριμένα μορφοποιημένο.

That's it – you've created a valid Git blob object.
All Git objects are stored the same way, just with different types – instead of the string blob, the header will begin with commit or tree.
Also, although the blob content can be nearly anything, the commit and tree content are very specifically formatted.
