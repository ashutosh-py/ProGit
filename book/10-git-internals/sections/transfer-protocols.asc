=== Πρωτόκολλα μεταφοράς

Το Git μπορεί να μεταφέρει δεδομένα μεταξύ δύο χώρων αποθήκευσης με δύο βασικούς τρόπους: το πρωτόκολλο ``dumb'' και το πρωτόκολλο ``smart''.
Αυτή η ενότητα θα καλύψει γρήγορα τον τρόπο λειτουργίας αυτών των δύο κύριων πρωτοκόλλων.

Git can transfer data between two repositories in two major ways: the ``dumb'' protocol and the ``smart'' protocol.
This section will quickly cover how these two main protocols operate.

==== Το χαζό πρωτόκολλο

Εάν ρυθμίζουμε ένα αποθετήριο που θα εμφανίζεται μόνο για ανάγνωση μέσω HTTP, το πρόχειρο dumb είναι πιθανό τι θα χρησιμοποιηθεί.
Αυτό το πρωτόκολλο ονομάζεται ``dumb'' επειδή δεν απαιτεί ειδικό κώδικα Git στην πλευρά του διακομιστή κατά τη διάρκεια της διαδικασίας μεταφοράς. η διαδικασία παραλαβής είναι μια σειρά αιτήσεων HTTP `GET`, όπου ο πελάτης μπορεί να αναλάβει τη διάταξη του αποθετηρίου Git στο διακομιστή.

If you're setting up a repository to be served read-only over HTTP, the dumb protocol is likely what will be used.
This protocol is called ``dumb'' because it requires no Git-specific code on the server side during the transport process; the fetch process is a series of HTTP `GET` requests, where the client can assume the layout of the Git repository on the server.

[ΣΗΜΕΙΩΣΗ]
====
Το αλλόκοτο πρωτόκολλο χρησιμοποιείται σπάνια αυτές τις μέρες.
Είναι δύσκολο να εξασφαλιστεί ή να γίνει ιδιωτική, έτσι ώστε οι περισσότεροι κεντρικοί υπολογιστές Git (τόσο στο σύννεφο όσο και στο χώρο) θα αρνηθούν να το χρησιμοποιήσουν.
Συνήθως συνιστάται να χρησιμοποιήσουμε το έξυπνο πρωτόκολλο, το οποίο περιγράφουμε λίγο περισσότερο.

The dumb protocol is fairly rarely used these days.
It's difficult to secure or make private, so most Git hosts (both cloud-based and on-premises) will refuse to use it.
It's generally advised to use the smart protocol, which we describe a bit further on.
====

Ας ακολουθήσουμε τη διαδικασία `http-fetch` για τη βιβλιοθήκη simplegit:

[source,console]
----
$ git clone http://server/simplegit-progit.git
----

Το πρώτο πράγμα που κάνει αυτή η εντολή είναι να κατεβάσουμε το αρχείο info / refs.
Αυτό το αρχείο γράφεται από την εντολή `update-server-info`, γι' αυτό πρέπει να το ενεργοποιήσουμε ως άγκιστρο `post-receive` για να λειτουργήσει σωστά η μεταφορά HTTP:

The first thing this command does is pull down the `info/refs` file.
This file is written by the `update-server-info` command, which is why you need to enable that as a `post-receive` hook in order for the HTTP transport to work properly:

[source]
----
=> GET info/refs
ca82a6dff817ec66f44342007202690a93763949     refs/heads/master
----

Τώρα έχουμε μια λίστα με τις απομακρυσμένες αναφορές και τα SHA-1.
Στη συνέχεια, αναζητάτε ποια είναι η αναφορά HEAD, ώστε να ξέρουμε τι να ελέγξουμε όταν τελειώσουμε:

Now you have a list of the remote references and SHA-1s.
Next, you look for what the HEAD reference is so you know what to check out when you're finished:

[source]
----
=> GET HEAD
ref: refs/heads/master
----

Θα πρέπει να ελέγξουμε τον κλάδο `master` όταν ολοκληρώσουμε τη διαδικασία.
Σε αυτό το σημείο, είστε έτοιμοι να ξεκινήσουμε τη διαδικασία περπατήματος.
Επειδή το σημείο εκκίνησής μας είναι το αντικείμενο υποβολής `ca82a6` που είδαμε στο αρχείο` info / refs`, ξεκινάτε με το φόρτωμα που:

You need to check out the `master` branch when you've completed the process.
At this point, you're ready to start the walking process.
Because your starting point is the `ca82a6` commit object you saw in the `info/refs` file, you start by fetching that:

[source]
----
=> GET objects/ca/82a6dff817ec66f44342007202690a93763949
(179 bytes of binary data)
----

Παίρνουμε ένα αντικείμενο πίσω --το αντικείμενο βρίσκεται σε χαλαρή μορφή στο διακομιστή και το έχουμε τραβήξει σε ένα στατικό HTTP GET αίτημα.
Μπορούμε να το αποσυμπιέσουμε, να απογυμνώσουμε την κεφαλίδα και να εξετάσουμε το περιεχόμενο της υποβολής:

You get an object back – that object is in loose format on the server, and you fetched it over a static HTTP GET request.
You can zlib-uncompress it, strip off the header, and look at the commit content:

[source,console]
----
$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon <schacon@gmail.com> 1205815931 -0700
committer Scott Chacon <schacon@gmail.com> 1240030591 -0700

changed the version number
----

Έπειτα, έχουμε δύο επιπλέον αντικείμενα για να ανακτήσουμε - `cfda3b`, το δέντρο του περιεχομένου που η υποβολή μόλις ανακτήσαμε. και `085bb3`, η οποία είναι η μητρική υποβολή:

Next, you have two more objects to retrieve – `cfda3b`, which is the tree of content that the commit we just retrieved points to; and `085bb3`, which is the parent commit:

[source]
----
=> GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
(179 bytes of data)
----

Αυτό μας δίνει το επόμενο αντικείμενο υποβολής.
Πιάσε το αντικείμενο του δέντρου:

That gives you your next commit object.
Grab the tree object:

[source]
----
=> GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
(404 - Not Found)
----

Ωχ - φαίνεται ότι το αντικείμενο του δέντρου δεν είναι σε χαλαρή μορφή στο διακομιστή, οπότε παίρνουμε πίσω μια απάντηση 404.
Υπάρχουν δύο λόγοι γι' αυτό --το αντικείμενο θα μπορούσε να βρίσκεται σε ένα εναλλακτικό αποθετήριο ή θα μπορούσε να είναι σε ένα πακέτο πακέτων σε αυτό το αποθετήριο.
Το Git ελέγχει πρώτα τα καταχωρημένα εναλλακτικά:

Oops – it looks like that tree object isn't in loose format on the server, so you get a 404 response back.
There are a couple of reasons for this – the object could be in an alternate repository, or it could be in a packfile in this repository.
Git checks for any listed alternates first:

[source]
----
=> GET objects/info/http-alternates
(empty file)
----

Αν αυτό επανέλθει με μια λίστα εναλλακτικών διευθύνσεων URL, το Git ελέγχει τα χαλαρά αρχεία και τα πακέτα πακέτων εκεί - αυτός είναι ένας ωραίος μηχανισμός για έργα που είναι διχαλωτές μεταξύ τους για να μοιράζονται αντικείμενα στο δίσκο.
Ωστόσο, επειδή σε αυτήν την περίπτωση δεν αναφέρονται εναλλακτικές, το αντικείμενο πρέπει να βρίσκεται σε ένα πακέτο.
Για να δούμε τι πακέτα πακέτων είναι διαθέσιμα σε αυτόν τον διακομιστή, πρέπει να πάρουμε το αρχείο `objects / info / packs`, το οποίο περιέχει μια λίστα αυτών (που επίσης δημιουργείται από το` update-server-info`):

If this comes back with a list of alternate URLs, Git checks for loose files and packfiles there – this is a nice mechanism for projects that are forks of one another to share objects on disk.
However, because no alternates are listed in this case, your object must be in a packfile.
To see what packfiles are available on this server, you need to get the `objects/info/packs` file, which contains a listing of them (also generated by `update-server-info`):

[source]
----
=> GET objects/info/packs
P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
----

Υπάρχει μόνο ένα πακέτο πακέτων στο διακομιστή, οπότε το αντικείμενο μας είναι προφανές εκεί, αλλά θα ελέγξουμε το αρχείο ευρετηρίου για να βεβαιωθείτε.
Αυτό είναι επίσης χρήσιμο εάν έχουμε πολλαπλούς πακέτες packet στον διακομιστή, έτσι ώστε να μπορούμε να δούμε ποιο packfile περιέχει το αντικείμενο που χρειάζεστε:

There is only one packfile on the server, so your object is obviously in there, but you'll check the index file to make sure.
This is also useful if you have multiple packfiles on the server, so you can see which packfile contains the object you need:

[source]
----
=> GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
(4k of binary data)
----

Τώρα που έχουμε το ευρετήριο packfile, μπορούμε να δούμε αν το αντικείμενο είναι μέσα σε αυτό - επειδή το ευρετήριο παραθέτει τα SHA-1s των αντικειμένων που περιέχονται στο packfile και τα αντισταθμιστικά σε αυτά τα αντικείμενα.
Το αντικείμενο μας είναι εκεί, έτσι προχωρήστε και πάρτε ολόκληρο το πακέτο:

Now that you have the packfile index, you can see if your object is in it – because the index lists the SHA-1s of the objects contained in the packfile and the offsets to those objects.
Your object is there, so go ahead and get the whole packfile:

[source]
----
=> GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
(13k of binary data)
----

Έχουμε το αντικείμενο του δέντρου μας, έτσι συνεχίζουμε να περπατάτε τις υποβολές μας.
Όλα είναι επίσης μέσα στο αρχείο πακέτου που μόλις κατεβάσατε, οπότε δεν χρειάζεται να κάνουμε άλλα αιτήματα στον διακομιστή μας.
Το Git ελέγχει ένα αντίγραφο εργασίας του κλάδου `master` το οποίο υποδείχθηκε από την αναφορά HEAD που κατεβάσαμε στην αρχή.

You have your tree object, so you continue walking your commits.
They're all also within the packfile you just downloaded, so you don't have to do any more requests to your server.
Git checks out a working copy of the `master` branch that was pointed to by the HEAD reference you downloaded at the beginning.

==== Το έξυπνο πρωτόκολλο

Το απλό πρωτόκολλο είναι απλό, αλλά λίγο αναποτελεσματικό και δεν μπορεί να χειριστεί τη γραφή δεδομένων από τον πελάτη στο διακομιστή.
Το έξυπνο πρωτόκολλο είναι μια πιο κοινή μέθοδος μεταφοράς δεδομένων, αλλά απαιτεί μια διαδικασία στο απομακρυσμένο άκρο που είναι έξυπνη για το Git - μπορεί να διαβάσει τα τοπικά δεδομένα, να καταλάβει τι έχει και χρειάζεται ο πελάτης και να δημιουργήσει ένα προσαρμοσμένο packfile για αυτό.
Υπάρχουν δύο ομάδες διαδικασιών για τη μεταφορά δεδομένων: ένα ζεύγος για τη μεταφόρτωση δεδομένων και ένα ζεύγος για τη λήψη δεδομένων.

The dumb protocol is simple but a bit inefficient, and it can't handle writing of data from the client to the server.
The smart protocol is a more common method of transferring data, but it requires a process on the remote end that is intelligent about Git – it can read local data, figure out what the client has and needs, and generate a custom packfile for it.
There are two sets of processes for transferring data: a pair for uploading data and a pair for downloading data.

===== Μεταφόρτωση δεδομένων

(((git εντολές, send-pack)))) (((git εντολές, λήψη-πακέτο)))
Για να μεταφορτώσει δεδομένα σε μια απομακρυσμένη διαδικασία, το Git χρησιμοποιεί τις διαδικασίες `send-pack` και `receive-pack`.
Η διαδικασία "αποστολής-συσκευασίας" εκτελείται στον πελάτη και συνδέεται με μια διαδικασία `receive-pack 'στην απομακρυσμένη πλευρά.

(((git commands, send-pack)))(((git commands, receive-pack)))
To upload data to a remote process, Git uses the `send-pack` and `receive-pack` processes.
The `send-pack` process runs on the client and connects to a `receive-pack` process on the remote side.

====== SSH

Για παράδειγμα, ας πούμε ότι τρέχουμε το `git push master master` στο έργο μας, και` προέλευση 'ορίζεται ως μια διεύθυνση URL που χρησιμοποιεί το πρωτόκολλο SSH.
Το Git ενεργοποιεί τη διαδικασία `send-pack`, η οποία ενεργοποιεί μια σύνδεση μέσω SSH στο διακομιστή μας.
Προσπαθεί να εκτελέσει μια εντολή στον απομακρυσμένο διακομιστή μέσω μιας κλήσης SSH που μοιάζει με κάτι τέτοιο:

For example, say you run `git push origin master` in your project, and `origin` is defined as a URL that uses the SSH protocol.
Git fires up the `send-pack` process, which initiates a connection over SSH to your server.
It tries to run a command on the remote server via an SSH call that looks something like this:

[source,console]
----
$ ssh -x git@server "git-receive-pack 'simplegit-progit.git'"
00a5ca82a6dff817ec66f4437202690a93763949 refs/heads/master□report-status \
	delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1+github-607-gfba4028 delete-refs
0000
----

Η εντολή git-receive-pack αποκρίνεται αμέσως με μία γραμμή για κάθε αναφορά που αυτή τη στιγμή έχει - στην περίπτωση αυτή, μόνο τον κλάδο `master` και το SHA-1 του.
Η πρώτη γραμμή περιέχει επίσης μια λίστα με τις δυνατότητες του διακομιστή (εδώ, `status-report`,` delete-refs` και μερικές άλλες, συμπεριλαμβανομένου του αναγνωριστικού πελάτη).

The `git-receive-pack` command immediately responds with one line for each reference it currently has – in this case, just the `master` branch and its SHA-1.
The first line also has a list of the server's capabilities (here, `report-status`, `delete-refs`, and some others, including the client identifier).

Each line starts with a 4-character hex value specifying how long the rest of the line is.
Your first line starts with 005b, which is hexadecimal for 91, meaning that 91 bytes remain on that line.
The next line starts with 003e, which is 62, so you read the remaining 62 bytes.
The next line is 0000, meaning the server is done with its references listing.

Κάθε γραμμή ξεκινάει με μια τετραψήφια εξαγωνική τιμή που καθορίζει πόσο καιρό είναι το υπόλοιπο της γραμμής.
Η πρώτη γραμμή ξεκινά με 005b, η οποία είναι δεκαεξαδική για 91, πράγμα που σημαίνει ότι 91 bytes παραμένουν στη γραμμή αυτή.
Η επόμενη γραμμή ξεκινά με 003e, δηλαδή 62, οπότε διαβάζουμε τα υπόλοιπα 62 byte.
Η επόμενη γραμμή είναι 0000, πράγμα που σημαίνει ότι ο διακομιστής γίνεται με τη λίστα αναφοράς.

Τώρα που γνωρίζει την κατάσταση του διακομιστή, η διαδικασία `send-pack` μάς καθορίζει τι δεσμεύει ότι έχει ο διακομιστής.
Για κάθε αναφορά που θα ενημερώσει αυτή η ώθηση, η διαδικασία `send-pack` αναφέρει τη διαδικασία `receive-pack` εκείνη την πληροφορία.
Για παράδειγμα, εάν ενημερώνουμε τον κλάδο `master` και προσθέτουμε έναν κλάδο `experiment`, η απάντηση `send-pack` μπορεί να μοιάζει με αυτό:

Now that it knows the server's state, your `send-pack` process determines what commits it has that the server doesn't.
For each reference that this push will update, the `send-pack` process tells the `receive-pack` process that information.
For instance, if you're updating the `master` branch and adding an `experiment` branch, the `send-pack` response may look something like this:

[source]
----
0076ca82a6dff817ec66f44342007202690a93763949 15027957951b64cf874c3557a0f3547bd83b3ff6 \
	refs/heads/master report-status
006c0000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d \
	refs/heads/experiment
0000
----

Git sends a line for each reference you're updating with the line's length, the old SHA-1, the new SHA-1, and the reference that is being updated.
The first line also has the client's capabilities.
The SHA-1 value of all '0's means that nothing was there before – because you're adding the experiment reference.
If you were deleting a reference, you would see the opposite: all '0's on the right side.

Το Git στέλνει μια γραμμή για κάθε αναφορά που ενημερώνουμε με το μήκος της γραμμής, το παλιό SHA-1, το νέο SHA-1 και την αναφορά που ενημερώνεται.
Η πρώτη γραμμή έχει επίσης τις δυνατότητες του πελάτη.
Η τιμή SHA-1 όλων των '0 σημαίνει ότι τίποτα δεν υπήρχε πριν - επειδή προσθέτουμε την αναφορά του πειράματος.
Εάν διαγράψαμε μια αναφορά, θα δούμε το αντίθετο: όλα τα '0 στη δεξιά πλευρά.

Στη συνέχεια, ο υπολογιστής-πελάτης στέλνει ένα πακέτο πακέτων από όλα τα αντικείμενα που δεν έχει ακόμα ο διακομιστής.
Τέλος, ο διακομιστής ανταποκρίνεται με μια ένδειξη επιτυχίας (ή βλάβης):

Next, the client sends a packfile of all the objects the server doesn't have yet.
Finally, the server responds with a success (or failure) indication:

[source]
----
000eunpack ok
----

====== HTTP(S)

Αυτή η διαδικασία είναι ως επί το πλείστον η ίδια σε σχέση με το HTTP, αν και η χειραψία είναι λίγο διαφορετική.
Η σύνδεση ξεκινά με αυτό το αίτημα:

[source]
----
=> GET http://server/simplegit-progit.git/info/refs?service=git-receive-pack
001f# service=git-receive-pack
00ab6c5f0e45abd7832bf23074a333f739977c9e8188 refs/heads/master□report-status \
	delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1~vmg-bitmaps-bugaloo-608-g116744e
0000
----

Αυτό είναι το τέλος της πρώτης ανταλλαγής πελάτη-εξυπηρετητή.
Στη συνέχεια ο πελάτης υποβάλλει ένα άλλο αίτημα, αυτή τη φορά ένα `POST`, με τα δεδομένα που παρέχει το` git-upload-pack`.

That's the end of the first client-server exchange.
The client then makes another request, this time a `POST`, with the data that `git-upload-pack` provides.

[source]
----
=> POST http://server/simplegit-progit.git/git-receive-pack
----

Το αίτημα `POST` περιλαμβάνει την έξοδο `send-pack` και το πακέτο ως το ωφέλιμο φορτίο του.
Ο διακομιστής τότε υποδεικνύει επιτυχία ή αποτυχία με την απόκριση HTTP.

===== Λήψη δεδομένων

(((git εντολές, fetch-pack)))) (((git εντολές, upload-pack)))
Όταν κάνουμε λήψη δεδομένων, εμπλέκονται οι διαδικασίες `fetch-pack` και` upload-pack`.
Ο πελάτης ξεκινά μια διαδικασία `fetch-pack 'που συνδέεται με μια διαδικασία upload-pack στην απομακρυσμένη πλευρά για να διαπραγματευτεί ποια δεδομένα θα μεταφερθούν προς τα κάτω.

(((git commands, fetch-pack)))(((git commands, upload-pack)))
When you download data, the `fetch-pack` and `upload-pack` processes are involved.
The client initiates a `fetch-pack` process that connects to an `upload-pack` process on the remote side to negotiate what data will be transferred down.

====== SSH

Αν κάνουμε την ανάκτηση μέσω SSH, η `fetch-pack` τρέχει κάτι τέτοιο:

[source,console]
----
$ ssh -x git@server "git-upload-pack 'simplegit-progit.git'"
----

Αφού η `fetch-pack` συνδεθεί, η `upload-pack` επιστρέφει κάτι σαν αυτό:

[source]
----
00dfca82a6dff817ec66f44342007202690a93763949 HEAD□multi_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fe2409a098dc3e53539a9028a94b6224db9d6a6b6 refs/heads/master
0000
----

This is very similar to what `receive-pack` responds with, but the capabilities are different.
In addition, it sends back what HEAD points to (`symref=HEAD:refs/heads/master`) so the client knows what to check out if this is a clone.

Αυτό είναι πολύ παρόμοιο με αυτό που αποκρίνεται με το `receive-pack`, αλλά οι δυνατότητες είναι διαφορετικές.

Επιπλέον, στέλνει πίσω τα κεφάλαια HEAD (`symref = HEAD: refs / heads / master) έτσι ώστε ο πελάτης να ξέρει τι να ελέγξει εάν είναι κλώνος.

Σε αυτό το σημείο, η διαδικασία `fetch-pack` εξετάζει ποια αντικείμενα έχει και ανταποκρίνεται με τα αντικείμενα που χρειάζεται, στέλνοντας` `want' 'και κατόπιν το SHA-1 που θέλει.
Αποστέλλει όλα τα αντικείμενα που έχει ήδη με ``have'' και στη συνέχεια το SHA-1.
Στο τέλος αυτής της λίστας, γράφει ``done'' για να ξεκινήσει η διαδικασία `upload-pack` για να ξεκινήσει η αποστολή του packfile των δεδομένων που χρειάζεται:

At this point, the `fetch-pack` process looks at what objects it has and responds with the objects that it needs by sending ``want'' and then the SHA-1 it wants.
It sends all the objects it already has with ``have'' and then the SHA-1.
At the end of this list, it writes ``done'' to initiate the `upload-pack` process to begin sending the packfile of the data it needs:

[source]
----
003cwant ca82a6dff817ec66f44342007202690a93763949 ofs-delta
0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
0009done
0000
----

====== HTTP(S)

Η χειραψία για μια λειτουργία λήψης απαιτεί δύο αιτήσεις HTTP.
Το πρώτο είναι ένα `GET` στο ίδιο τελικό σημείο που χρησιμοποιείται στο πρωτόκολλο dumb:

The handshake for a fetch operation takes two HTTP requests.
The first is a `GET` to the same endpoint used in the dumb protocol:

[source]
----
=> GET $GIT_URL/info/refs?service=git-upload-pack
001e# service=git-upload-pack
00e7ca82a6dff817ec66f44342007202690a93763949 HEAD□multi_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed no-done symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
0000
----

Αυτό είναι πολύ παρόμοιο με την κλήση του `git-upload-pack 'μέσω μιας σύνδεσης SSH, αλλά η δεύτερη ανταλλαγή γίνεται ως ξεχωριστό αίτημα:

[source]
----
=> POST $GIT_URL/git-upload-pack HTTP/1.0
0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7
0032have 441b40d833fdfa93eb2908e52742248faf0ee993
0000
----

Επαναλαμβάνουμε ότι αυτό είναι το ίδιο σχήμα όπως παραπάνω.
Η απάντηση σε αυτό το αίτημα υποδηλώνει επιτυχία ή αποτυχία και περιλαμβάνει το πακέτο.

Again, this is the same format as above.
The response to this request indicates success or failure, and includes the packfile.

==== Περίληψη πρωτοκόλλων

Αυτή η ενότητα περιέχει μια πολύ βασική επισκόπηση των πρωτοκόλλων μεταφοράς.
Το πρωτόκολλο περιλαμβάνει πολλά άλλα χαρακτηριστικά, όπως δυνατότητες `multi_ack` ή `sideband`, αλλά η κάλυψή τους είναι εκτός του πεδίου αυτού του βιβλίου.
Προσπαθήσαμε να μας δώσουμε μια αίσθηση της γενικής οπισθοπορείας μεταξύ πελάτη και διακομιστή. αν χρειάζεστε περισσότερες γνώσεις από αυτό, ίσως θέλουμε να ρίξουμε μια ματιά στον πηγαίο κώδικα Git.
