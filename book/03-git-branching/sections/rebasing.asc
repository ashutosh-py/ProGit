[[_rebasing]]
=== Rebasing

(((rebasing)))
Στο Git, υπάρχουν δύο βασικοί τρόποι ενσωμάτωσης των αλλαγών από έναν κλάδο σε έναν άλλο: με την εντολή `merge' και την εντολή `rebase` (επανατοποθέτηση).
Σε αυτήν την ενότητα θα δούμε τι είναι η επανατοποθέτηση, πώς την κάνουμε, γιατί θεωρείται εκπληκτικό εργαλείο και σε ποιες περιπτώσεις δεν θα θέλουμε να την χρησιμοποιήσουμε.


==== The Basic Rebase

Εάν επιστρέψουμε σε ένα παλαιότερο παράδειγμα από το <<_basic_merging>>, θα δούμε ότι η δουλειά μας είχε αποκλίνει και είχαμε κάνει υποβολές δύο διαφορετικούς κλάδους.

.Απλό αποκλίνον ιστορικό.
image::images/basic-rebase-1.png[Απλό αποκλίνον ιστορικό.]

Ο ευκολότερος τρόπος ενσωμάτωσης των κλάδων, όπως έχουμε ήδη δει, είναι η εντολή `merge` (συγχώνευση).
Επιτελεί μια τριμερή συγχώνευση μεταξύ των δύο τελευταίων στιγμιότυπων διακλάδωσης (`C3` και`C4`) και του πιο πρόσφατου κοινού προγόνου τους (`C2`), δημιουργώντας ένα νέο στιγμιότυπο (και υποβολή).

.Συγχώνευση και ενσωμάτωση αποκλίνοντος ιστορικού εργασίας.
image::images/basic-rebase-2.png[Συγχώνευση και ενσωμάτωση αποκλίνοντος ιστορικού εργασίας.]

Ωστόσο, υπάρχει κι ένας άλλος τρόπος: μπορούμε να πάρουμε μόνον τις αλλαγές που εισήχθησαν με την υποβολή `C4` και να τις εφαρμόσουμε (επανατοποθετήσουμε) ξανά στο στιγμιότυπο `C3`.
Στο Git, αυτό ονομάζεται _επανατοποθέτηση_ (rebasing).
Με την εντολή `rebase` μπορούμε να πάρουμε όλες τις αλλαγές που υποβλήθηκαν σε ένα κλάδο και να τις επαναλάβουμε σε έναν άλλο.(((git commands, rebase)))

Σε αυτό το παράδειγμα, θα τρέχαμε τα παρακάτω:

[source,console]
----
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
----

Η διαδικασία που ακολουθείται με την εντολή `rebase` είναι η εξής: μεταβαίνει στον κοινό πρόγονο των δύο κλάδων (εκείνου στον οποίο βρισκόμαστε και εκείνου τον οποίο θα αναπροσαρμόσουμε και παίρνει τις διαφορές (diff) που εισάγονται από κάθε υποβολή του κλάδου στον οποίο που βρισκόμαστε· αποθηκεύει αυτές τις διαφορές σε προσωρινά αρχεία, μετατοπίζει τον τρέχοντα κλάδο στην ίδια υποβολή στην οποία βρίσκεται και ο κλάδος τον οποίο θα αναπροσαρμόσουμε και, τέλος, εφαρμόζει τις αλλαγές την μία μετά την άλλη με την σειρά τους.

.Επανατοποθέτηση των αλλαγών του στιγμιότυπου `C4` στο στιγμιότυπο `C3`.
image::images/basic-rebase-3.png[Επανατοποθέτηση των αλλαγών του στιγμιότυπου `C4` στο στιγμιότυπο `C3`.]

Σε αυτό το σημείο, μπορούμε να επιστρέψουμε στον κύριο κλάδο και να τον ταχυπροωθήσουμε.

[source,console]
----
$ git checkout master
$ git merge experiment
----

.Ταχυπροώθηση του κύριου κλάδου.
image::images/basic-rebase-4.png[Ταχυπροώθηση του κύριου κλάδου.]

Πλέον το στιγμιότυπο στο οποίο δείχνει η υποβολή `C4` είναι ακριβώς ίδιο με αυτό στο οποίο δείχνει η `C5` στο παλιότερο παράδειγμα της συγχώνευσης.
Το τελικό προϊόν της ενσωμάτωσης των αλλαγών είναι ακριβώς το ίδιο αλλά η επανατοποθέτηση κρατά το ιστορικό πιο τακτοποιημένο.
Αν εξετάσουμε το αρχείο καταγραφής ενός επανατοποθετημένου κλάδου, μοιάζει με γραμμικό ιστορικό: φαίνεται σαν όλη η εργασία να συνέβη στην σειρά παρά το ότι αρχικά γινόταν παράλληλα.

Συχνά, θα κάνετε κάτι τέτοιο για να βεβαιωθείτε ότι οι υποβολές σας εφαρμόζονται σωστά σε έναν απομακρυσμένο κλάδο – ενδεχομένως σε ένα έργο στο οποίο συμβάλλετε αλλά που δεν διατηρείτε.
Σε αυτήν την περίπτωση, θα κάνατε τη δουλειά σας σε έναν κλάδο και στη συνέχεια θα επανατοποθετούσατε την εργασία σας στον κλάδο `origin/master` όταν ήσασταν έτοιμοι να υποβάλλετε τις διορθώσεις σας στο κύριο έργο.
Με αυτόν τον τρόπο, ο συντηρητής δεν χρειάζεται να κάνει καμία εργασία ενσωμάτωσης – απλά μια ταχυπροώθηση ή μια καθαρή εφαρμογή.

Ας σημειωθεί ότι το στιγμιότυπο στο οποίο δείχνει η τελική υποβολή, δηλαδή αυτήν στην οποία καταλήγουμε, είναι το ίδιο είτε πρόκειται για την τελευταία από τις επανατοποθετημένες υποβολές μετά από συγχώνευση είτε η τελική υποβολή συγχώνευσης μετά από μία συγχώνευση – μόνον το ιστορικό είναι διαφορετικό.
Η επανατοποθέτηση εφαρμόζει αλλαγές μίας γραμμής εργασίας σε μία άλλη με την σειρά που έγιναν, ενώ η συγχώνευση παίρνει την τελικά στιγμιότυπα και τα συγχωνεύει.

==== More Interesting Rebases

You can also have your rebase replay on something other than the rebase target branch.
Take a history like <<rbdiag_e>>, for example.
You branched a topic branch (`server`) to add some server-side functionality to your project, and made a commit.
Then, you branched off that to make the client-side changes (`client`) and committed a few times.
Finally, you went back to your server branch and did a few more commits.

Μπορούμε επίσης να εφαρμόσουμε την επανατοποθέτηση σε κάποιον κλάδο διαφορετικό από τον κλάδο στόχου επαναδιαπραγμάτευσης.
Για παράδειγμα, ας πάρουμε ένα ιστορικό όπως το <<rbdiag_e>>.
Έχουμε δημιουργήσει μία διακλάδωση από έναν τοπικό κλάδο (`server`) για να προσθέσουμε κάποια λειτουργικότητα από την πλευρά του διακομιστή στο έργο μας και πραγματοποιήσαμε μια υποβολή.
Στη συνέχεια, δημιουργήσαμε μία ακόμα διακλάδωση για να κάνουμε τις αλλαγές από την πλευρά του πελάτη (`client`) και κάναμε επίσης μερικές υποβολές.
Τέλος, επιστρέψαμε στον κλάδο `server` και κάναμε μερικές ακόμη υποβολές.

[[rbdiag_e]]
.Ιστορικό με έναν κλάδο να ξεπετάγεται από έναν άλλο κλάδο.
image::images/interesting-rebase-1.png[Ιστορικό με έναν κλάδο να ξεπετάγεται από έναν άλλο κλάδο.]

Ας υποθέσουμε ότι αποφασίζουμε να συγχωνεύσουμε τις αλλαγές από την πλευρά του πελάτη στην κεντρική γραμμή που θα δημοσιοποιηθεί αλλά θέλουμε να αναβάλλουμε τις αλλαγές από την πλευρά του διακομιστή μέχρι να εξεταστούν περαιτέρω.
Μπορούμε να πάρουμε τις αλλαγές από τον κλάδο `client` που δεν βρίσκονται στον κλάδο `server` (`C8` και`C9`) και να τις αναπαράγουμε στον κύριο κλάδο μας χρησιμοποιώντας την επιλογή `--onto` της `git rebase`:

[source,console]
----
$ git rebase --onto master server client
----

Αυτή η εντολή ουσιαστικά λέει, ``Μετάβαινε στον κλάδο `client`, βρες τις διορθώσεις από τον κοινό πρόγονο των κλάδων `client` και `server` και στηβ συνέχεια εφάρμοσέ τις στον κλάδο `master`.
Είναι λίγο περίπλοκο, αλλά το αποτέλεσμα είναι πολύ όμορφο.

.Επανατοποθέτηση ενός τοπικού κλάδου σε έναν άλλο τοπικό κλάδο.
image::images/interesting-rebase-2.png[Επανατοποθέτηση ενός τοπικού κλάδου σε έναν άλλο τοπικό κλάδο.]

Τώρα μπορούμε να ταχυπροωθήσουμε τον κύριο κλάδο (βλ. <<rbdiag_g>>):

[source,console]
----
$ git checkout master
$ git merge client
----

[[rbdiag_g]]
.Ταχυπροώθηση του κύριου κλάδου ώστε να περιλάβη τις αλλαγές του κλάδου `client`.
image::images/interesting-rebase-3.png[Ταχυπροώθηση του κύριου κλάδου ώστε να περιλάβη τις αλλαγές του κλάδου `client`.]

Ας πούμε ότι τώρα αποφασίζουμε να ανασύρουμε και τον κλάδο `server`.
Μπορούμε να επανατοποθετήσουμε τον κλάδο `server` στον κύριο κλάδο χωρίς να πρέπει να μεταβούμε σε αυτόν προηγουμένως εκτελώντας το `git rebase <basebranch> <topicbranch>` – που μεταβαίνει στον τοπικό κλάδο (σε αυτήν την περίπτωση, τον `server`) για εμάς και εφαρμόζει τις αλλαγές του στον βασικό κλάδο (`master`):

[source,console]
----
$ git rebase master server
----

Η παραπάνω εφαρμόζει την εργασία που είχατε κάνει στον `server` στον κλάδο `master`, όπως φαίνεται στο <<rbdiag_h>>.

[[rbdiag_h]]
.Επανατοποθέτηση του κλάδου `server` στον κλάδο `master`.
image::images/interesting-rebase-4.png[Επανατοποθέτηση του κλάδου `server` στον κλάδο `master`.]

Στη συνέχεια μπορούμε να ταχυπροωθήσουμε τον βασικό κλάδο (`master`):

[source,console]
----
$ git checkout master
$ git merge server
----

Μπορούμε να αφαιρέσουμε τους κλάδους `client` και `server` επειδή όλα τα έργα είναι ολοκληρωμένα και δεν τα χρειαζόμαστε πια, αφήνοντας το ιστορικό μας για όλη αυτήν την διαδικασία να μοιάζει με το <<rbdiag_i>>:

[source,console]
----
$ git branch -d client
$ git branch -d server
----

[[rbdiag_i]]
.τελικό ιστορικό υποβολών
image::images/interesting-rebase-5.png[Τελικό ιστορικό υποβολών.]

[[_rebase_peril]]
==== Οι κίνδυνοι της επανατοποθέτησης

(((rebasing, perils of)))
Όμως η ευτυχία της επανατοποθέτησης έχει και αυτή τα μειονεκτήματά της, τα οποία μπορούν να συνοψιστούν σε μία γραμμή:

** Μην επανατοποθετείτε υποβολές που υπάρχουν εκτός του αποθετηρίου σας.**

Αν ακολουθήσετε αυτήν την συμβουλή, θα είστε μια χαρά.
Αν δεν το κάνετε, θα γίνεται μισητός σε όλους τους ανθρώπους και και θα σας περιφρονήσουν φίλοι και οικογένεια.

When you rebase stuff, you're abandoning existing commits and creating new ones that are similar but different.
If you push commits somewhere and others pull them down and base work on them, and then you rewrite those commits with `git rebase` and push them up again, your collaborators will have to re-merge their work and things will get messy when you try to pull their work back into yours.

Όταν επανατοποθετούμε, εγκαταλείπουμε υπάρχουσες υποβολές και δημιουργούμε νέες που είναι παρόμοιες αλλά διαφορετικές.
Εάν προωθήσουμε υποβολές κάπου και άλλοι τις ανασύρουν και βασίσουν την δουλειά τους σε αυτές και στη συνέχεια ξαναγράψουμε αυτές τις υποβολές με `git rebase` και τις προωθήσουμε ξανά, οι συνεργάτες μας θα πρέπει να ξανασυγχωνεύσουν την δουλειά τους και τα πράγματα θα μπλέξουν όταν προσπαθήστουμε να ανασύρουμε την δουλειά τους πίσω στη δική μας.

Ας δούμε ένα παράδειγμα του τρόπου με τον οποίο η αναδιοργάνωση της εργασίας που έχουμε δημοσιοποιήσει μπορεί να προκαλέσει προβλήματα.
Ας υποθέσουμε ότι κλωνοποιούμε από έναν κεντρικό διακομιστή και στην συνέχεια κάνουμε κάποιες αλλαγές.
Το ιστορικό της υποβολής μας μοιάζει με αυτό:

.Κλωνοποίηση αποθετηρίου και επεξεργασία του.
image::images/perils-of-rebasing-1.png["Clone a repository, and base some work on it."]

Τώρα, κάποιος άλλος κάνει κι άλλη δουλειά που περιλαμβάνει συγχώνευση και προωθεί την δουλειά του στον κεντρικό διακομιστή.
Την ανασύρουμε και συγχωνεύουμε τον νέο απομακρυσμένο κλάδο στην δουλειά μας, κάνοντας το ιστορικό μας να μοιάζει με αυτό:

.Ανάσυρση περισσότερων υποβολών και συγχώνευσή τους στην εργασία μας.
image::images/perils-of-rebasing-2.png["Ανάσυρση περισσότερων υποβολών και συγχώνευσή τους στην εργασία μας."]

Στη συνέχεια, ο άνθρωπος που προώθησε την συγχωνευμένη δουλειά αποφασίζει να επιστρέψει και να επανατοποθετήσει την εργασία του· κάνει `git push --force'' για να επανεγγράψει το ιστορικό στον διακομιστή.
Στη συνέχεια, εμείς ανασύρουμε από τον διακομιστή και φέρνουμε τις νέες υποβολές.

[[_pre_merge_rebase_work]]
.Κάποιος προωθεί επανατοποθετημένες υποβολές, εγκαταλείποντας τις υποβολές στις οποίες έχουμε βασίσει την δουλειά μας
image::images/perils-of-rebasing-3.png["Κάποιος προωθεί επανατοποθετημένες υποβολές, εγκαταλείποντας τις υποβολές στις οποίες έχουμε βασίσει την δουλειά μας."]

Τώρα έχουμε μπλέξει άσχημα.
Εάν κάνουμε `git pull', θα δημιουργήσουμε μια δέσμευση συγχώνευσης που συμπεριλαμβάνει και τις δύο γραμμές του ιστορικού και το αποθετήριο μας θα μοιάζει με αυτό:

[[_merge_rebase_work]]
.Συγχώνευση της ίδιας εργασίας σε μία νέα υποβολή συγχώνευσης
image::images/perils-of-rebasing-4.png[συγχώνευση της ίδιας εργασίας σε μία νέα υποβολή συγχώνευσης.]

Εφόσον το ιστορικό μας μοιάζει με το παραπάνω, αν τρέξουμε ένα `git log`, θα δούμε δύο υποβολές που έχουν τον ίδιο συγγραφέα, ημερομηνία και μήνυμα, κάτι που προκαλεί σύγχυση.
Επιπλέον, αν προωθήσουμε αυτό το ιστορικό πίσω στον διακομιστή, θα επαναφέρουμε όλα εκείνες τις επανατοποθετημένες υποβολές στον κεντρικό εξυπηρετητή, κάτι που θα μπερδέψει ακόμα περισσότερο τον κόσμο.
Είναι αρκετά σίγουρο ότι ο άλλος προγραμματιστής δεν θέλει οι `C4` και `C6` να βρίσκονται στο ιστορικό· άλλωστε αυτός είναι ο λόγος για τον οποίο έκανε την επανατοποθέτηση.

[[_rebase_rebase]]
==== Rebase When You Rebase

Αν βρεθούμε σε μια τέτοια κατάσταση, το Git διαθέτει κάποια μαγικά που θα μπορούν να μας βοηθήσουν.
Εάν κάποιος από την ομάδα μας προωθεί αλλαγές που επανεγγράφουν εργασία στην οποία βασίσαμε την δική μας δουλειά, το πρόβλημά μας ανάγετα στο να εντοπίσουμε τι είναι δικό μας και τι έχει ξαναγραφτεί από αυτόν.

Το Git εκτός από το άθροισμα ελέγχου SHA-1 υπολογίζει επίσης ένα άθροισμα ελέγχου που βασίζεται ακριβώς στο μπάλωμα που εισήχθη με την υποβολή.
Αυτό ονομάζεται ``patch-id''.

Αν ανασύρουμε το έργο που ξαναγράφτηκε και το επανατοποθετήσουμε πάνω στις νέες υποβολές του συνεργάτη μας, το Git μπορεί συχνά να καταλάβει ποιες αλλαγές είναι σίγουρα δικές μας και να τις εφαρμόσει ξανά στον νέο κλάδο.

Για παράδειγμα, στο προηγούμενο σενάριο, αν αντί να κάνουμε συγχώνευση όταν βρισκόμαστε στο <<_pre_merge_rebase_work>> τρέξουμε `git rebase teamone/master`, το Git:

* Θα προσδιορίσει ποια δουλειά βρίσκεται μόνον στον κλάδο μας (C2, C3, C4, C6, C7)
* Θα προσδιορίσει ποιες υποβολές δεν είναι δεν είναι υποβολές συγχώνευσης (C2, C3, C4)
* Θα προσδιορίσει ποιες υποβολές δεν έχουν ξαναγραφτεί στον κλάδο στόχο (μόνο οι C2 και C3, δεδομένου ότι η C4 είναι το ίδιο μπάλωμα με την C4 ')
* Θα εφαρμόει αυτές τις υποβολές στον κλάδο `teamone/master`.

Έτσι, αντί για το αποτέλεσμα που βλέπουμε στην <<_merge_rebase_work>>, θα καταλήγαμε σε κάτι που μοιάζει πιο πολύ με την <<_rebase_rebase_work >>.

So instead of the result we see in <<_merge_rebase_work>>, we would end up with something more like <<_rebase_rebase_work>>.

[[_rebase_rebase_work]]
.Επανατοποθέτηση πάνω σε επανατοποθετημένη εργασία
image::images/perils-of-rebasing-5.png[Επανατοποθέτηση πάνω σε επανατοποθετημένη εργασία]
#[[_rebase_rebase_work]]
#Rebase on top of force-pushed rebase work.
#image::images/perils-of-rebasing-5.png[Rebase on top of force-pushed rebase work.]

Αυτό θα έχει το επιθυμητό αποτέλεσμα μόνον εάν οι C4 και C4' που έκανε που ο συνεργάτης μας είναι σχεδόν ακριβώς το ίδιο μπάλωμα.
Διαφορετικά, η επανατοποθέτηση δεν θα είναι σε θέση να καταλάβει ότι πρόκειται για διπλή δουλειά και θα προσθέσει ένα ακόμα μπάλωμα παρόμοιο με το C4 (το οποίο πιθανότατα θα αποτύχει να εφαρμόσει καθαρά, αφού οι αλλαγές θα έχουν τουλάχιστον εν μέρει εφαρμοστεί).

Μπορούμε επίσης να απλοποιήσουμε την διαδικασία τρέχοντας ένα `git pull --rebase` αντί για ένα κανονικό `git pull`.
Ή θα μπορούσαμε να το κάνουμε χειροκίνητα με ένα `git fetch` ακολουθούμενο από ένα `git rebase teamone/master` στην συγκεκριμένη περίπτωση.

Εάν χρησιμοποιούμε το `git pull` και θέλουμε να κάνουμε `--rebase` την προεπιλογή, μπορούμε να ορίσουμε την τιμή του `pull.rebase` με κάτι σαν `git config --global pull.rebase true`.

Εάν αντιμετωπίζουμε την επανατοποθέτηση ως έναν τρόπο για να τακτοποιούμε και να εργαζόμαστε με τις δεσμεύσεις προτού τις προωθήσουμε και αν επανατοποθετούμε μόνον υποβολές που δεν ήταν ποτέ διαθέσιμες δημοσίως, τότε θα είμαστε μια χαρά.
Εάν επανατοποθετούμε υποβολές που έχουν ήδη πρωθηθεί δημοσίως και κάποιοι άλλοι έχουν βασίσει μέρος της εργασίας τους σε αυτές τις υποβολές, τότε μπορεί να αντιμετωπίσουμε προβλήματα που θα μας προκαλέσουν αγανάκτηση και την περιφρόνηση των συνεργατών μας.

Αν αυτό θεωρηθεί απαραίτητο σε κάποιο σημείο, θα πρέπει να βεβαιωθούμε ότι ο καθένας ξέρει να τρέχει το `git pull --rebase` για να προσπαθήσει να καταπραΰνει τον πόνο μετά το συμβάν.


==== Σύγκριση επανατοποθέτησης και συγχώνευσης

(((rebasing, vs. merging)))(((merging, vs. rebasing)))
Τώρα που έχουμε δει την επανατοποθέτηση και την συγχώνευση σε δράση, ίσως να αναρωτιέστε ποια διαδικασία είναι καλύτερη.
Πριν να απαντήσουμε σε αυτό το ερώτημα, ας θυμηθούμε τι ακριβώς είναι το ιστορικό.

Μια θεώρηση του πράγματος είναι ότι το ιστορικό των υποβολών του αποθετηρίου μας είναι *καταγραφή όσων πραγματικά συνέβησαν*.
Είναι ένα ιστορικό έγγραφο, πολύτιμο από μόνο του και δεν πρέπει να παραβιάζεται.
Από αυτήν την σκοπιά, η αλλαγή του ιστορικού των υποβολών αποτελεί σχεδόν βλασφημία. _Ψευδόμαστε_ για το τι πραγματικά συνέβη.
Τι γίνεται, λοιπόν, αν υπάρχει μια μπουρδουκλωμένη σειρά υποβολών συγχώνευσης;
Αυτός είναι ο τρόπος με τον οποίο συνέβησαν και το απουθετήριο πρέπει να το διατηρήσει για πάντα.

Η αντίθετη άποψη είναι ότι η ιστορία της δέσμευσης είναι η *μία αφήγηση του πώς έγινε το έργο μας*.
Δεν θα δημοσιεύαμε το προσχέδιο ενός βιβλίου και το εγχειρίδιο για το πώς θα συντηρήσουμε το λογισμικό μας αξίζει προσεκτική επεξεργασία.
Αυτό είναι το στρατόπεδο που χρησιμοποιεί εργαλεία όπως η επανατοποθέτηση και filter-branch για να αφηγηθεί την ιστορία με τον τρόπο που είναι ο καλύτερος δυνατός για τους μελλοντικούς αναγνώστες.

Τώρα, στο ερώτημα εάν η συγχώνευση ή η επαναδιαπραγμάτευση είναι καλύτερη: ελπίζουμε ότι βλέπετε ότι η απάντηση δεν είναι και τόσο απλή.
Το Git είναι ένα ισχυρό εργαλείο και μας επιτρέπει να κάνουμε πολλά πράγματα στο ιστορικό ή με το ιστορικό αλλά κάθε ομάδα και κάθε έργο είναι διαφορετικά.
Εφόσον γνωρίζουμε πώς λειτουργούν και οι δύο αυτές διαδικασίες, μπορούμε να αποφασίσουμε ποια είναι η καλύτερη σε κάθε περίσταση.

Σε γενικές γραμμές, ο τρόπος να αποκτήσουμε το καλύτερο και από τους δύο κόσμους είναι να αναθεωρήσουμε τις τοπικές αλλαγές που έχουμε κάνει αλλά δεν έχουμε μοιραστεί με άλλους ακόμα, πριν τις προωθήσουμε, προκειμένου να καθαρίσουμε την ιστορία μας αλλά ποτέ να μην επανατοποθετούμε τίποτα που έχουμε προωθήσει κάπου.

