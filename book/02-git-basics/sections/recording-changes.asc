=== Καταχωρώντας αλλαγές στο αποθετήριο

Έχετε λοιπόν ένα ολοκαίνουριο αποθετήριο Git και μια ενημερωμένη έκδοση των αρχείων του έργου.
Η διαδικασία που θα ακολουθήσουμε είναι να κάνουμε μερικές αλλαγές στο έργο και να υποβάλλουμε ένα στιγμιότυπο από αυτές τις αλλαγές στο αποθετήριο κάθε φορά που θέλουμε να καταγράψουμε την εκάστοτε κατάσταση του έργου μας.

Θυμηθείτε ότι κάθε αρχείο στον κατάλογο που δουλεύετε μπορεί να βρίσκεται σε δύο καταστάσεις: εντοπισμένο ή μη εντοπισμένο.
Τα εντοπισμένα αρχεία είναι αυτά που βρίσκονταν στο τελευταίο στιγμιότυπο και μπορούν να είναι τροποποιημένα, ατροποποίητα ή καταχωρημένα.
Τα μη εντοπισμένα αρχεία από την άλλη μπορούν να είναι οτιδήποτε άλλο. Τα αρχεία αυτά μπορούν να είναι οποιοδήποτε αρχεία στον κατάλογο εργασίας σας τα οποία δεν βρίσκονταν στο τελευταίο στιγμιότυπο και ούτε έχουν καταχωρηθεί ακόμα.
Για παράδειγμα, όταν κλωνοποιείτε για πρώτη φορά ένα αποθετήριο, όλα τα αρχεία θα είναι εντοπισμένα και ατροποποίητα καθώς μόλις τα ενημερώσατε και δεν τα έχετε επεξεργαστεί ακόμα.

Καθώς επεξεργάζεστε τα αρχεία, το Git θα τα αναγνωρίζει ως τροποποιημένα καθώς έχουν αλλάξει από την τελευταία φορά που υποβάλλατε κάποια αρχεία.
Τα επόμενα στάδια είναι η καταχώρηση των τροποποιημένων αρχείων και η υποβολή τους, η διαδικασία αυτή θα επαναλαμβάνεται συνέχεια.

.The lifecycle of the status of your files.
image::images/lifecycle.png[The lifecycle of the status of your files.]

[[_checking_status]]
==== Ελέγχοντας την Κατάσταση των Αρχείων σας

Το βασικό εργαλείο που μπορείτε να χρησιμοποιήσετε ώστε να δείτε την τρέχουσα κατάσταση των αρχείων είναι η εντολή `git status`.(((git commands, status)))
Αν εκτελέσετε την εντολή αυτή αμέσως αφού κλωνοποιήσετε ένα αποθετήριο, θα δείτε στην γραμμή εντολών το παρακάτω μήνυμα:

[source,console]
----
$ git status
On branch master
nothing to commit, working directory clean
----

Το μήνυμα αυτό σημαίνει ότι έχετε ένα καθαρό κατάλογο εργασίας. Με άλλα λόγια, δεν υπάρχουν τροποποιημένα ή εντοπισμένα αρχεία.
Επίσης δεν υπάρχουν ούτε μη εντοπισμένα αρχεία αλλιώς το Git θα τα είχε καταγράψει στο παραπάνω μήνυμα.
Επίσης, η εντολή αυτή μας ενημερώνει σε ποιον κλάδο βρισκόμαστε καθώς και ότι δεν έχει αποκλίνει από τον αντίστοιχο κλάδο του διακομιστή.
Προς το παρόν χρησιμοποιούμε τον κύριο κλάδο, ``master'', ο οποίος είναι και ο προεπιλεγμένος.
Θα αναφερθούμε πιο αναλυτικά στους κλάδους στο κεφάλαιο <<_git_branching>>.

Έστω ότι έχουμε προσθέσει ένα νέο αρχείο στο έργο μας, ένα απλό αρχείο README.
Αν το αρχείο αυτό δεν προυπήρχε και εκτελέσουμε την εντολή `git status`, θα δείτε το μη εντοπισμένο αρχείο σας ως εξής:

[source,console]
----
$ echo 'My Project' > README
$ git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)
----

Βλέπουμε λοιπόν ότι το αρχείο README είναι μη εντοπισμένο καθώς βρίσκεται κάτω από την κατηγορία ``Untracked files''.
Ένα μη εντοπισμένο αρχείο ουσιαστικά σημαίνει ότι το Git βλέπει ένα αρχείο το οποίο δεν υπήρχε στο προηγούμενο στιγμιότυπο (την τελευταία φορά που υποβάλλατε αρχεία). Το Git δεν θα συμπεριλάβει το αρχείο αυτό στα επόμενα στιγμιότυπα που θα υποβάλλετε αν δεν το ζητήσετε ρητά.
Αυτό γίνεται ώστε να μην συμπεριλάβετε κατά λάθος στο έργο σας αρχεία τα οποία δεν θέλατε, για παράδειγμα δυαδικά αρχεία.
Στην περίπτωσή μας, θέλουμε να συμπεριλάβουμε το αρχείο README στο έργο μας οπότε πάμε να ενημερώσουμε το Git ώστε να το εντοπίσει.

[[_tracking_files]]
==== Εντοπίζοντας Νέα Αρχεία

Για να εντοπίσει το Git ένα καινούριο αρχείο, χρησιμοποιούμε την εντολή `git add`.(((git commands, add)))
Ξεκινάμε τον εντοπισμό του αρχείου REAMDE με την εντολή:

[source,console]
----
$ git add README
----

Αν τώρα εκτελέσετε την εντολή για να δείτε την τρέχουσα κατάσταση του αποθετηρίου, θα δείτε ότι το αρχείο README είναι πλέον εντοπισμένο και καταχωρημένο ώστε να είναι έτοιμο να υποβληθεί:

[source,console]
----
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

----

Το αρχείο πλέον βρίσκεται κάτω από την κατηγορία ``Changes to be committed'' που σημαίνει ότι είναι καταχωρημένο.
Αν σε αυτό το σημείο κάνετε υποβολή των αρχείων σας, η έκδοση του αρχείου README όταν εκτελέσατε την εντολή `git add` είναι αυτή που θα αποθηκευτεί στο στιγμιότυπο.
Προηγουμένως κάναμε κάτι αντίστοιχο, εκτελέσαμε την εντολή `git init` ακολουθούμενη από `git add (files)`. Με τον τρόπο αυτό ξεκινήσαμε τον εντοπισμό των αρχείων του καταλόγου.(((git commands, init)))(((git commands, add)))
Η εντολή `git add` μπορεί να ακολουθείται είτε από ένα αρχείο είτε από έναν κατάλογο. Αν ακολουθείται από κατάλογο τότε η εντολή θα καταχωρήσει όλα τα αρχεία του συγκεκριμένου καταλόγου αναδρομικά.

==== Καταχωρώντας Τροποποιημένα Αρχεία

Πάμε λοιπόν να τροποποιήσουμε ένα αρχείο το οποίο είναι ήδη εντοπισμένο.
Έστω ότι τροποποιήτε ένα ήδη εντοπισμένο αρχείο, το ``CONTRIBUTING.md'' και εκτελείτε την εντολή `git status` ξανά:

[source,console]
----
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

Το αρχείο ``CONTRIBUTING.md'' βρίσκεται κάτω από την κατηγορία ``Changed but not staged for commit'', που σημαίνει ότι ένα ήδη εντοπισμένο αρχείο έχει τροποποιηθεί στο κατάλογο εργασίας αλλά δεν έχει καταχωρηθεί ακόμα.
Για να το καταχωρήσουμε θα πρέπει να εκτελέσουμε την εντολή `git add`.
Η εντολή `git add` έχει πολλές λειτουργίες: την χρησιμοποιείτε για να ξεκινήσετε τον εντοπισμό καινούριων αρχείων, για να καταχωρήσετε αρχεία αλλά και για άλλες λειτουργίες όπως το να σημειώσετε αρχεία που προέρχονται από συγκρούσεις συγχώνευσης (merge conflicts) ως επιλυμένα.
Μπορείτε να σκεφτείτε την εντολή ως ``πρόσθεσε αυτό το περιεχόμενο σε ό,τι υποβάλλεις την επόμενη φορά'' αντί για ``πρόσθεσε αυτό το αρχείο στο έργο''.(((git commands, add)))
Πάμε λοιπόν να εκτελέσουμε την εντολή `git add` για να καταχωρήσουμε το αρχείο``CONTRIBUTING.md'' και έπειτα να δούμε την τρέχουσα κατάσταση του αποθετηρίου:

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

----

Και τα δύο αρχεία πλέον είναι καταχωρημένα και θα συμπεριληφθούν στην επόμενη υποβολή στιγμιοτύπου.
Στο σημείο αυτό, ας υποθέσουμε ότι θυμάστε μια μικρή αλλαγή που θέλετε να κάνετε στο αρχείο `CONTRIBUTING.md` πριν το υποβάλλετε.
Αφού κάνετε την αλλαγή που θέλετε, είσαστε έτοιμοι για την υποβολή. 
Παρ' όλα αυτά ας εκτελέσουμε `git status` άλλη μια φορά:

[source,console]
----
$ vim CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

Περίεργο ε;
Το αρχείο `CONTRIBUTING.md` αναφέρεται πλέον ως καταχωρημένο αλλά και ως μη καταχωρημένο.
Πως είναι αυτό δυνατόν?
Αυτό που συμβαίνει είναι ότι το Git καταχωρεί ένα αρχείο ακριβώς όπως είναι την στιγμή που εκτελείτε την εντολή `git add`.
Αν υποβάλλετε το στιγμιότυπο τώρα, η έκδοση του αρχείου `CONTRIBUTING.md` που υπήρχε όταν εκτελέσατε την εντολή `git add` είναι αυτή που θα συμπεριληφθεί στην υποβολή (και όχι η τωρινή έκδοση του αρχείου).
Γενικά, αν τροποποιήσετε ένα αρχείο αφότου έχει εκτελέσει την εντολή `git add`, θα πρέπει να την εκτελέσετε ξανά ώστε να καταχωρήσετε την τελευταία έκσοτη του αρχείου:

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
----

==== Σύντομη κατάσταση

Ενώ η εντολή `git status` μας δίνει αρκετά περιεκτική πληροφορία, είναι επίσης και πολύ μακροσκελής.
Στο Git μπορείτε να δείτε και μια πιο σύντομη περιγραφή της κατάστασης του αποθετηρίου.
Αν εκτελέσετε `git status -s` ή `git status --short` θα έχετε ένα πιο απλοποιημένο αποτέλεσμα.

[source,console]
----
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
----

Τα καινούργια αρχεία που δεν έχουν εντοπιστεί ακόμα συμβολίζονται με `??`, τα καινούρια αρχεία που έχουν καταχωρηθεί με `A`, τα τροποποιημένα αρχεία με `M` κ.ο.κ.
Το αποτέλεσμα της εντολής περιλαμβάνει δύο σύμβολα για το κάθε αρχείο. Το αριστερό σύμβολο υποδηλώνει ότι το αρχείο έχει καταχωρηθεί και το δεξί ότι έχει τροποποιηθεί.
Για παράδειγμα, το αρχείο `README` είναι τροποιποιημένο στο κατάλογο εργασίας αλλά δεν έχει καταχωρηθεί ακόμα. Το αρχείο `lib/simplegit.rb` είναι τροποποιημένο και καταχωρημένο.
Το αρχείο `Rakefile` από την άλλη έχει τροποποιηθεί, καταχωρηθεί, και τροποποιηθεί ξανά που σημαίνει ότι υπάρχουν κάποιες αλλαγές που έχουν καταχωρηθεί και κάποιες που δεν έχουν.

[[_ignoring]]
==== Αγνοώντας αρχεία

Είναι συχνό φαινόμενο να υπάρχει μια κατηγορία αρχείων που δεν θέλετε να καταχωρηθούν αυτόματα από το Git αλλά ούτε και να τα βλέπετε ως μη εντοπισμένα.
Συνήθως αυτά είναι αρχεία που δημιουργούνται αυτόματα όπως αρχεία καταγραφής ή αρχεία που δημιουργούνται από τον μεταγλωττιστή.
Σε αυτές τις περιπτώσεις μπορείτε να βρείτε το μοτίβο των ονομάτων των αρχείων που δεν χρειάζεστε και να τα καταχωρήσετε στο αρχείο `.gitignore`.(((ignoring files)))
Ας δούμε ένα παράδειγμα αρχείου `.gitignore`:

[source,console]
----
$ cat .gitignore
*.[oa]
*~
----

Η πρώτη γραμμή ενημερώνει το Git ώστε να αγνοεί όλα τα αρχεία που τελειώνουν σε ``.o'' ή ``.a''.
Η δεύτερη γραμμή ενημερώνει το Git ώστε να αγνοεί όλα τα αρχεία που τελειώνουν με τον χαρακτήρα της ισπανικής περισπωμένης (`~`), το οποίο χρησιμοποιείται από πολλούς επεξεργαστές κειμένου, όπως ο Emacs, για να δηλώσει τα προσωρινά αρχεία.
Μπορείτε επίσεις να συμπεριλάβεται καταλόγους που περιλαμβάνουν αρχεία καταγραφής, προσωρινούς καταλόγους κ.ό.κ.
Γενικά είναι καλή ιδέα να ρυθμίσετε το αρχείο `.gitignore` νωρίς ώστε να μην υποβάλλετε κατά λάθος αρχεία που δεν θέλετε να βρίσκονται στο αποθετήριο.

Οι κανόνες για τα μοτίβα που μπορείτε να δηλώσετε στο αρχείο `.gitignore` είναι οι εξής:

*  Οι κενές γραμμές ή οι γραμμές που ξεκινούν με `#` θα αγνοηθούν.
*  Μπορείτε να χρησιμοποιήσετε τα κλασικά μοτίβα για ονόματα αρχείων (glob patterns).
*  Μπορείτε να ξεκινήσετε τα μοτίβα σας με μια κάθετο (`/`) ώστε να αποφύγετε την αναδρομικότητα
*  Μπορείτε να τελειώσετε τα μοτίβα σας με μια κάθετο (`/`) ώστε να ορίσετε έναν κατάλογο.
*  Μπορείτε να αντιστρέψετε ένα μοτίβο χρησιμοποιώντας ένα θαυμαστικό (`!`) στην αρχή του.

Τα μοτίβα αυτά είναι σαν απλοποιημένες κανονικές εκφράσεις (regular expressions) που χρησιμοποιούν τα λειτουργικά συστήματα.
Ένας αστερίσκος (`*`) αντιστοιχεί σε 0 ή περισσότερους χαρακτήρες. Το `[abc]` αντιστοιχεί σε οποιονδήποτε χαρακτήρα βρίσκεται μέσα στις αγκύλες. Το σύμβολο του αγγλικού ερωτηματικού (`?`) αντιστοιχεί σε έναν και μόνο χαρακτήρα. Αν οι αγκύλες περιέχουν 2 χαρακτήρες που μεταξύ τους χωρίζονται με παύλα (`[0-9]`) τότε αυτή η έκφραση αντιστοιχεί σε όλους τους χαρακτήρες που υπάρχουν μεταξύ των 2 χαρακτήρων (στην περίπτωσή μας, όλοι οι αριθμοί από το 0 μέχρι το 9).
Μπορείτε επίσης να χρησιμοποιήσετε 2 αστερίσκους για να αντιστοιχίσετε εμφωλευμένους καταλόγους: η έκφραση `a/**/z` αντιστοιχεί στους καταλόγους `a/z`, `a/b/z`, `a/b/c/z` κ.ό.κ.

Ας δούμε άλλο ένα παράδειγμα ενός αρχείου .gitignore:

[source]
----
# no .a files
*.a

# but do track lib.a, even though you're ignoring .a files above
!lib.a

# only ignore the TODO file in the current directory, not subdir/TODO
/TODO

# ignore all files in the build/ directory
build/

# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# ignore all .pdf files in the doc/ directory
doc/**/*.pdf
----

[TIP]
====
Αν θέλετε κάποια παραδείγματα για να ξεκινήσετε, το GitHub συντηρεί μια λίστα με παραδείγματαα αρχείων `.gitignore` για πολλές γλώσσες προγραμματισμού στην διεύθυνση https://github.com/github/gitignore[].
====

[[_git_diff_staged]]
==== Βλέποντας τις καταχωρημένες και μη αλλαγές

Αν η εντολή `git status` είναι πολύ αόριστη για εσάς και θέλετε να δείτε ακριβώς τι έχετε αλλάξει (και όχι μόνο ποια αρχεία έχουν αλλάξει), μπορείτε να χρησιμοποιήσετε την εντολή `git diff`.(((git commands, diff)))
Θα καλύψουμε την εντολή αυτή πιο αναλυτικά αργότερα, αλλά θα την χρησιμοποιείτε συχνά για να απαντήσετε σε 2 ερωτήσεις: Τι έχετε αλλάξει και δεν έχετε καταχωρήσει ακόμα;
Και επίσης, τι έχετε καταχωρήσει που είναι έτοιμο για να υποβληθεί;
Ενώ η εντολή `git status` απαντά σε αυτές τις ερωτήσεις πολύ γενικά, απαριθμώντας τα ονόματα των αρχείων, η εντολή `git diff` θα σας δείξει ακριβώς ποιες γραμμές προστέθηκαν ή αφαιρέθηκαν.

Έστω λοιπόν ότι επεξεργάζεστε και καταχωρείτε το αρχείο `README` και μετά επεξεργάζεστε το αρχείο `CONTRIBUTING.md` χωρίς να το καταχωρήσετε.
Αν τώρα εκτελέσετε την εντολή `git status`, θα δείτε κάτι τέτοιο:

[source,console]
----
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Για να δείτε τι έχετε αλλάξει αλλά δεν έχετε καταχωρήσει, πληκτρολογήστε `git diff`:

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

Η εντολή αυτή συγκρίνει τον κατάλογο εργασίας σας με ό,τι υπάρχει στην περιοχή καταχώρησης.
Το αποτέλεσμά της λοιπόν θα περιλαμβάνει τις αλλαγές που έχετε κάνει αλλά δεν έχετε καταχωρήσει ακόμα.

Αν θέλετε να δείτε τι έχετε καταχωρήσει που θα είναι και μέρος της επόμενης υποβολής, μπορείτε να χρησιμοποιήσετε την εντολή `git diff --staged`.
Η εντολή αυτή συγκρίνει τις καταχωρημένες αλλαγές με την τελευταία υποβολή:

[source,console]
----
$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
----

It's important to note that `git diff` by itself doesn't show all changes made since your last commit – only changes that are still unstaged.
This can be confusing, because if you've staged all of your changes, `git diff` will give you no output.

For another example, if you stage the `CONTRIBUTING.md` file and then edit it, you can use `git diff` to see the changes in the file that are staged and the changes that are unstaged.
If our environment looks like this:

[source,console]
----
$ git add CONTRIBUTING.md
$ echo '# test line' >> CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Now you can use `git diff` to see what is still unstaged

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line
----

and `git diff --cached` to see what you've staged so far (--staged and --cached are synonyms):

[source,console]
----
$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

[NOTE]
.Git Diff in an External Tool
====
We will continue to use the `git diff` command in various ways throughout the rest of the book.
There is another way to look at these diffs if you prefer a graphical or external diff viewing program instead.
If you run `git difftool` instead of `git diff`, you can view any of these diffs in software like Araxis, emerge, vimdiff and more.
Run `git difftool --tool-help` to see what is available on your system.
====

[[_committing_changes]]
==== Committing Your Changes

Now that your staging area is set up the way you want it, you can commit your changes.
Remember that anything that is still unstaged – any files you have created or modified that you haven't run `git add` on since you edited them – won't go into this commit.
They will stay as modified files on your disk.
In this case, let's say that the last time you ran `git status`, you saw that everything was staged, so you're ready to commit your changes.(((git commands, status)))
The simplest way to commit is to type `git commit`:(((git commands, commit)))

[source,console]
----
$ git commit
----

Doing so launches your editor of choice.
(This is set by your shell's `$EDITOR` environment variable – usually vim or emacs, although you can configure it with whatever you want using the `git config --global core.editor` command as you saw in <<_getting_started>>).(((editor, changing default)))(((git commands, config)))

The editor displays the following text (this example is a Vim screen):

[source]
----

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C
----

You can see that the default commit message contains the latest output of the `git status` command commented out and one empty line on top.
You can remove these comments and type your commit message, or you can leave them there to help you remember what you're committing.
(For an even more explicit reminder of what you've modified, you can pass the `-v` option to `git commit`.
Doing so also puts the diff of your change in the editor so you can see exactly what changes you're committing.)
When you exit the editor, Git creates your commit with that commit message (with the comments and diff stripped out).

Alternatively, you can type your commit message inline with the `commit` command by specifying it after a -m flag, like this:

[source,console]
----
$ git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
----

Now you've created your first commit!
You can see that the commit has given you some output about itself: which branch you committed to (`master`), what SHA-1 checksum the commit has (`463dc4f`), how many files were changed, and statistics about lines added and removed in the commit.

Remember that the commit records the snapshot you set up in your staging area.
Anything you didn't stage is still sitting there modified; you can do another commit to add it to your history.
Every time you perform a commit, you're recording a snapshot of your project that you can revert to or compare to later.

==== Skipping the Staging Area

(((staging area, skipping)))
Although it can be amazingly useful for crafting commits exactly how you want them, the staging area is sometimes a bit more complex than you need in your workflow.
If you want to skip the staging area, Git provides a simple shortcut.
Adding the `-a` option to the `git commit` command makes Git automatically stage every file that is already tracked before doing the commit, letting you skip the `git add` part:

[source,console]
----
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)
----

Notice how you don't have to run `git add` on the ``CONTRIBUTING.md'' file in this case before you commit.

[[_removing_files]]
==== Removing Files

(((files, removing)))
To remove a file from Git, you have to remove it from your tracked files (more accurately, remove it from your staging area) and then commit.
The `git rm` command does that, and also removes the file from your working directory so you don't see it as an untracked file the next time around.

If you simply remove the file from your working directory, it shows up under the ``Changed but not updated'' (that is, _unstaged_) area of your `git status` output:

[source,console]
----
$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")
----

Then, if you run `git rm`, it stages the file's removal:

[source,console]
----
$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    deleted:    PROJECTS.md
----

The next time you commit, the file will be gone and no longer tracked.
If you modified the file and added it to the index already, you must force the removal with the `-f` option.
This is a safety feature to prevent accidental removal of data that hasn't yet been recorded in a snapshot and that can't be recovered from Git.

Another useful thing you may want to do is to keep the file in your working tree but remove it from your staging area.
In other words, you may want to keep the file on your hard drive but not have Git track it anymore.
This is particularly useful if you forgot to add something to your `.gitignore` file and accidentally staged it, like a large log file or a bunch of `.a` compiled files.
To do this, use the `--cached` option:

[source,console]
----
$ git rm --cached README
----

You can pass files, directories, and file-glob patterns to the `git rm` command.
That means you can do things such as

[source,console]
----
$ git rm log/\*.log
----

Note the backslash (`\`) in front of the `*`.
This is necessary because Git does its own filename expansion in addition to your shell's filename expansion.
This command removes all files that have the `.log` extension in the `log/` directory.
Or, you can do something like this:

[source,console]
----
$ git rm \*~
----

This command removes all files that end with `~`.

[[_git_mv]]
==== Moving Files

(((files, moving)))
Unlike many other VCS systems, Git doesn't explicitly track file movement.
If you rename a file in Git, no metadata is stored in Git that tells it you renamed the file.
However, Git is pretty smart about figuring that out after the fact – we'll deal with detecting file movement a bit later.

Thus it's a bit confusing that Git has a `mv` command.
If you want to rename a file in Git, you can run something like

[source,console]
----
$ git mv file_from file_to
----

and it works fine.
In fact, if you run something like this and look at the status, you'll see that Git considers it a renamed file:

[source,console]
----
$ git mv README.md README
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
----

However, this is equivalent to running something like this:

[source,console]
----
$ mv README.md README
$ git rm README.md
$ git add README
----

Git figures out that it's a rename implicitly, so it doesn't matter if you rename a file that way or with the `mv` command.
The only real difference is that `mv` is one command instead of three – it's a convenience function.
More important, you can use any tool you like to rename a file, and address the add/rm later, before you commit.
