=== Mencatat Perubahan pada Repositori

Pada titik ini, Anda harus memiliki repositori _bona fide_ Git di komputer lokal Anda, dan salinan checkout atau _working dari semua file di depan Anda.
Biasanya, Anda ingin mulai melakukan perubahan dan melakukan snapshot perubahan tersebut ke dalam repositori Anda setiap kali proyek mencapai keadaan yang ingin Anda catat.

Ingat bahwa setiap file dalam direktori kerja Anda bisa berada di salah satu dari dua negara bagian: _tracked_or_untracked_.
File yang dilacak adalah file yang ada di snapshot terakhir; mereka dapat dimodifikasi, dimodifikasi, atau dipentaskan.
Singkatnya, file yang dilacak adalah file yang diketahui Git.

File yang tidak dilacak adalah segalanya - file apa pun di direktori kerja Anda yang tidak ada dalam potret terakhir Anda dan tidak berada di area stage Anda.
Saat pertama kali mengkloning sebuah repositori, semua file Anda akan dilacak dan tidak dimodifikasi karena Git telah memeriksanya dan Anda belum mengedit apapun.

Saat Anda mengedit file, Git melihat mereka sebagai yang dimodifikasi, karena Anda telah mengubahnya sejak komit terakhir Anda.
Saat Anda bekerja, Anda secara selektif memformat file yang dimodifikasi ini dan kemudian melakukan semua perubahan bertahap tersebut, dan siklus berulang.

Siklus hidup dari status file Anda.
image::images/lifecycle.png [Siklus hidup status file Anda.]

[[_checking_status]]
==== Memeriksa Status File Anda

Alat utama yang Anda gunakan untuk menentukan file mana yang statusnya adalah perintah `git status`.((Perintah git, status)))
Jika Anda menjalankan perintah ini langsung setelah kloning, Anda harus melihat sesuatu seperti ini:

[Source, konsol]
----
$ status git
Di cabang master
Cabang Anda sudah mutakhir dengan 'asal / master'.
tidak ada yang harus dilakukan, direktori kerja bersih
----

Ini berarti Anda memiliki direktori kerja yang bersih - dengan kata lain, tidak ada file yang Anda lacak yang dimodifikasi.
Git juga tidak melihat file yang tidak terlacak, atau mereka akan tercantum di sini.
Akhirnya, perintah tersebut memberitahukan cabang mana Anda dan memberitahukan bahwa Anda belum menyimpang dari cabang yang sama di server.
Untuk saat ini, cabang itu selalu ``master'', yang merupakan default; Anda tidak akan khawatir tentang hal ini di sini.
<<ch03-git-branching#ch03-git-branching>> akan membahas cabang dan referensi secara rinci.

Misalkan Anda menambahkan file baru ke proyek Anda, file 'README' sederhana.
Jika file tersebut tidak ada sebelumnya, dan Anda menjalankan `git status`, Anda melihat file yang tidak terlacak seperti ini:

[source,console]
----
$ echo 'My Project' > README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

Tidak ada yang ditambahkan pada komit tapi file yang tidak terlampir hadir (gunakan "git add" untuk dilacak)
----

Anda dapat melihat bahwa file `README` baru Anda tidak terlacak, karena berada di bawah file` Untracked files '' yang menuju output status Anda.
Untracked pada dasarnya berarti Git melihat file yang tidak Anda miliki di snapshot sebelumnya (commit); Git tidak akan mulai memasukkannya ke dalam snapshot komit Anda sampai Anda secara eksplisit memberitahukannya untuk melakukannya.
Hal ini dilakukan agar Anda tidak secara tidak sengaja mulai memasukkan file biner atau file lain yang tidak Anda maksudkan.
Anda ingin mulai memasukkan `README`, jadi mari kita mulai melacak file.

[[_tracking_files]]
==== Melacak File Baru

Untuk mulai melacak file baru, Anda menggunakan perintah `git add`.((Perintah git, tambahkan))
Untuk mulai melacak file `README`, Anda dapat menjalankan ini:

[source,console]
----
$ git add README
----

Jika Anda menjalankan perintah status Anda lagi, Anda dapat melihat file `README` Anda sekarang dilacak dan dipentaskan untuk dilakukan:

[source,console]
----
$ status git
Di cabang master
Cabang Anda sudah mutakhir dengan 'asal / master'.
Perubahan yang harus dilakukan:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

----
Anda dapat mengetahui bahwa itu dipentaskan karena berada di bawah judul "Perubahan yang akan dilakukan".
Jika Anda berkomitmen pada saat ini, versi file pada saat Anda menjalankan `git add` adalah apa yang ada dalam snapshot historis.
Anda mungkin ingat bahwa ketika Anda menjalankan `git init` sebelumnya, Anda kemudian menjalankan` git add <files> `- yaitu mulai melacak file di direktori.(((git commands, init)))(((git commands, add)))

Perintah `git add` mengambil nama path untuk file atau direktori; Jika itu adalah sebuah direktori, perintah tersebut menambahkan semua file dalam direktori itu secara rekursif.

==== Memodifikasi Format File

Mari kita ubah file yang sudah dilacak.
Jika Anda mengubah file yang sebelumnya dilacak yang disebut `CONTRIBUTING.md` dan kemudian jalankan perintah `git status` Anda lagi, Anda akan mendapatkan sesuatu yang terlihat seperti ini:

[source,console]
----
$ git status
Di cabang master
Cabang Anda sudah mutakhir dengan 'asal / master'.
Perubahan yang harus dilakukan:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

File `CONTRIBUTING.md` muncul di bawah bagian yang bernama ``Perubahan yang tidak dipentaskan untuk komit'' - yang berarti bahwa file yang dilacak telah dimodifikasi dalam direktori kerja namun belum dipentaskan.
Untuk tahap itu, Anda menjalankan perintah `git add`.
`git add` adalah perintah serbaguna - Anda menggunakannya untuk mulai melacak file baru, ke file panggung, dan melakukan hal-hal lain seperti menandai file yang berkonflik gabungan seperti yang teratasi.
Mungkin akan sangat membantu untuk menganggapnya lebih sebagai ``menambahkan konten ini ke komit berikutnya'' daripada ``menambahkan file ini ke proyek'' (((perintah git, tambahkan)))
Mari jalankan `git add` sekarang ke stage file `CONTRIBUTING.md`, lalu jalankan `git status` lagi:

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
Di cabang master
Cabang Anda sudah mutakhir dengan 'asal/master'.
Perubahan yang harus dilakukan:
  (use "git reset HEAD <file>..." to unstage)

     file baru: README
     dimodifikasi: CONTRIBUTING.md

----

Kedua file dipentaskan dan akan masuk ke komit berikutnya.
Pada titik ini, misalkan Anda ingat satu perubahan kecil yang ingin Anda buat di `CONTRIBUTING.md` sebelum Anda menghubunginya.
Anda membukanya lagi dan membuat perubahan itu, dan Anda siap untuk melakukan.
Namun, mari kita jalankan `git status` sekali lagi:

[source,console]
----
$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Perubahan tidak dipentaskan untuk komit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    dimodifikasi: CONTRIBUTING.md

----

Apa apaan?
Sekarang `CONTRIBUTING.md` terdaftar sebagai stage _and_ unstaged.
Bagaimana mungkin?
Ternyata Git memprogram sebuah file persis seperti saat Anda menjalankan perintah `git add`.
Jika Anda melakukan sekarang, versi `CONTRIBUTING.md` seperti saat Anda terakhir menjalankan perintah` git add` adalah bagaimana ia akan masuk ke komit, bukan versi file seperti yang terlihat di direktori kerja Anda saat Anda jalankan `git commit`
Jika Anda memodifikasi file setelah menjalankan `git add`, Anda harus menjalankan` git add` lagi untuk tahap versi terbaru file:

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
----

==== Short Status

Sementara output `git status` cukup komprehensif, ini juga cukup bertele-tele.
Git juga memiliki bendera status pendek sehingga Anda bisa melihat perubahan Anda dengan cara yang lebih kompak.
Jika Anda menjalankan `git status -s` atau `git status --short` Anda mendapatkan keluaran yang jauh lebih sederhana dari perintah:

[source,console]
----
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
----

File baru yang tidak dilacak memiliki `?` di sampingnya, file baru yang telah ditambahkan ke area stage memiliki `A`, file yang dimodifikasi memiliki `M` dan sebagainya.
Ada dua kolom pada output - kolom kiri menunjukkan status area pementasan dan kolom sebelah kanan menunjukkan status pohon kerja.
Jadi misalnya pada output itu, file `README` dimodifikasi di direktori kerja tapi belum dipentaskan, sedangkan file` lib / simplegit.rb` telah dimodifikasi dan dipentaskan.
`Rakefile` dimodifikasi, dipentaskan lalu dimodifikasi lagi, jadi ada perubahan pada keduanya yang dipentaskan dan tidak dipersiapkan.

[[_ignoring]]
==== Ignoring Files

Seringkali, Anda akan memiliki kelas file yang Anda tidak ingin Git menambahkan atau bahkan menunjukkan Anda sebagai tidak terlewatkan secara otomatis.
Ini umumnya file yang dibuat secara otomatis seperti file log atau file yang dihasilkan oleh sistem build Anda.
Dalam kasus seperti itu, Anda dapat membuat pola daftar file agar sesuai dengan nama mereka `.gitignore`.((((Mengabaikan file)))
Berikut adalah contoh `.gitignore` file:

[source,console]
----
$ cat .gitignore
*.[oa]
*~
----

The first line tells Git to ignore any files ending in ``.o'' or ``.a'' -- object and archive files that may be the product of building your code.
The second line tells Git to ignore all files whose names end with a tilde (`~`), which is used by many text editors such as Emacs to mark temporary files.
Anda mungkin juga menyertakan direktori log, tmp, atau pid; dokumentasi yang dihasilkan secara otomatis; dan seterusnya.
Menyiapkan file `.gitignore` untuk repositori baru Anda sebelum Anda mulai umumnya adalah ide bagus sehingga Anda tidak sengaja melakukan file yang sebenarnya tidak Anda inginkan dalam gudang Git Anda.

Aturan untuk pola yang dapat Anda masukkan ke dalam file `gitignore` adalah sebagai berikut:

* Garis kosong atau garis yang diawali dengan `#` diabaikan.
* Pola glob standar bekerja, dan akan diterapkan secara rekursif di seluruh keseluruhan pohon kerja.
* Anda bisa memulai pola dengan garis miring (`/`) untuk menghindari rekursifitas.
* Anda bisa mengakhiri pola dengan garis miring (`/`) untuk menentukan direktori.
* Anda bisa meniadakan sebuah pola dengan memulainya dengan tanda seru (`!`).

Glob patterns are like simplified regular expressions that shells use.
An asterisk (`*`) matches zero or more characters; `[abc]` matches any character inside the brackets (in this case a, b, or c); a question mark (`?`) matches a single character; and brackets enclosing characters separated by a hyphen (`[0-9]`) matches any character between them (in this case 0 through 9).
You can also use two asterisks to match nested directories; `a/**/z` would match `a/z`, `a/b/z`, `a/b/c/z`, and so on.

Here is another example `.gitignore` file:

[source]
----
# ignore all .a files
*.a

# but do track lib.a, even though you're ignoring .a files above
!lib.a

# only ignore the TODO file in the current directory, not subdir/TODO
/TODO

# ignore all files in the build/ directory
build/

# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# ignore all .pdf files in the doc/ directory and any of its subdirectories
doc/**/*.pdf
----

[TIP]
====
GitHub mempertahankan daftar file `gitignore` yang cukup lengkap untuk puluhan proyek dan bahasa di https://github.com/github/gitignore [] jika Anda menginginkan titik awal untuk proyek Anda.
====

[CATATAN]
====
Dalam kasus sederhana, repositori mungkin memiliki file `.gitignore` tunggal di dalam direktori root, yang berlaku secara rekursif ke keseluruhan repositori.
Namun, juga memungkinkan untuk memiliki file `.gitignore` tambahan di subdirektori.
Aturan dalam file `gitignore` bersarang ini hanya berlaku untuk file di bawah direktori tempat mereka berada.
(Repositori sumber kernel Linux memiliki file 206 `.gitignore`.)

Tidak jauh dari ruang lingkup buku ini untuk membahas beberapa file `gitignore`; lihat `man gitignore` untuk detailnya.
====

[[_git_diff_staged]]
==== Viewing Your Staged and Unstaged Changes

If the `git status` command is too vague for you -- you want to know exactly what you changed, not just which files were changed -- you can use the `git diff` command.(((git commands, diff)))
We'll cover `git diff` in more detail later, but you'll probably use it most often to answer these two questions: What have you changed but not yet staged?
And what have you staged that you are about to commit?
Although `git status` answers those questions very generally by listing the file names, `git diff` shows you the exact lines added and removed -- the patch, as it were.

Let's say you edit and stage the `README` file again and then edit the `CONTRIBUTING.md` file without staging it.
If you run your `git status` command, you once again see something like this:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

To see what you've changed but not yet staged, type `git diff` with no other arguments:

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

That command compares what is in your working directory with what is in your staging area.
The result tells you the changes you've made that you haven't yet staged.

If you want to see what you've staged that will go into your next commit, you can use `git diff --staged`.
This command compares your staged changes to your last commit:

[source,console]
----
$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
----

It's important to note that `git diff` by itself doesn't show all changes made since your last commit -- only changes that are still unstaged.
If you've staged all of your changes, `git diff` will give you no output.

For another example, if you stage the `CONTRIBUTING.md` file and then edit it, you can use `git diff` to see the changes in the file that are staged and the changes that are unstaged.
If our environment looks like this:

[source,console]
----
$ git add CONTRIBUTING.md
$ echo '# test line' >> CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Now you can use `git diff` to see what is still unstaged:

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line
----

and `git diff --cached` to see what you've staged so far (`--staged` and `--cached` are synonyms):

[source,console]
----
$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

[NOTE]
.Git Diff in an External Tool
====
We will continue to use the `git diff` command in various ways throughout the rest of the book.
There is another way to look at these diffs if you prefer a graphical or external diff viewing program instead.
If you run `git difftool` instead of `git diff`, you can view any of these diffs in software like emerge, vimdiff and many more (including commercial products).
Run `git difftool --tool-help` to see what is available on your system.
====

[[_committing_changes]]
==== Committing Your Changes

Now that your staging area is set up the way you want it, you can commit your changes.
Remember that anything that is still unstaged -- any files you have created or modified that you haven't run `git add` on since you edited them -- won't go into this commit.
They will stay as modified files on your disk.
In this case, let's say that the last time you ran `git status`, you saw that everything was staged, so you're ready to commit your changes.(((git commands, status)))
The simplest way to commit is to type `git commit`:(((git commands, commit)))

[source,console]
----
$ git commit
----

Doing so launches your editor of choice.
(This is set by your shell's `EDITOR` environment variable -- usually vim or emacs, although you can configure it with whatever you want using the `git config --global core.editor` command as you saw in <<ch01-getting-started#ch01-getting-started>>).(((editor, changing default)))(((git commands, config)))

The editor displays the following text (this example is a Vim screen):

[source]
----

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Your branch is up-to-date with 'origin/master'.
#
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C
----

You can see that the default commit message contains the latest output of the `git status` command commented out and one empty line on top.
You can remove these comments and type your commit message, or you can leave them there to help you remember what you're committing.
(For an even more explicit reminder of what you've modified, you can pass the `-v` option to `git commit`.
Doing so also puts the diff of your change in the editor so you can see exactly what changes you're committing.)
When you exit the editor, Git creates your commit with that commit message (with the comments and diff stripped out).

Alternatively, you can type your commit message inline with the `commit` command by specifying it after a `-m` flag, like this:

[source,console]
----
$ git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
----

Now you've created your first commit!
You can see that the commit has given you some output about itself: which branch you committed to (`master`), what SHA-1 checksum the commit has (`463dc4f`), how many files were changed, and statistics about lines added and removed in the commit.

Remember that the commit records the snapshot you set up in your staging area.
Anything you didn't stage is still sitting there modified; you can do another commit to add it to your history.
Every time you perform a commit, you're recording a snapshot of your project that you can revert to or compare to later.

==== Skipping the Staging Area

(((staging area, skipping)))
Although it can be amazingly useful for crafting commits exactly how you want them, the staging area is sometimes a bit more complex than you need in your workflow.
If you want to skip the staging area, Git provides a simple shortcut.
Adding the `-a` option to the `git commit` command makes Git automatically stage every file that is already tracked before doing the commit, letting you skip the `git add` part:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)
----

Notice how you don't have to run `git add` on the `CONTRIBUTING.md` file in this case before you commit.
That's because the `-a` flag includes all changed files.
This is convenient, but be careful; sometimes this flag will cause you to include unwanted changes.

[[_removing_files]]
==== Removing Files

(((files, removing)))
To remove a file from Git, you have to remove it from your tracked files (more accurately, remove it from your staging area) and then commit.
The `git rm` command does that, and also removes the file from your working directory so you don't see it as an untracked file the next time around.

If you simply remove the file from your working directory, it shows up under the ``Changes not staged for commit'' (that is, _unstaged_) area of your `git status` output:

[source,console]
----
$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")
----

Then, if you run `git rm`, it stages the file's removal:

[source,console]
----
$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    deleted:    PROJECTS.md
----

The next time you commit, the file will be gone and no longer tracked.
If you modified the file and added it to the staging area already, you must force the removal with the `-f` option.
This is a safety feature to prevent accidental removal of data that hasn't yet been recorded in a snapshot and that can't be recovered from Git.

Another useful thing you may want to do is to keep the file in your working tree but remove it from your staging area.
In other words, you may want to keep the file on your hard drive but not have Git track it anymore.
This is particularly useful if you forgot to add something to your `.gitignore` file and accidentally staged it, like a large log file or a bunch of `.a` compiled files.
To do this, use the `--cached` option:

[source,console]
----
$ git rm --cached README
----

You can pass files, directories, and file-glob patterns to the `git rm` command.
That means you can do things such as:

[source,console]
----
$ git rm log/\*.log
----

Note the backslash (`\`) in front of the `*`.
This is necessary because Git does its own filename expansion in addition to your shell's filename expansion.
This command removes all files that have the `.log` extension in the `log/` directory.
Or, you can do something like this:

[source,console]
----
$ git rm \*~
----

This command removes all files whose names end with a `~`.

[[_git_mv]]
==== Moving Files

(((files, moving)))
Unlike many other VCS systems, Git doesn't explicitly track file movement.
If you rename a file in Git, no metadata is stored in Git that tells it you renamed the file.
However, Git is pretty smart about figuring that out after the fact -- we'll deal with detecting file movement a bit later.

Thus it's a bit confusing that Git has a `mv` command.
If you want to rename a file in Git, you can run something like:

[source,console]
----
$ git mv file_from file_to
----

and it works fine.
In fact, if you run something like this and look at the status, you'll see that Git considers it a renamed file:

[source,console]
----
$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
----

However, this is equivalent to running something like this:

[source,console]
----
$ mv README.md README
$ git rm README.md
$ git add README
----

Git figures out that it's a rename implicitly, so it doesn't matter if you rename a file that way or with the `mv` command.
The only real difference is that `git mv` is one command instead of three -- it's a convenience function.
More importantly, you can use any tool you like to rename a file, and address the add/rm later, before you commit.
