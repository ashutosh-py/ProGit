[[_git_tools]]
== Git Tools

By now, you’ve learned most of the day-to-day commands and workflows that you need to manage or maintain a Git repository for your source code control.
You’ve accomplished the basic tasks of tracking and committing files, and you’ve harnessed the power of the staging area and lightweight topic branching and merging.

Now you’ll explore a number of very powerful things that Git can do that you may not necessarily use on a day-to-day basis but that you may need at some point.


ΕΝΟΤΗΤΑ 7.1

ΕΝΟΤΗΤΑ 7.2

ΕΝΟΤΗΤΑ 7.3

ΕΝΟΤΗΤΑ 7.4

ΕΝΟΤΗΤΑ 7.5

ΕΝΟΤΗΤΑ 7.6
[[_rewriting_history]]
=== Ιστορικό επανεγγραφής

Πολλές φορές, όταν εργαζόμαστε με το Git, μπορεί να θέλουμε να αναθεωρήσουμε το ιστορικό της δέσμευσής μας για κάποιο λόγο.
Ένα από τα σπουδαία πράγματα για το Git είναι ότι μας επιτρέπει να λαμβάνουμε αποφάσεις την τελευταία δυνατή στιγμή.
Μπορούμε να αποφασίσουμε ποια αρχεία πηγαίνουν στην οποία υποβάλλεται αμέσως προτού υποβάλλουμε με την περιοχή σταδιοποίησης, μπορούμε να αποφασίσουμε ότι δεν εννοούσαμε να εργαζόμαστε σε κάτι ακόμα με την εντολή stash και μπορούμε να ξαναγράψουμε υποβολές που έχουν ήδη συμβεί έτσι ώστε να μοιάζουν συνέβησαν με διαφορετικό τρόπο.
Αυτό μπορεί να συνεπάγεται την αλλαγή της σειράς των υποβολών, την αλλαγή μηνυμάτων ή την τροποποίηση των αρχείων σε μια δέσμευση, τη συμπλοκή ή τη διάσπαση των υποβολών ή την πλήρη κατάργηση των υποβολών - προτού μοιραστούμε τη δουλειά μας με άλλους.

Σε αυτήν την ενότητα, θα καλύψουμε τον τρόπο επίτευξης αυτών των πολύ χρήσιμων εργασιών, ώστε να μπορούμε να κάνουμε την ιστορία των υποβολών μας να μοιάζει με τον τρόπο που θέλουμε πριν να την μοιραστούμε με άλλους.

[[_git_amend]]
==== Αλλαγή της τελευταίας εντολής

Η αλλαγή της τελευταίας μας δέσμευσης είναι πιθανώς η πιο συνηθισμένη επανεγγραφή ιστορικού που θα κάνουμε.
Θα θέλουμε συχνά να κάνουμε δύο βασικά πράγματα στην τελευταία μας δέσμευση: να αλλάξουμε το μήνυμα δέσμευσης ή να αλλάξουμε το στιγμιότυπο που μόλις καταγράψαμε προσθέτοντας, αλλάζοντας και αφαιρώντας αρχεία.

Αν θέλουμε να τροποποιήσουμε μόνο το τελευταίο μας μήνυμα, είναι πολύ απλό:

[πηγή, κονσόλα]
----
$ git commit - amend
----

Αυτό μας φέρνει στον επεξεργαστή κειμένων μας, ο οποίος έχει το τελευταίο μας μήνυμα εμπλοκής σε αυτό, έτοιμο να τροποποιήσουμε το μήνυμα.
Όταν αποθηκεύουμε και κλείνουμε τον επεξεργαστή, ο συντάκτης γράφει μια νέα δέσμευση που περιέχει αυτό το μήνυμα και κάνει τη νέα μας τελευταία δέσμευση.

Αν έχουμε υποβληθεί και στη συνέχεια θέλουμε να αλλάξουμε το στιγμιότυπο που διαπράξαμε προσθέτοντας ή αλλάζοντας αρχεία, πιθανώς επειδή ξεχάσαμε να προσθέσουμε ένα νεοδημιουργημένο αρχείο όταν αρχικά υποβάλατε, η διαδικασία λειτουργεί βασικά με τον ίδιο τρόπο.
Μπορούμε να επεξεργαστούμε τις αλλαγές που θέλουμε, επεξεργάζοντας ένα αρχείο και τρέχοντας το `git add` σε αυτό ή` git rm` σε ένα κομμάτι που παρακολουθείται και το επόμενο `git commit --amend` παίρνει την τρέχουσα περιοχή σταδιοδρομίας μας και το κάνει το στιγμιότυπο για νέα δέσμευση.

Πρέπει να είστε προσεκτικοί με αυτήν την τεχνική επειδή η τροποποίηση τροποποιεί το SHA-1 της δέσμευσης.
Είναι σαν ένα πολύ μικρό rebase - μην τροποποιήσουμε την τελευταία μας δέσμευση εάν το έχουμε ήδη ωθήσει.

[[_changing_multiple]]
==== Αλλαγή μηνυμάτων πολλαπλών εντολών

Για να τροποποιήσουμε μια δέσμευση που είναι πιο πίσω στο ιστορικό μας, πρέπει να μεταβούμε σε πιο πολύπλοκα εργαλεία.
Το Git δεν διαθέτει ένα εργαλείο τροποποίησης-ιστορικού, αλλά μπορούμε να χρησιμοποιήσουμε το εργαλείο επανακαθορισμού για να επαναπροσδιορίσουμε μια σειρά υποβολών στο HEAD στο οποίο είχαν αρχικά βασιστεί αντί να τις μετακινήσουμε σε άλλο.
Με το εργαλείο interactive rebase, μπορούμε στη συνέχεια να σταματήσουμε μετά από κάθε δέσμευση που θέλουμε να τροποποιήσουμε και να αλλάξουμε το μήνυμα, να προσθέσουμε αρχεία ή να κάνουμε ό, τι επιθυμούμε.
Μπορούμε να εκτελέσουμε το rebase διαδραστικά προσθέτοντας την επιλογή `-i` στο` git rebase`.
Πρέπει να υποδείξουμε πόσο μακριά θέλουμε να ξαναγράψουμε τις υποβολές λέγοντας την εντολή που υποβάλλεται να επαναπροσδιορίσει.

Για παράδειγμα, εάν θέλουμε να αλλάξουμε τα τελευταία τρία μηνύματα δέσμευσης ή κάποιο από τα μηνύματα δέσμευσης σε αυτήν την ομάδα, παρέχουμε ως όρισμα το `git rebase -i` τον γονέα της τελευταίας δέσμευσης που θέλουμε να επεξεργαστούμε, το οποίο είναι` HEAD ~ 2 ^ `ή` HEAD ~ 3`.
Μπορεί να είναι πιο εύκολο να θυμηθούμε το `~ 3` επειδή προσπαθούμε να επεξεργαστούμε τις τελευταίες τρεις υποβολές. αλλά να θυμάστε ότι ο ίδιος ορίζει τέσσερις δεσμούς πριν, ο γονέας της τελευταίας δέσμευσης που θέλουμε να επεξεργαστούμε:

[πηγή, κονσόλα]
----
$ git rebase -i HEAD ~ 3
----

Θυμηθούμε ξανά ότι αυτή είναι μια εντολή επανεκκίνησης - κάθε δέσμευση που περιλαμβάνεται στη σειρά `HEAD ~ 3..HEAD` θα ξαναγραφεί, είτε αλλάζουμε το μήνυμα είτε όχι.
Μην συμπεριλάβουμε οποιαδήποτε δέσμευση έχουμε ήδη σπρώξει σε κεντρικό εξυπηρετητή - αυτό θα προκαλέσει σύγχυση σε άλλους προγραμματιστές παρέχοντας μια εναλλακτική έκδοση της ίδιας αλλαγής.

Η εκτέλεση αυτής της εντολής μάς δίνει μια λίστα υποβολών στον επεξεργαστή κειμένου μας που μοιάζει με αυτό:

[πηγή, κονσόλα]
----
pick f7f3f6d άλλαξε λίγο το όνομά μου
επιλέξτε 310154e ενημερωμένη μορφοποίηση README και προσθέστε φταίξιμο
επιλέξτε a5f4a0d πρόσθεσε cat-αρχείο

# Rebase 710f0f8..a5f4a0d επάνω 710f0f8
# #
# Εντολές:
# p, pick = χρήση commit
# r, reword = Χρήση commit, αλλά επεξεργαστούμε το μήνυμα commit
# e, edit = use commit, αλλά σταματήστε να τροποποιήσετε
# s, squash = χρήση commit, αλλά συγχώνευση σε προηγούμενη commit
# f, fixup = όπως "squash", αλλά απορρίψτε το μήνυμα καταγραφής αυτής της δέσμευσης
# x, exec = εκτέλεση εντολής (το υπόλοιπο της γραμμής) χρησιμοποιώντας shell
# #
# Αυτές οι γραμμές μπορούν να παραγγελθούν εκ νέου. εκτελούνται από πάνω προς τα κάτω.
# #
# Εάν αφαιρέσουμε μια γραμμή εδώ, ΟΠΟΙΟΣ ΔΕΝ ΕΙΝΑΙ ΑΠΩΛΕΙΑ.
# #
# Ωστόσο, αν αφαιρέσουμε τα πάντα, η αναβολή θα ακυρωθεί.
# #
# Σημειώστε ότι οι κενές υποβολές σχολιάζονται
----

Είναι σημαντικό να σημειώσουμε ότι αυτές οι υποβολές παρατίθενται με την αντίθετη σειρά από αυτές που συνήθως βλέπουμε χρησιμοποιώντας την εντολή `log`.
Αν εκτελέσουμε ένα `log ', θα δούμε κάτι σαν αυτό:

[πηγή, κονσόλα]
----
$ git log --pretty = μορφή: "% h% s" HEAD ~ 3..HEAD
Το a5f4a0d πρόσθεσε αρχεία γάτας
310154e ενημέρωση της μορφοποίησης README και προστιθέμενη ευθύνη
Το f7f3f6d άλλαξε λίγο το όνομά μου
----

Παρατηρήστε την αντίστροφη σειρά.

Το interactive rebase μάς δίνει ένα σενάριο που θα τρέξει.
Θα ξεκινήσει από τη δέσμευση που καθορίσαμε στη γραμμή εντολών (`HEAD ~ 3`) και θα επαναλάβει τις αλλαγές που εισήχθησαν σε κάθε μία από αυτές τις υποβολές από πάνω προς τα κάτω.
Εμφανίζει το παλαιότερο στην κορυφή, αντί για το νεότερο, επειδή είναι το πρώτο που θα επαναλάβει.

Πρέπει να επεξεργαστούμε το σενάριο έτσι ώστε να σταματήσει στη διαδικασία που θέλουμε να επεξεργαστούμε.
Για να το κάνουμε αυτό, αλλάξτε τη λέξη `pick 'στη λέξη' edit 'για κάθε μία από τις υποβολές που θέλουμε να σταματήσει η δέσμη ενεργειών.
Για παράδειγμα, για να τροποποιήσουμε μόνο το τρίτο μήνυμα δέσμευσης, αλλάζουμε το αρχείο έτσι ώστε να φαίνεται ως εξής:

[πηγή, κονσόλα]
----
επεξεργασία f7f3f6d άλλαξε λίγο το όνομά μου
επιλέξτε 310154e ενημερωμένη μορφοποίηση README και προσθέστε φταίξιμο
επιλέξτε a5f4a0d πρόσθεσε cat-αρχείο
----

Όταν αποθηκεύουμε και κλείνουμε τον επεξεργαστή, το Git μάς επιστρέφει πίσω στην τελευταία δέσμευση της λίστας και μας ρίχνει στη γραμμή εντολών με το ακόλουθο μήνυμα:

[πηγή, κονσόλα]
----
$ git rebase -i HEAD ~ 3
Σταμάτησα στο f7f3f6d ... άλλαξε λίγο το όνομά μου
Μπορούμε να τροποποιήσουμε την δέσμευση τώρα, με

       git commit - amend

Μόλις είστε ικανοποιημένοι με τις αλλαγές μας, εκτελέστε

       git rebase - συνεχίστε
----

Αυτές οι οδηγίες μάς λένε ακριβώς τι να κάνουμε.
Τύπος

[πηγή, κονσόλα]
----
$ git commit - amend
----

Αλλαγή του μηνύματος αποστολής και έξοδος από τον επεξεργαστή.
Τότε τρέξε

[πηγή, κονσόλα]
----
$ git rebase - συνεχίστε
----

Αυτή η εντολή θα εφαρμόσει αυτόματα τις άλλες δύο υποβολές και στη συνέχεια τελειώσατε.
Εάν αλλάξουμε την επιλογή για επεξεργασία σε περισσότερες γραμμές, μπορούμε να επαναλάβουμε αυτά τα βήματα για κάθε δέσμευση που αλλάζουμε για επεξεργασία.
Κάθε φορά, ο Git θα σταματήσει, θα μας επιτρέψει να τροποποιήσουμε τη δέσμευση και να συνεχίσουμε όταν τελειώσουμε.

==== Αναταξινόμηση υποβολών

Μπορούμε επίσης να χρησιμοποιήσουμε διαδραστικές αναβαθμίσεις για να αναδιατάξουμε ή να αφαιρέσουμε πλήρως τις υποβολές.
Εάν θέλουμε να αφαιρέσουμε το `` add cat-file '' και να αλλάξουμε τη σειρά με την οποία εισάγονται οι άλλες δύο υποβολές, μπορούμε να αλλάξουμε το σενάριο rebase από αυτό

[πηγή, κονσόλα]
----
pick f7f3f6d άλλαξε λίγο το όνομά μου
επιλέξτε 310154e ενημερωμένη μορφοποίηση README και προσθέστε φταίξιμο
επιλέξτε a5f4a0d πρόσθεσε cat-αρχείο
----

σ 'αυτό:


[πηγή, κονσόλα]
----
επιλέξτε 310154e ενημερωμένη μορφοποίηση README και προσθέστε φταίξιμο
pick f7f3f6d άλλαξε λίγο το όνομά μου
----

Όταν αποθηκεύουμε και εξερχόμαστε από τον επεξεργαστή, το Git επιστρέφει τον κλάδο μας στο γονικό των υποβολών αυτών, εφαρμόζει `310154e` και στη συνέχεια` f7f3f6d` και στη συνέχεια σταματά.
Μπορούμε να αλλάξουμε αποτελεσματικά τη σειρά αυτών των υποβολών και να αφαιρέσουμε πλήρως το `` add cat-file ''.

[[_squashing]]
==== Συγχαρητήρια υποβολές

Είναι επίσης δυνατή η ανάληψη μιας σειράς υποβολών και η κατάρριψή τους σε μια ενιαία δέσμευση με το εργαλείο διαδραστικής αναπροσαρμογής.
Η δέσμη ενεργειών παρέχει χρήσιμες οδηγίες στο μήνυμα επαναγοράς:

[πηγή, κονσόλα]
----
# #
# Εντολές:
# p, pick = χρήση commit
# r, reword = Χρήση commit, αλλά επεξεργαστούμε το μήνυμα commit
# e, edit = use commit, αλλά σταματήστε να τροποποιήσετε
# s, squash = χρήση commit, αλλά συγχώνευση σε προηγούμενη commit
# f, fixup = όπως "squash", αλλά απορρίψτε το μήνυμα καταγραφής αυτής της δέσμευσης
# x, exec = εκτέλεση εντολής (το υπόλοιπο της γραμμής) χρησιμοποιώντας shell
# #
# Αυτές οι γραμμές μπορούν να παραγγελθούν εκ νέου. εκτελούνται από πάνω προς τα κάτω.
# #
# Εάν αφαιρέσουμε μια γραμμή εδώ, ΟΠΟΙΟΣ ΔΕΝ ΕΙΝΑΙ ΑΠΩΛΕΙΑ.
# #
# Ωστόσο, αν αφαιρέσουμε τα πάντα, η αναβολή θα ακυρωθεί.
# #
# Σημειώστε ότι οι κενές υποβολές σχολιάζονται
----

Εάν, αντί για `` pick '' ή `` edit '', καθορίσουμε `` squash '', το Git εφαρμόζει τόσο την αλλαγή όσο και την αλλαγή απευθείας ενώπιον του και μας κάνει να συγχωνεύσουμε τα μηνύματα commit.
Επομένως, εάν θέλουμε να πραγματοποιήσουμε μια μόνο δέσμευση από αυτές τις τρεις υποβολές, θα κάνουμε το σενάριο να μοιάζει με αυτό:

[πηγή, κονσόλα]
----
pick f7f3f6d άλλαξε λίγο το όνομά μου
squash 310154e ενημέρωση της μορφοποίησης του README και προστιθέμενη ευθύνη
squash a5f4a0d πρόσθεσε cat-αρχείο
----

Όταν αποθηκεύουμε και κλείνουμε τον επεξεργαστή, το Git εφαρμόζει και τις τρεις αλλαγές και στη συνέχεια μας επαναφέρει στον επεξεργαστή για να συγχωνεύσουμε τα τρία μηνύματα commit:

[πηγή, κονσόλα]
----
# Αυτός είναι ένας συνδυασμός 3 υποβολών.
# Το μήνυμα της πρώτης ανάληψης είναι:
άλλαξε λίγο το όνομά μου

# Αυτό είναι το δεύτερο μήνυμα δέσμευσης:

ενημερωμένη μορφοποίηση του README και προστιθέμενη ευθύνη

# Αυτό είναι το 3ο μήνυμα αποστολής:

προστιθέμενο αρχείο γάτας
----

Όταν το αποθηκεύσουμε αυτό, έχουμε μία μόνο δέσμευση που εισάγει τις αλλαγές και των τριών προηγούμενων υποβολών.

==== Διαίρεση μιας δέσμευσης

Ο διαχωρισμός μιας δέσμευσης αναστέλλει μια δέσμευση και στη συνέχεια μερικά στάδια και υποβάλλει όσες φορές υποβάλλει με την οποία θέλουμε να καταλήξουμε.
Για παράδειγμα, ας υποθέσουμε ότι θέλουμε να χωρίσουμε τη μεσαία δέσμευση των τριών υποβολών μας.
Αντί της `` ενημερωμένης μορφοποίησης README και προστιθέμενης φταίει '', θέλουμε να την χωρίσουμε σε δύο υποβολές: `` ενημερωμένη μορφοποίηση README '' για την πρώτη και `` add blame '' για τη δεύτερη.
Μπορούμε να το κάνουμε αυτό στο σενάριο `rebase -i` αλλάζοντας την εντολή για τη δέσμευση που θέλουμε να χωρίσουμε στο` `edit '':

[πηγή, κονσόλα]
----
pick f7f3f6d άλλαξε λίγο το όνομά μου
επεξεργασία 310154e ενημερωμένη μορφοποίηση README και πρόσθετη ευθύνη
επιλέξτε a5f4a0d πρόσθεσε cat-αρχείο
----

Στη συνέχεια, όταν το σενάριο σάς βγάζει στη γραμμή εντολών, επαναφέρουμε αυτήν τη δέσμευση, λάβουμε τις αλλαγές που έχουν επαναφερθεί και δημιουργήσουμε πολλαπλές υποβολές από αυτές.
Όταν αποθηκεύουμε και εξερχόμαστε από  τον επεξεργαστή, το Git επιστρέφει στον γονέα της πρώτης δέσμευσης στη λίστα μας, εφαρμόζει την πρώτη δέσμευση (`f7f3f6d`), εφαρμόζει το δεύτερο (` 310154e`) και μας φέρνει στην κονσόλα.
Εκεί, μπορούμε να εκτελέσουμε μια μεικτή επαναφορά αυτής της δέσμευσης με το `git reset HEAD ^`, το οποίο ακυρώνει αποτελεσματικά αυτό το commit και αφήνει τα τροποποιημένα αρχεία unstaged.
Τώρα μπορούμε να οργανώσουμε και να υποβάλλουμε αρχεία μέχρι να έχουμε αρκετές υποβολές και τρέξτε το `git rebase --continue` όταν τελειώσετε:

[πηγή, κονσόλα]
----
$ git reset HEAD ^
$ git προσθέστε README
$ git commit -m 'ενημερωμένη μορφοποίηση README'
$ git προσθέστε lib / simplegit.rb
$ git commit -m 'πρόσθεσε φταίει'
$ git rebase - συνεχίστε
----

Το Git εφαρμόζει την τελευταία δέσμευση (`a5f4a0d`) στο σενάριο και το ιστορικό μας μοιάζει με αυτό:

[πηγή, κονσόλα]
----
$ git log -4 - πρότυπο = μορφή: "% h% s"
1c002dd πρόσθεσε αρχεία γάτας
9b29157 προστέθηκε ευθύνη
35cfb2b ενημερωμένη μορφοποίηση του αρχείου README
Το f3cc40e άλλαξε λίγο το όνομά μου
----

Για άλλη μια φορά, αυτό αλλάζει τα SHA-1s όλων των υποβολών στη λίστα μας, οπότε βεβαιωθούμε ότι δεν εμφανίζεται καμία δέσμευση σε αυτήν τη λίστα που έχουμε ήδη σπρώξει σε ένα κοινόχρηστο αποθετήριο.

==== Η επιλογή πυρηνικών: `filter-branch`

Υπάρχει μια άλλη επιλογή επανεγγραφής ιστορικού που μπορούμε να χρησιμοποιήσουμε αν χρειάζεται να ξαναγράψουμε έναν μεγαλύτερο αριθμό υποβολών με κάποιο τρόπο με δυνατότητα γραφής - για παράδειγμα, αλλάζοντας τη διεύθυνση ηλεκτρονικού ταχυδρομείου μας σε παγκόσμιο επίπεδο ή αφαιρώντας ένα αρχείο από κάθε δέσμευση.
Η εντολή είναι `filter-branch` και μπορεί να ξαναγράψει τεράστιες λεπτομέρειες της ιστορίας μας, επομένως πιθανώς να μην το χρησιμοποιήσουμε, εκτός εάν το σχέδιό μας δεν είναι ακόμη δημόσια και άλλοι άνθρωποι δεν έχουν βασίσει τις εργασίες από τις υποβολές για τις οποίες είστε να ξαναγράψει.
Ωστόσο, μπορεί να είναι πολύ χρήσιμο.
Θα μάθουμε μερικές από τις κοινές χρήσεις, ώστε να μπορούμε να πάρουμε μια ιδέα για κάποια από τα πράγματα που είναι σε θέση.

[[_removing_file_every_commit]]
===== Αφαίρεση ενός αρχείου από κάθε δέσμευση

Αυτό συμβαίνει αρκετά συχνά.
Κάποιος αναγκαστικά διαπράττει ένα τεράστιο δυαδικό αρχείο με ένα άσκοπο `git add ', και θέλουμε να το αφαιρέσουμε παντού.
Ίσως κάναμε λάθος ένα αρχείο που περιείχε κωδικό πρόσβασης και θέλουμε να κάνουμε το έργο μας ανοιχτό.
`filter-branch` είναι το εργαλείο που θέλουμε να χρησιμοποιήσουμε για να καθαρίσουμε ολόκληρο το ιστορικό μας.
Για να καταργήσουμε ένα αρχείο που ονομάζεται passwords.txt από ολόκληρο το ιστορικό μας, μπορούμε να χρησιμοποιήσουμε την επιλογή `--tree-filter 'σε` filter-branch`:

[πηγή, κονσόλα]
----
$ git-φίλτρο-κλάδο -tree-φίλτρο "rm -f passwords.txt" HEAD
Επανασυνδέστε 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Οι αναφορές 'refs / heads / master' επαναδιατυπώθηκαν
----

Η επιλογή `--tree-filter 'εκτελεί την εντολή που έχει οριστεί μετά από κάθε ολοκλήρωση του έργου και κατόπιν επαναφέρει τα αποτελέσματα.
Σε αυτήν την περίπτωση, καταργούμε ένα αρχείο που ονομάζεται passwords.txt από κάθε στιγμιότυπο, είτε υπάρχει είτε όχι.
Αν θέλουμε να καταργήσουμε όλα τα αρχεία backup του προγράμματος επεξεργασίας, έχουμε τη δυνατότητα να εκτελέσουμε κάτι σαν το `git filter-branch -tree-filter 'rm -f * ~' HEAD`.

Θα είστε σε θέση να παρακολουθήσουμε Git ξαναγράφοντας δέντρα και υποβολές και στη συνέχεια να μετακινήσουμε τον δείκτη του κλάδου στο τέλος.
Είναι γενικά μια καλή ιδέα να το κάνουμε αυτό σε έναν κλάδο δοκιμών και στη συνέχεια να επαναφέρουμε σκληρά τον κύριο κλάδο αφού έχουμε καθορίσει το αποτέλεσμα είναι αυτό που πραγματικά θέλουμε.
Για να εκτελέσουμε το `filter-branch` σε όλους τους κλάδους μας, μπορούμε να περάσετε` --all` στην εντολή.

===== Κάνοντας έναν υποκατάλογο τη νέα ρίζα

Ας υποθέσουμε ότι έχουμε πραγματοποιήσει εισαγωγή από άλλο σύστημα ελέγχου πηγής και έχουμε υποκαταλόγους που δεν έχουν νόημα (κορμός, ετικέτες κ.ο.κ.).
Αν θέλουμε ο υποκατάλογος `trunk` να είναι ο νέος ρίζας του έργου για κάθε δέσμευση, το` filter-branch` μπορεί επίσης να μας βοηθήσει:

[πηγή, κονσόλα]
----
$ git φίλτρο-κλάδο -subdirectory-φίλτρο κορμό HEAD
Επαναφορά 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Οι αναφορές 'refs / heads / master' επαναδιατυπώθηκαν
----

Τώρα, η νέα μας ρίζα έργου είναι αυτή που ήταν στον υποκατάλογο `trunk` κάθε φορά.
Το Git θα καταργήσει επίσης αυτόματα υποβολές που δεν επηρέασαν τον υποκατάλογο.

===== Αλλαγή διευθύνσεων ηλεκτρονικού ταχυδρομείου παγκοσμίως

Μια άλλη συνηθισμένη περίπτωση είναι ότι ξεχάσαμε να εκτελέσουμε το `git config` για να ορίσουμε το όνομα και τη διεύθυνση ηλεκτρονικού ταχυδρομείου πριν αρχίσουμε να εργαζόμαστε ή ίσως θέλουμε να ανοίξουμε ένα έργο στο χώρο εργασίας και να αλλάξουμε όλες τις διευθύνσεις ηλεκτρονικού ταχυδρομείου εργασίας μας προσωπική διεύθυνση.
Σε κάθε περίπτωση, μπορούμε να αλλάξουμε τις διευθύνσεις ηλεκτρονικού ταχυδρομείου σε πολλαπλές υποβολές σε μια παρτίδα με `filter-branch` επίσης.
Πρέπει να είστε προσεκτικοί για να αλλάξουμε μόνο τις διευθύνσεις ηλεκτρονικού ταχυδρομείου που είναι δικές μας, γι 'αυτό χρησιμοποιήστε το `--commit-filter':

[πηγή, κονσόλα]
----
$ git filter-branch -commit-filter '
        αν ["$ GIT_AUTHOR_EMAIL" = "schacon @ localhost"];
        έπειτα
                GIT_AUTHOR_NAME = "Scott Chacon";
                GIT_AUTHOR_EMAIL = "schacon@example.com";
                git δέσμευση-δέντρο "$ @";
        αλλού
                git δέσμευση-δέντρο "$ @";
        fi 'HEAD
----

Αυτό περνάει και ξαναγράφει κάθε δέσμευση για τη νέα μας διεύθυνση.
Επειδή οι υποβολές περιέχουν τις τιμές SHA-1 των γονέων τους, αυτή η εντολή αλλάζει κάθε commit SHA-1 στο ιστορικό μας, όχι μόνο εκείνες που έχουν την αντίστοιχη διεύθυνση ηλεκτρονικού ταχυδρομείου.












ΕΝΟΤΗΤΑ 7.7
[[_git_reset]]
=== Επαναφορά απομυθοποιημένων

Πριν προχωρήσουμε σε πιο εξειδικευμένα εργαλεία, ας μιλήσουμε για το 'reset' και 'checkout'.
Αυτές οι εντολές είναι δύο από τα πιο συγκεχυμένα μέρη του Git όταν τα συναντάς για πρώτη φορά.
Κάνουν τόσα πολλά πράγματα, που φαίνεται απελπισμένα να τα κατανοήσουν και να τα χρησιμοποιήσουν σωστά.
Γι 'αυτό, συνιστούμε μια απλή μεταφορά.

==== Τα τρία δέντρα

Ένας ευκολότερος τρόπος για να σκεφτείς για το «reset» και «checkout» είναι μέσω του πνευματικού πλαισίου του Git που είναι διαχειριστής περιεχομένου τριών διαφορετικών δέντρων.
Με το `` tree '' εδώ εννοούμε πραγματικά `` collection of files '', όχι ειδικά τη δομή δεδομένων.
(Υπάρχουν μερικές περιπτώσεις όπου ο δείκτης δεν λειτουργεί ακριβώς όπως ένα δέντρο, αλλά για τους σκοπούς μας είναι ευκολότερο να το σκεφτούμε αυτό τον τρόπο για τώρα.)

Git, καθώς το σύστημα διαχειρίζεται και χειρίζεται τρία δέντρα στην κανονική του λειτουργία:

[cols = "1,2", επιλογές = "κεφαλίδα"]
| ================================
| Δέντρο | Ρόλος
| HEAD | Τελευταίο στιγμιότυπο δέσμευσης, επόμενος γονέας
| Ευρετήριο | Προτεινόμενο επόμενο στιγμιότυπο δέσμευσης
| Κατάλογος εργασίας | Sandbox
| ================================

===== Η κεφαλή

Ο HEAD είναι ο δείκτης στην τρέχουσα αναφορά κλάδου, ο οποίος με τη σειρά του είναι ένας δείκτης μέχρι την τελευταία δέσμευση που έγινε σε αυτόν τον κλάδο.
Αυτό σημαίνει ότι το HEAD θα είναι το γονέα της επόμενης δέσμευσης που δημιουργείται.
Είναι γενικά απλούστερο να σκεφτόμαστε το HEAD ως το στιγμιότυπο * της τελευταίας μας δέσμευσης *.

Στην πραγματικότητα, είναι αρκετά εύκολο να δούμε τι φαίνεται αυτό το στιγμιότυπο.
Ακολουθεί ένα παράδειγμα λήψης της πραγματικής λίστας καταλόγων και των αθροισμάτων ελέγχου SHA-1 για κάθε αρχείο στο στιγμιότυπο HEAD:

[πηγή, κονσόλα]
----
$ git cat-file -p HEAD
δέντρο cfda3bf379e4f8dba8717dee55aab78aef7f4daf
συγγραφέας Scott Chacon 1301511835 -0700
σκηνοθεσία Scott Chacon 1301511835 -0700

αρχική δέσμευση

$ git ls-δέντρο -r HEAD
100644 μπλοκ a906cb2a4a904a152 ... README
100644 blob 8f94139338f9404f2 ... Rakefile
040000 δέντρο 99f1a6d12cb4b6f19 ... lib
----

Οι εντολές "cat-file" και "ls-tree" είναι εντολές "υδραυλικών" που χρησιμοποιούνται για πράγματα χαμηλότερου επιπέδου και δεν χρησιμοποιούνται πραγματικά στην καθημερινή εργασία, αλλά μας βοηθούν να δούμε τι συμβαίνει εδώ.

[[_εξέταση]]
===== Ο Δείκτης

Ο Δείκτης είναι * σας προτείνεται επόμενη commit *.
Έχουμε επίσης αναφερθεί σε αυτήν την έννοια ως `` Staging Area '' του Git, καθώς αυτό εξετάζει το Git όταν τρέχουμε το `git commit '.

Το Git γεμίζει αυτό το ευρετήριο με μια λίστα με όλα τα περιεχόμενα του αρχείου που έχουν ελεγχθεί τελευταία στον κατάλογο εργασίας μας και με αυτά που έμοιαζαν όταν είχαν ελεγχθεί αρχικά.
Στη συνέχεια, αντικαθιστάμε μερικά από αυτά τα αρχεία με νέες εκδόσεις τους και το `git commit 'μετατρέπει αυτό στο δέντρο για μια νέα δέσμευση.

[πηγή, κονσόλα]
----
$ git ls-αρχεία -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0 README
100644 8f94139338f9404f26296befa88755fc2598c289 0 Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0 lib / simplegit.rb
----

Και πάλι, εδώ χρησιμοποιούμε τα `ls-files ', τα οποία είναι περισσότερο από μια εντολή πίσω από τις σκηνές που μας δείχνει τι δείχνει το δείκτη μας.

Ο δείκτης δεν είναι τεχνικά δομή δέντρου - είναι στην πραγματικότητα υλοποιηθεί ως πεπλατυσμένο δηλωτικό - αλλά για τους σκοπούς μας είναι αρκετά κοντά.

===== Ο κατάλογος εργασίας

Τέλος, έχουμε τον κατάλογο εργασίας μας.
Τα άλλα δύο δέντρα αποθηκεύουν το περιεχόμενό τους με έναν αποτελεσματικό αλλά ενοχλητικό τρόπο, μέσα στον φάκελο `.git`.
Ο κατάλογος εργασίας τους αποσυμπιέζει σε πραγματικά αρχεία, πράγμα που καθιστά πολύ πιο εύκολο για μας να τα επεξεργαστούμε.
Σκεφτούμε τον κατάλογο εργασίας ως * sandbox *, όπου μπορούμε να δοκιμάσουμε τις αλλαγές πριν να τους υποβάλλουμε στην περιοχή αναμονής (index) και στη συνέχεια στο ιστορικό.

[πηγή, κονσόλα]
----
$ tree
.
├── README
├ Rakefile
└── lib
    └── simplegit.rb

1 κατάλογο, 3 αρχεία
----

==== Η ροή εργασίας

Ο κύριος σκοπός του Git είναι να καταγράφει στιγμιότυπα του έργου μας σε διαδοχικά καλύτερα κράτη, χειριζόμενος αυτά τα τρία δέντρα.

εικόνα :: images / reset-workflow.png []

Ας παρουσιάσουμε αυτή τη διαδικασία: πούμε ότι πηγαίνουμε σε ένα νέο κατάλογο με ένα μόνο αρχείο σε αυτό.
Θα ονομάσουμε αυτό το * v1 * του αρχείου και θα το υποδείξουμε με μπλε χρώμα.
Τώρα τρέχουμε το `git init`, το οποίο θα δημιουργήσει ένα αποθετήριο Git με μια αναφορά HEAD που δείχνει ένα μη ευγενικό κλάδο (` master` δεν υπάρχει ακόμα).

εικόνα :: images / reset-ex1.png []

Σε αυτό το σημείο, μόνο το δέντρο εργασίας Directory έχει οποιοδήποτε περιεχόμενο.

Τώρα θέλουμε να υποβάλλουμε αυτό το αρχείο, οπότε χρησιμοποιούμε το `git add` για να μεταφέρουμε περιεχόμενο στον κατάλογο εργασίας και να το αντιγράψουμε στον ευρετήριο.

εικόνα :: images / reset-ex2.png []

Στη συνέχεια, τρέχουμε το `git commit ', το οποίο παίρνει τα περιεχόμενα του Ευρετηρίου και το αποθηκεύει ως μόνιμο στιγμιότυπο, δημιουργεί ένα αντικείμενο δέσμευσης το οποίο δείχνει αυτό το στιγμιότυπο και ενημερώνει` master' για να δείξει αυτή τη δέσμευση.

εικόνα :: images / reset-ex3.png []

Αν εκτελέσουμε την κατάσταση git, δεν θα δούμε αλλαγές, καθώς και τα τρία δέντρα είναι τα ίδια.

Τώρα θέλουμε να κάνουμε μια αλλαγή σε αυτό το αρχείο και να την υποβάλλουμε.
Θα περάσουμε από την ίδια διαδικασία. πρώτα αλλάζουμε το αρχείο στον κατάλογο εργασίας μας.
Ας ονομάσουμε αυτό το * v2 * του αρχείου και να το υποδείξουμε με κόκκινο χρώμα.

εικόνα :: images / reset-ex4.png []

Αν εκτελέσουμε την κατάσταση `git 'αυτή τη στιγμή, το αρχείο θα εμφανιστεί με κόκκινο χρώμα με την ένδειξη` `Αλλαγές που δεν πραγματοποιήθηκαν για αποστολή' ', επειδή αυτή η καταχώριση διαφέρει μεταξύ του ευρετηρίου και του καταλόγου εργασίας.
Στη συνέχεια τρέχουμε `git add` σε αυτό για να το κατατάξουμε στο Ευρετήριο μας.

εικόνα :: images / reset-ex5.png []

Σε αυτό το σημείο, αν εκτελέσουμε την κατάσταση `git 'θα δούμε το αρχείο πράσινο
κάτω από `` Αλλαγές που πρέπει να υποβληθούν '' επειδή ο Δείκτης και ο HEAD διαφέρουν - δηλαδή, η προτεινόμενη επόμενη δέσμευσή μας τώρα είναι διαφορετική από την τελευταία μας δέσμευση.
Τέλος, τρέχουμε `git commit 'για να οριστικοποιήσουμε τη δέσμευση.

εικόνα :: images / reset-ex6.png []

Τώρα η κατάσταση `git 'δεν θα μας δώσει καμία έξοδο, καθώς και τα τρία δέντρα είναι τα ίδια ξανά.

Η αλλαγή κλάδων ή η κλωνοποίηση περνάει από μια παρόμοια διαδικασία.
Όταν κάνουμε checkout έναν `filter-branch`, αλλάζει * HEAD * για να δείξει το νέο κλάδο ref, συμπληρώνει το * Index * με το στιγμιότυπο αυτής της δέσμευσης και στη συνέχεια αντιγράφει τα περιεχόμενα του * Ευρετηρίου * στο * Working Directory *.

==== Ο ρόλος της επαναφοράς

Η εντολή `reset 'έχει μεγαλύτερη σημασία όταν προβληθεί σε αυτό το πλαίσιο.

Για τους σκοπούς αυτών των παραδειγμάτων, ας πούμε ότι τροποποιήσαμε ξανά το `file.txt` και το υποβάλαμε για τρίτη φορά.
Έτσι τώρα η ιστορία μας μοιάζει με αυτό:

εικόνα :: images / reset-start.png []

Ας περάσουμε τώρα ακριβώς τι κάνει `reset 'όταν το αποκαλούμε.
Χειρίζεται άμεσα αυτά τα τρία δέντρα με έναν απλό και προβλέψιμο τρόπο.
Κάνει μέχρι τρεις βασικές λειτουργίες.

===== Βήμα 1: Μετακινήστε το HEAD

Το πρώτο πράγμα που θα κάνουμε είναι να επαναφέρουμε αυτό που δείχνει το HEAD.
Αυτό δεν είναι το ίδιο με την αλλαγή του ίδιου του HEAD (το οποίο κάνει αυτό το "checkout"). 'reset' μετακινεί τον κλάδο που δείχνει το HEAD.
Αυτό σημαίνει ότι αν το HEAD έχει οριστεί στον κλάδο `master` (δηλ. Βρισκόμαστε στον κλάδο `master`), το `git reset 9e5e6a4` θα ξεκινήσει κάνοντας το` master` point στο `9e5e6a4`.

εικόνα :: images / reset-soft.png []

Ανεξάρτητα από το είδος της «επαναφοράς» με μια δέσμευση που επικαλείται, αυτό είναι το πρώτο πράγμα που θα προσπαθήσει πάντα να κάνει.
Με το `reset --soft ', θα σταματήσει απλά εκεί.

Τώρα πάρτε ένα δευτερόλεπτο για να δούμε αυτό το διάγραμμα και να συνειδητοποιήσουμε τι συνέβη: ουσιαστικά ανέτρεψε την τελευταία εντολή `git commit`.
Όταν εκτελούμε το `git commit ', το Git δημιουργεί μια νέα δέσμευση και μετακινεί το κλάδο που HEAD δείχνει σε αυτό.
Όταν επαναφέρουμε την επιστροφή στο HEAD ~ (το γονικό της HEAD), μετακινούμε τον κλάδο πίσω στο σημείο όπου ήταν, χωρίς να αλλάξουμε τον Ευρετήριο ή τον Κατάλογο εργασίας.
Θα μπορούσαμε τώρα να ενημερώσουμε τον Ευρετήριο και να εκτελέσουμε ξανά το `git commit` για να ολοκληρώσουμε τι θα έκανε το git commit - amend (βλ. << _ git_amend >>).

===== Βήμα 2: Ενημέρωση του Ευρετηρίου (- mixed)

Λάβουμε υπόψη ότι αν εκτελέσουμε την κατάσταση `git 'τώρα θα δούμε με πράσινο τη διαφορά μεταξύ του Ευρετηρίου και του τι είναι το νέο HEAD.

Το επόμενο πράγμα `reset 'θα κάνει είναι να ενημερώσει τον Δείκτη με τα περιεχόμενα του οποίου στιγμιότυπου HEAD τώρα δείχνει.

εικόνα :: images / reset-mixed.png []

Εάν καθορίσουμε την επιλογή `--mixed`, το` reset 'θα σταματήσει σε αυτό το σημείο.
Αυτή είναι και η προεπιλογή, οπότε αν δεν καθορίσουμε καθόλου επιλογή (μόνο `git reset HEAD ~` σε αυτή την περίπτωση), εδώ θα σταματήσει η εντολή.

Τώρα πάρτε ακόμα ένα δευτερόλεπτο για να δούμε αυτό το διάγραμμα και να συνειδητοποιήσουμε τι συνέβη: εξακολουθεί να παραβιάζει την τελευταία μας «δέσμευση», αλλά και τα πάντα.
Επιστρέψαμε πάλι πριν εκτελέσουμε όλες τις εντολές μας `git add` και` git commit`.

===== Βήμα 3: Ενημέρωση του καταλόγου εργασίας (- hard)

Το τρίτο πράγμα που θα κάνει η επαναφορά είναι να κάνει τον κατάλογο εργασίας να μοιάζει με τον ευρετήριο.
Αν χρησιμοποιούμε την επιλογή `--hard`, θα συνεχίσουμε σε αυτό το στάδιο.

εικόνα :: images / reset-hard.png []

Ας αναλογιστούμε λοιπόν τι συνέβη.
Καταργήσαμε την τελευταία δέσμευσή μας, τις εντολές `git add` και` git commit` ** και ** όλη την εργασία που κάναμε στον κατάλογο εργασίας μας.

Είναι σημαντικό να σημειωθεί ότι αυτή η σημαία (`--hard`) είναι ο μόνος τρόπος για να γίνει η εντολή` reset 'επικίνδυνη και μια από τις ελάχιστες περιπτώσεις όπου το Git θα καταστρέψει πραγματικά δεδομένα.
Οποιαδήποτε άλλη επίκληση του `reset 'μπορεί εύκολα να αναβληθεί, αλλά η επιλογή` --hard` δεν μπορεί, αφού αντικαθιστά με βίαιο τρόπο τα αρχεία στον κατάλογο εργασίας.
Σε αυτή τη συγκεκριμένη περίπτωση, εξακολουθούμε να έχουμε την έκδοση * v3 * του αρχείου μας σε μια δέσμευση στο Git DB, και θα μπορούσαμε να το επιστρέψουμε εξετάζοντας το `reflog` μας, αλλά αν δεν το είχαμε υποβληθεί, ο Git θα είχε ακόμα να αντικαταστήσει το αρχείο και θα ήταν ανεπανόρθωτη.

===== Ανακεφαλαίωση

Η εντολή 'επαναφορά' αντικαθιστά αυτά τα τρία δέντρα με συγκεκριμένη σειρά, σταματώντας όταν τα λέτε σε:

1. Μετακινήστε τα σημεία κλάδου HEAD στο _ (σταματήστε εδώ εάν `--soft`) _
2. Κάντε τον δείκτη να μοιάζει με HEAD _ (σταματήστε εδώ εκτός αν `--hard`) _
3. Κάντε τον Κατάλογο εργασίας να μοιάζει με τον Ευρετήριο

==== Επαναφορά με μια διαδρομή

Αυτό καλύπτει τη συμπεριφορά της «επαναφοράς» στη βασική της μορφή, αλλά μπορούμε επίσης να της προσφέρουμε ένα μονοπάτι για να ενεργήσουμε.
Αν καθορίσουμε μια διαδρομή, το `reset 'θα παραλείψει το βήμα 1 και θα περιορίσει το υπόλοιπο των ενεργειών του σε ένα συγκεκριμένο αρχείο ή σύνολο αρχείων.
Αυτό το πραγματικό είδος έχει νόημα - το HEAD είναι απλώς ένας δείκτης και δεν μπορούμε να επισημάνουμε μέρος μιας δέσμευσης και μέρος άλλου.
Ο κατάλογος ευρετηρίου και εργασίας _can_ ενημερώνεται εν μέρει, οπότε η επαναφορά συνεχίζεται με τα βήματα 2 και 3.

Επομένως, υποθέστε ότι τρέχουμε το `git reset file.txt`.
This form (since you did not specify a commit SHA-1 or branch, and you didn't specify `--soft` or `--hard`) is shorthand for `git reset --mixed HEAD file.txt`, which will:

1. Move the branch HEAD points to _(skipped)_
2. Make the Index look like HEAD _(stop here)_

So it essentially just copies `file.txt` from HEAD to the Index.

image::images/reset-path1.png[]

This has the practical effect of _unstaging_ the file.
If we look at the diagram for that command and think about what `git add` does, they are exact opposites.

image::images/reset-path2.png[]

This is why the output of the `git status` command suggests that you run this to unstage a file.
(See <<_unstaging>> for more on this.)

We could just as easily not let Git assume we meant ``pull the data from HEAD'' by specifying a specific commit to pull that file version from.
We would just run something like `git reset eb43bf file.txt`.

image::images/reset-path3.png[]

This effectively does the same thing as if we had reverted the content of the file to *v1* in the Working Directory, ran `git add` on it, then reverted it back to *v3* again (without actually going through all those steps).
If we run `git commit` now, it will record a change that reverts that file back to *v1*, even though we never actually had it in our Working Directory again.

It's also interesting to note that like `git add`, the `reset` command will accept a `--patch` option to unstage content on a hunk-by-hunk basis.
So you can selectively unstage or revert content.

==== Squashing

Let's look at how to do something interesting with this newfound power – squashing commits.

Say you have a series of commits with messages like ``oops.'', ``WIP'' and ``forgot this file''.
You can use `reset` to quickly and easily squash them into a single commit that makes you look really smart.
(<<_squashing>> shows another way to do this, but in this example it's simpler to use `reset`.)

Let's say you have a project where the first commit has one file, the second commit added a new file and changed the first, and the third commit changed the first file again.
The second commit was a work in progress and you want to squash it down.

image::images/reset-squash-r1.png[]

You can run `git reset --soft HEAD~2` to move the HEAD branch back to an older commit (the first commit you want to keep):

image::images/reset-squash-r2.png[]

And then simply run `git commit` again:

image::images/reset-squash-r3.png[]

Now you can see that your reachable history, the history you would push, now looks like you had one commit with `file-a.txt` v1, then a second that both modified `file-a.txt` to v3 and added `file-b.txt`.
The commit with the v2 version of the file is no longer in the history.


==== Check It Out

Finally, you may wonder what the difference between `checkout` and `reset` is.
Like `reset`, `checkout` manipulates the three trees, and it is a bit different depending on whether you give the command a file path or not.

===== Without Paths

Running `git checkout [branch]` is pretty similar to running `git reset --hard [branch]` in that it updates all three trees for you to look like `[branch]`, but there are two important differences.

First, unlike `reset --hard`, `checkout` is working-directory safe; it will check to make sure it's not blowing away files that have changes to them.
Actually, it's a bit smarter than that – it tries to do a trivial merge in the Working Directory, so all of the files you _haven't_ changed in  will be updated.
`reset --hard`, on the other hand, will simply replace everything across the board without checking.

The second important difference is how it updates HEAD.
Where `reset` will move the branch that HEAD points to, `checkout` will move HEAD itself to point to another branch.

For instance, say we have `master` and `develop` branches which point at different commits, and we're currently on `develop` (so HEAD points to it).
If we run `git reset master`, `develop` itself will now point to the same commit that `master` does.
If we instead run `git checkout master`, `develop` does not move, HEAD itself does.
HEAD will now point to `master`.

So, in both cases we're moving HEAD to point to commit A, but _how_ we do so is very different.
`reset` will move the branch HEAD points to, `checkout` moves HEAD itself.

image::images/reset-checkout.png[]

===== With Paths

The other way to run `checkout` is with a file path, which, like `reset`, does not move HEAD.
It is just like `git reset [branch] file` in that it updates the index with that file at that commit, but it also overwrites the file in the working directory.
It would be exactly like `git reset --hard [branch] file` (if `reset` would let you run that) – it's not working-directory safe, and it does not move HEAD.

Also, like `git reset` and `git add`, `checkout` will accept a `--patch` option to allow you to selectively revert file contents on a hunk-by-hunk basis.

==== Περίληψη

Ας ελπίσουμε τώρα ότι καταλαβαίνουμε και αισθανόμαστε πιο άνετα με την εντολή `reset ', αλλά ίσως εξακολουθούμε να έχουμε λίγη σύγχυση σχετικά με τον τρόπο που διαφέρει από το' checkout 'και δεν θα μπορούσαμε να θυμηθούμε όλους τους κανόνες των διαφορετικών επικλήσεων.

Εδώ είναι ένα cheat-φύλλο για το οποίο οι εντολές επηρεάζουν τα δέντρα.
Η στήλη `` HEAD '' διαβάζει `` REF '' αν αυτή η εντολή μετακινεί την αναφορά (κλάδο) στην οποία το HEAD δείχνει και `` HEAD '' αν μετακινεί το ίδιο το HEAD.
Δώστε ιδιαίτερη προσοχή στο 'WD Safe'; στήλη - αν αναφέρει * ΟΧΙ *, πάρτε ένα δευτερόλεπτο για να σκεφτούμε πριν εκτελέσουμε αυτήν την εντολή.

[επιλογές = "κεφαλίδα", cols = "3,1,1,1,1"]
| ================================
| | HEAD | Ευρετήριο | Workdir | WD Safe;
| * Επίπεδο δέσμευσης * | | |
| `reset --soft [commit]` REF | NO | NO | ΝΑΙ
| `επαναφορά [commit]` REF | ΝΑΙ NO | ΝΑΙ
| `επαναφορά - σκληρή [δέσμευση]` REF | ΝΑΙ ΝΑΙ *ΟΧΙ*
| "checkout [commit]` HEAD | ΝΑΙ ΝΑΙ ΝΑΙ
| * Επίπεδο αρχείου * | | |
| `επαναφορά (commit) [αρχείο]` NO | ΝΑΙ NO | ΝΑΙ
| "checkout (commit) [αρχείο]` NO | ΝΑΙ ΝΑΙ *ΟΧΙ*
| ================================





ΕΝΟΤΗΤΑ 7.8

[[_advanced_merging]]
=== Σύνθετη συγχώνευση

Η συγχώνευση στο Git είναι συνήθως αρκετά εύκολη.
Εφόσον το Git καθιστά εύκολη τη συγχώνευση ενός άλλου κλάδου πολλές φορές, αυτό σημαίνει ότι μπορούμε να έχουμε έναν πολύ μακρόβιο κλάδο, αλλά μπορούμε να το κρατάμε ενημερωμένο καθώς πηγαίνουμε, επιλύοντας συχνά μικρές συγκρούσεις, αντί να εκπλαγούμε από μια τεράστια σύγκρουση στο τέλος της σειράς.

Εντούτοις, μερικές φορές προκύπτουν δύσκολες συγκρούσεις.
Σε αντίθεση με κάποια άλλα συστήματα ελέγχου έκδοσης, το Git δεν προσπαθεί να είναι υπερβολικά έξυπνο για τη λύση της επίλυσης συγκρούσεων.
Η φιλοσοφία του Git είναι να είναι έξυπνη για να προσδιορίσει πότε μια λύση συγχώνευσης είναι ξεκάθαρη, αλλά αν υπάρχει σύγκρουση, δεν προσπαθεί να είναι έξυπνος για την αυτόματη επίλυσή της.
Επομένως, αν περιμένουμε πολύ για να συγχωνεύσουμε δύο κλάδους που αποκλίνουν γρήγορα, μπορούμε να αντιμετωπίσουμε ορισμένα ζητήματα.

Σε αυτή την ενότητα, θα αναφερθούμε σε ποια από αυτά τα θέματα θα μπορούσαν να είναι και τι εργαλεία Git μας δίνει για να βοηθήσουμε να χειριστούμε αυτές τις πιο δύσκολες καταστάσεις.
Θα καλύψουμε επίσης μερικούς από τους διαφορετικούς, μη τυποποιημένους τύπους συγχώνευσης που μπορούμε να κάνουμε, καθώς και να δούμε πώς μπορούμε να αποφύγουμε συγχωνεύσεις που έχουμε κάνει.

==== Συγχώνευση συγκρούσεων

Ενώ καλύψαμε κάποια βασικά στοιχεία για την επίλυση των συγκρούσεων συγχώνευσης σε << _ basic_merge_conflicts >>, για πιο πολύπλοκες συγκρούσεις, το Git παρέχει μερικά εργαλεία για να μας βοηθήσει να καταλάβουμε τι συμβαίνει και πώς να αντιμετωπίσουμε καλύτερα τη σύγκρουση.

Πρώτα απ 'όλα, αν είναι δυνατόν, προσπαθούμε να βεβαιωθούμε ότι ο κατάλογος εργασίας μας είναι καθαρός πριν κάνουμε μια συγχώνευση που μπορεί να έχει συγκρούσεις.
Εάν έχουμε εργασία σε εξέλιξη, είτε την υποβάλουμε σε έναν προσωρινό κλάδο είτε την αποθηκεύσουμε.
Αυτό το καθιστά έτσι ώστε να μπορούμε να ακυρώσουμε * οτιδήποτε * δοκιμάσουμε εδώ.
Εάν έχουμε μη αποθηκευμένες αλλαγές στον κατάλογο εργασίας μας όταν δοκιμάζουμε συγχώνευση, ορισμένες από αυτές τις συμβουλές μπορεί να μας βοηθήσουν να χάσουμε αυτήν την εργασία.

Ας περάσουμε από ένα πολύ απλό παράδειγμα.
Έχουμε ένα εξαιρετικά απλό αρχείο Ruby που εκτυπώνει 'hello world'.

[πηγή, ρουμπίνι]
----
#! / usr / bin / env ruby

def hello
  βάζει "γεια κόσμο"
τέλος

Χαίρετε()
----

Στο αποθετήριό μας, δημιουργούμε έναν νέο κλάδο που ονομάζεται «κενό διάστημα» και προχωράμε στην αλλαγή όλων των τερματισμών της γραμμής Unix σε τερματισμούς γραμμής DOS, αλλάζοντας ουσιαστικά κάθε γραμμή του αρχείου, αλλά μόνο με κενά.
Στη συνέχεια, αλλάζουμε τη γραμμή `` hello world '' στο 'hello mundo' '.

[πηγή, κονσόλα]
----
$ git checkout -b κενό διάστημα
Μεταπήδησε σε ένα νέο κλάδο 'κενό'

$ unix2dos hello.rb
unix2dos: μετατροπή του αρχείου hello.rb σε μορφή DOS ...
$ git commit -am 'μετατραπεί το hello.rb στο DOS'
[whitespace 3270f76] μετατρέπει το hello.rb στο DOS
 1 αρχείο άλλαξε, 7 εισαγωγές (+), 7 διαγραφές (-)

$ vim hello.rb
$ git diff -b
diff - git a / hello.rb b / hello.rb
δείκτης ac51efd..e85207e 100755
--- a / hello.rb
+++ β / hello.rb
@@ -1,7 +1,7 @@
 #! / usr / bin / env ruby

 def hello
- βάζει "γεια κόσμο"
+ βάζει 'hello mundo' ^ M
 τέλος

 Χαίρετε()

$ git commit -am 'hello mundo change'
[whitespace 6d338d2] αλλαγή hello mundo
 1 αρχείο άλλαξε, 1 εισαγωγή (+), 1 διαγραφή (-)
----

Τώρα επιστρέφουμε στον κλάδο `master` και προσθέτουμε κάποια τεκμηρίωση για τη λειτουργία.

[πηγή, κονσόλα]
----
$ git master checkout
Μετάβαση στο κλάδο 'master'

$ vim hello.rb
$ git diff
diff - git a / hello.rb b / hello.rb
δείκτης ac51efd..36c06c8 100755
--- a / hello.rb
+++ β / hello.rb
@@ -1,5 +1,6 @@
 #! / usr / bin / env ruby

+ # εκτυπώνει ένα χαιρετισμό
 def hello
   βάζει "γεια κόσμο"
 τέλος

$ git commit -am 'έγγραφο της συνάρτησης'
[master bec6336] τεκμηριώνει τη λειτουργία
 1 αρχείο άλλαξε, 1 εισαγωγή (+)
----

Τώρα προσπαθούμε να συγχωνευθούμε στον κλάδο μας `whitespace` και θα έχουμε συγκρούσεις εξαιτίας των αλλαγών στο κενό.

[πηγή, κονσόλα]
----
$ git συγχώνευση κενών
Αυτόματη συγχώνευση hello.rb
CONFLICT (περιεχόμενο): Συγχώνευση διενέξεων στο hello.rb
Η αυτόματη συγχώνευση απέτυχε να διορθώσουμε τις συγκρούσεις και στη συνέχεια να υποβάλουμε το αποτέλεσμα.
----

[[_abort_merge]]
===== Ακύρωση συγχώνευσης

Έχουμε τώρα μερικές επιλογές.
Πρώτον, ας καλύψουμε πώς να βγούμε από αυτή την κατάσταση.
Εάν ίσως δεν περίμεναν συγκρούσεις και δεν θέλεις να ασχοληθείς με την κατάσταση ακόμα, μπορείς απλά να βγεις από τη συγχώνευση με το `git merge --abort`.

[πηγή, κονσόλα]
----
$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master
----

Η επιλογή `git merge --abort` προσπαθεί να επιστρέψει στην κατάστασή μας πριν εκτελέσουμε τη συγχώνευση.
Οι μόνες περιπτώσεις στις οποίες μπορεί να μην είναι σε θέση να το κάνει τέλεια θα ήταν εάν είχαμε ασταθείς, μη υποβλημένες αλλαγές στον κατάλογο εργασίας όταν την έτρεχε, αλλιώς θα έπρεπε να δουλέψει καλά.

Αν για κάποιο λόγο θέλουμε απλώς να αρχίσουμε πάλι, μπορούμε επίσης να εκτελέσουμε το `git reset --hard HEAD` και η αποθήκη μας θα επιστρέψει στην τελευταία αφοσιωμένη κατάσταση.
Θυμηθούμε ότι οποιαδήποτε εργασία δεν έχει υποβληθεί θα χαθεί, οπότε πρέπει να βεβαιωθούμε ότι δεν θέλουμε τις αλλαγές μας.

===== Αγνόηση του λευκού χώρου

Στη συγκεκριμένη περίπτωση, οι συγκρούσεις σχετίζονται με το κενό.
Γνωρίζουμε αυτό γιατί η υπόθεση είναι απλή, αλλά είναι επίσης πολύ εύκολο να το πεις σε πραγματικές περιπτώσεις όταν εξετάζεις τη σύγκρουση επειδή κάθε γραμμή έχει αφαιρεθεί από τη μια πλευρά και έχει προστεθεί ξανά από την άλλη.
Από προεπιλογή, το Git βλέπει όλες αυτές τις γραμμές να αλλάζουν, οπότε δεν μπορεί να συγχωνεύσει τα αρχεία.

Η προεπιλεγμένη στρατηγική συγχώνευσης μπορεί να πάρει επιχειρήματα αν και μερικά από αυτά είναι για να αγνοούν σωστά τις αλλαγές στο κενό.
Αν δούμε ότι έχουμε πολλά προβλήματα στο κενό σε μια συγχώνευση, μπορούμε απλά να το ακυρώσουμε και να το κάνουμε ξανά, αυτή τη φορά με το "-Xignore-all-space" ή το "-Xignore-space-change".
Η πρώτη επιλογή αγνοεί τον κενό χώρο ** εντελώς ** κατά τη σύγκριση γραμμών, η δεύτερη αντιμετωπίζει τις αλληλουχίες ενός ή περισσότερων χαρακτήρων κενής θέσης ως ισοδύναμα.

[πηγή, κονσόλα]
----
$ git συγχώνευση -Xignore-space-αλλαγή κενό διάστημα
Αυτόματη συγχώνευση hello.rb
Συγχώνευση από την «αναδρομική» στρατηγική.
 hello.rb | 2 + -
 1 αρχείο άλλαξε, 1 εισαγωγή (+), 1 διαγραφή (-)
----

Δεδομένου ότι σε αυτήν την περίπτωση, οι αλλαγές του πραγματικού αρχείου δεν ήταν αντιφατικές, αφού αγνοήσαμε τις αλλαγές στο κενό, όλα πάνε καλά.

Αυτό είναι ένα lifesaver εάν έχουμε κάποιον στην ομάδα μας που του αρέσει να περιστοιχίζει περιστασιακά τα πάντα από διαστήματα σε καρτέλες ή αντίστροφα.

[[_manual_remerge]]
===== Εγχειρίδιο αρχείου Επανασύνδεση

Παρόλο που ο Git επεξεργάζεται την προεπεξεργασία των λευκών χώρων αρκετά καλά, υπάρχουν και άλλοι τύποι αλλαγών που ίσως το Git δεν μπορεί να χειριστεί αυτόματα, αλλά είναι διορθωμένες σε στίγματα.
Για παράδειγμα, ας υποθέσουμε ότι ο Git δεν μπόρεσε να χειριστεί την αλλαγή του λευκού χώρου και έπρεπε να το κάνουμε με το χέρι.

Αυτό που πραγματικά πρέπει να κάνουμε είναι να εκτελέσουμε το αρχείο που προσπαθούμε να συγχωνεύσουμε μέσω ενός προγράμματος `dos2unix` προτού δοκιμάσουμε την πραγματική συγχώνευση αρχείων.
Πώς θα το κάναμε έτσι;

Πρώτον, μπαίνουμε στην κατάσταση σύγκρουσης συγχώνευσης.
Στη συνέχεια, θέλουμε να λάβουμε αντίγραφα της έκδοσης του αρχείου, της έκδοσής τους (από τον κλάδο που συγχωνεύουμε) και της κοινής έκδοσης (από όπου και οι δύο πλευρές διακλαδίζονται).
Στη συνέχεια, θέλουμε να διορθώσουμε είτε την πλευρά τους είτε την πλευρά μας και να ξαναδοκιμάσουμε τη συγχώνευση και πάλι μόνο για αυτό το μοναδικό αρχείο.

Η λήψη των τριών εκδόσεων αρχείων είναι πραγματικά εύκολη.
Το Git αποθηκεύει όλες αυτές τις εκδόσεις στο ευρετήριο κάτω από τα `` στάδια '' τα οποία ο καθένας έχει τους αριθμούς που σχετίζονται με αυτά.
Το στάδιο 1 είναι ο κοινός πρόγονος, το στάδιο 2 είναι η έκδοση μας και το στάδιο 3 είναι από το `MERGE_HEAD`, την έκδοση που συγχωνεύουμε (` `theirs '').

Μπορούμε να εξαγάγουμε ένα αντίγραφο από κάθε μία από αυτές τις εκδόσεις του αρχείου που βρίσκεται σε διένεξη με την εντολή `git show` και μια ειδική σύνταξη.

[πηγή, κονσόλα]
----
$ git εμφάνιση: 1: hello.rb> hello.common.rb
$ git εμφάνιση: 2: hello.rb> hello.ours.rb
$ git εμφάνιση: 3: hello.rb> hello.theirs.rb
----

Αν θέλουμε να πάρουμε λίγο περισσότερο σκληρό πυρήνα, μπορούμε επίσης να χρησιμοποιήσουμε την εντολή `ls-files -u` για να λάβουμε τα πραγματικά SHA-1s των Git blobs για κάθε ένα από αυτά τα αρχεία.

[πηγή, κονσόλα]
----
$ git ls-αρχεία -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1 hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2 hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3 hello.rb
----

Το `: 1: hello.rb` είναι απλά μια συντομογραφία για να κοιτάξει κανείς εκείνο το blob SHA-1.

Τώρα που έχουμε το περιεχόμενο και των τριών σταδίων στον κατάλογο εργασίας μας, μπορούμε να διορθώσουμε χειροκίνητα τη δική τους για να διορθώσουμε το πρόβλημα του κεντρικού χώρου και να συγχωνεύσουμε ξανά το αρχείο με την ελάχιστα γνωστή εντολή `git merge-file` που κάνει ακριβώς αυτό.

[πηγή, κονσόλα]
----
$ dos2unix hello.theirs.rb
dos2unix: μετατροπή του αρχείου hello.theirs.rb σε μορφή Unix ...

$ git συγχώνευση-αρχείο -p \
    hello.ours.rb hello.common.rb hello.theirs.rb> hello.rb

$ git diff -b
diff - cc hello.rb
δείκτης 36c06c8, e85207e..0000000
--- a / hello.rb
+++ β / hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! / usr / bin / env ruby

 + # εκτυπώνει ένα χαιρετισμό
  def hello
- βάζει "γεια κόσμο"
+ βάζει 'hello mundo'
  τέλος

  Χαίρετε()
----

Σε αυτό το σημείο έχουμε συγχωνεύσει ωραία το αρχείο.
Στην πραγματικότητα, αυτό λειτουργεί καλύτερα από την επιλογή `ignore-space-change ', διότι αυτό στην πραγματικότητα επιδιορθώνει τις αλλαγές του κεντρικού χώρου πριν από τη συγχώνευση αντί να τις αγνοεί απλώς.
Στη συγχώνευση `ignore-space-change`, καταλήξαμε με μερικές γραμμές με τερματισμούς γραμμής DOS, κάνοντας τα πράγματα μικτά.

Εάν θέλουμε να πάρουμε μια ιδέα πριν τελειώσουμε αυτήν τη δέσμευση για το τι πραγματικά άλλαξε μεταξύ της μιας πλευράς ή της άλλης, μπορούμε να ζητήσουμε από το `git diff` να συγκρίνουμε τι υπάρχει στον κατάλογο εργασίας που πρόκειται να υποβάλουμε ως αποτέλεσμα συγχώνευση σε οποιοδήποτε από αυτά τα στάδια.
Ας περάσουμε από όλα αυτά.

Για να συγκρίνουμε το αποτέλεσμά μας με αυτό που είχαμε στον κλάδο μας πριν από τη συγχώνευση, με άλλα λόγια, για να δούμε τι εισήγαγε η συγχώνευση, μπορούμε να εκτελέσουμε το `git diff --ours`

[πηγή, κονσόλα]
----
$ git diff --ours
* Ξετυλιγμένη διαδρομή hello.rb
diff - git a / hello.rb b / hello.rb
δείκτης 36c06c8..44d0a25 100755
--- a / hello.rb
+++ β / hello.rb
@@ -2,7 +2,7 @@

 # εκτυπώνει ένα χαιρετισμό
 def hello
- βάζει "γεια κόσμο"
+ βάζει 'hello mundo'
 τέλος

 Χαίρετε()
----

Έτσι, εδώ μπορούμε εύκολα να δούμε ότι αυτό που συνέβη στον κλάδο μας, αυτό που εισάγουμε στην πραγματικότητα σε αυτό το αρχείο με αυτήν τη συγχώνευση, αλλάζει αυτή τη μοναδική γραμμή.

Αν θέλουμε να δούμε πώς το αποτέλεσμα της συγχώνευσης διέφερε από αυτό που ήταν στο πλευρό τους, μπορούμε να εκτελέσουμε το `git diff --their`.
Σε αυτό και στο ακόλουθο παράδειγμα, πρέπει να χρησιμοποιήσουμε το `-b` για να καταργήσουμε το κενό επειδή το συγκρίνουμε με αυτό που υπάρχει στο Git, όχι το καθαρισμένο αρχείο` hello.theirs.rb`.

[πηγή, κονσόλα]
----
$ git diff - τους -b
* Ξετυλιγμένη διαδρομή hello.rb
diff - git a / hello.rb b / hello.rb
δείκτης e85207e..44d0a25 100755
--- a / hello.rb
+++ β / hello.rb
@@ -1,5 +1,6 @@
 #! / usr / bin / env ruby

+ # εκτυπώνει ένα χαιρετισμό
 def hello
   βάζει 'hello mundo'
 τέλος
----

Τέλος, μπορούμε να δούμε πως το αρχείο έχει αλλάξει και από τις δύο πλευρές με το `git diff --base`.

[πηγή, κονσόλα]
----
$ git diff -base -b
* Ξετυλιγμένη διαδρομή hello.rb
diff - git a / hello.rb b / hello.rb
δείκτης ac51efd..44d0a25 100755
--- a / hello.rb
+++ β / hello.rb
@@ -1,7 +1,8 @@
 #! / usr / bin / env ruby

+ # εκτυπώνει ένα χαιρετισμό
 def hello
- βάζει "γεια κόσμο"
+ βάζει 'hello mundo'
 τέλος

 Χαίρετε()
----

Σε αυτό το σημείο μπορούμε να χρησιμοποιήσουμε την εντολή `git clean` για να ξεκαθαρίσουμε τα επιπλέον αρχεία που δημιουργήσαμε για να κάνουμε τη χειροκίνητη συγχώνευση αλλά δεν χρειάζεται πλέον.

[πηγή, κονσόλα]
----
$ git clean -f
Κατάργηση του hello.common.rb
Αφαίρεση του hello.ours.rb
Αφαίρεση του hello.theirs.rb
----

[[_checking_out_conflicts]]
===== Έλεγχος των συγκρούσεων

Ίσως δεν είμαστε ευχαριστημένοι με το ψήφισμα σε αυτό το σημείο για κάποιο λόγο, ή ίσως η χειροκίνητη επεξεργασία μιας ή και των δύο πλευρών ακόμα δεν λειτούργησε καλά και χρειαζόμαστε περισσότερο περιβάλλον.

Ας αλλάξουμε λίγο το παράδειγμα.
Για αυτό το παράδειγμα, έχουμε δυο κλάδοι μεγαλύτερης διάρκειας ζωής, οι οποίοι έχουν μερικές υποβολές, αλλά δημιουργούν μια νόμιμη σύγκρουση περιεχομένου όταν συγχωνευθούν.

[πηγή, κονσόλα]
----
$ git log --graph --online --decorate - όλα
* f1270f7 (HEAD, master) ενημέρωση του README
* 9af9d3b προσθέστε ένα README
* 694971d φράση ενημέρωσης στον κόσμο hola
| * e3eb223 (mundo) προσθέστε περισσότερες δοκιμές
| * 7cff591 προσθέστε δέσμη ενεργειών δοκιμής
| * c3ffff1 άλλαξε το κείμενο στο hello mundo
| /
* b7dcc89 αρχικός γεια παγκόσμιος κώδικας
----

Τώρα έχουμε τρεις μοναδικές υποβολές που ζουν μόνο στον κλάδο `master` και τρεις άλλους που ζουν στον κλάδο` mundo`.
Αν προσπαθήσουμε να συγχωνεύσουμε τον κλάδο `mundo`, έχουμε μια σύγκρουση.

[πηγή, κονσόλα]
----
$ git merge mundo
Αυτόματη συγχώνευση hello.rb
CONFLICT (περιεχόμενο): Συγχώνευση διενέξεων στο hello.rb
Η αυτόματη συγχώνευση απέτυχε να διορθώσουμε τις συγκρούσεις και στη συνέχεια να υποβάλουμε το αποτέλεσμα.
----

Θα θέλαμε να δούμε τι είναι η σύγκρουση συγχώνευσης.
Αν ανοίξουμε το αρχείο, θα δούμε κάτι τέτοιο:

[πηγή, ρουμπίνι]
----
#! / usr / bin / env ruby

def hello
<<<<<<< HEAD
  βάζει "κόσμο hola"
=======
  βάζει 'hello mundo'
>>>>>>> mundo
τέλος

Χαίρετε()
----

Και οι δύο πλευρές της συγχώνευσης πρόσθεσαν περιεχόμενο σε αυτό το αρχείο, αλλά μερικές από τις υποβολές τροποποίησαν το αρχείο στον ίδιο χώρο που προκάλεσε αυτή τη σύγκρουση.

Ας διερευνήσουμε μερικά εργαλεία που έχουμε τώρα στη διάθεσή μας για να καθορίσουμε πώς προέκυψε αυτή η σύγκρουση.
Ίσως δεν είναι προφανές πώς ακριβώς πρέπει να διορθώσουμε αυτή τη σύγκρουση.
Χρειαζόμαστε περισσότερο περιβάλλον.

Ένα χρήσιμο εργαλείο είναι το `git checkout` με την επιλογή` --conflict '.
Αυτό θα ξανά εκτελεί το αρχείο και θα αντικαταστήσει τους δείκτες σύγκλισης συγχώνευσης.
Αυτό μπορεί να είναι χρήσιμο αν θέλουμε να επαναφέρουμε τους δείκτες και να προσπαθήσουμε να τις λύσουμε ξανά.

Μπορούμε να περάσουμε `--conflict` είτε 'diff3` είτε ' merge '(που είναι η προεπιλογή).
Εάν το περάσουμε το `diff3`, το Git θα χρησιμοποιήσει μια ελαφρώς διαφορετική έκδοση σημάτων σύγκρουσης, όχι μόνο να μας δώσει τις εκδόσεις` `ours '' και` `s '' αλλά και την έκδοση `` base '' inline για να μας δώσει περισσότερο.

[πηγή, κονσόλα]
----
$ git checkout --conflict = diff3 hello.rb
----

Μόλις το τρέξουμε αυτό, το αρχείο θα μοιάζει με αυτό:

[πηγή, ρουμπίνι]
----
#! / usr / bin / env ruby

def hello
<<<<<<< δικά μας
  βάζει "κόσμο hola"
||||||| βάση
  βάζει "γεια κόσμο"
=======
  βάζει 'hello mundo'
>>>>>>> τους
τέλος

Χαίρετε()
----

Εάν μας αρέσει αυτή η μορφή, μπορούμε να την ορίσουμε ως προεπιλογή για μελλοντικές διενέξεις συγχώνευσης, ορίζοντας τη ρύθμιση `merge.conflictstyle` σε` diff3`.

[πηγή, κονσόλα]
----
$ git config --global merge.conflictstyle diff3
----

Η εντολή "git checkout" μπορεί επίσης να πάρει τις επιλογές `--ours 'και` --their', οι οποίες μπορεί να είναι ένας πολύ γρήγορος τρόπος για να επιλέξουμε απλά τη μια πλευρά ή την άλλη χωρίς να συγχωνεύσουμε τα πράγματα καθόλου.

Αυτό μπορεί να είναι ιδιαίτερα χρήσιμο για συγκρούσεις δυαδικών αρχείων, όπου μπορούμε απλά να επιλέξουμε μία πλευρά ή όπου θέλουμε να συγχωνεύσουμε μόνο ορισμένα αρχεία από άλλον κλάδο -- μπορούμε να κάνουμε συγχώνευση και στη συνέχεια να ολοκληρώσουμε την ολοκλήρωση κάποιων αρχείων από τη μια πλευρά ή την άλλη πριν από τη δέσμευση.

[[_merge_log]]
===== Συγχώνευση αρχείου καταγραφής

Ένα άλλο χρήσιμο εργαλείο κατά την επίλυση συγχωνεύσεων συγχώνευσης είναι το `git log`.
Αυτό μπορεί να μας βοηθήσει να αποκτήσουμε περιεχόμενο σχετικά με το τι μπορεί να συνέβαλε στις συγκρούσεις.
Αναθεώρηση λίγη ιστορία για να θυμόμαστε γιατί δύο γραμμές ανάπτυξης έρχονται σε επαφή με την ίδια περιοχή του κώδικα μπορεί να είναι πραγματικά χρήσιμη μερικές φορές.

Για να πάρουμε μια πλήρη λίστα με όλες τις μοναδικές υποβολές που συμπεριλήφθηκαν σε οποιονδήποτε κλάδο που συμμετέχει σε αυτήν τη συγχώνευση, μπορούμε να χρησιμοποιήσουμε τη σύνταξη `` τριπλής κουκίδας '' που μάθαμε στο << _ triple_dot >>.

[πηγή, κονσόλα]
----
$ git log --online - αριστερά-δεξιά HEAD ... MERGE_HEAD
<f1270f7 ενημέρωση του README
<9af9d3b προσθέστε ένα README
<694971d ενημερώστε φράση στον κόσμο hola
> e3eb223 προσθέστε περισσότερες δοκιμές
> 7cff591 προσθέστε δέσμη ενεργειών δοκιμής
> c3ffff1 άλλαξε το κείμενο στο hello mundo
----

Αυτή είναι μια ωραία λίστα των έξι συνολικών υποβολών που εμπλέκονται, καθώς και ποια γραμμή ανάπτυξης ανέλαβε κάθε δέσμευση.

Μπορούμε να απλουστεύσουμε περαιτέρω αυτό το γεγονός αν και να μας δώσουμε πολύ πιο συγκεκριμένο πλαίσιο.
Αν προσθέσουμε την επιλογή `--merge 'στο` git log`, θα εμφανιστούν μόνο οι υποβολές σε κάθε πλευρά της συγχώνευσης που αγγίζουν ένα αρχείο που βρίσκεται σε διένεξη.

[πηγή, κονσόλα]
----
$ git log -online -left-right -merge
<694971d ενημερώστε φράση στον κόσμο hola
> c3ffff1 άλλαξε το κείμενο στο hello mundo
----

Αν τρέξουμε αυτό με την επιλογή `-p`, αντί να πάρουμε μόνο τις διαφορές στο αρχείο που κατέληξε σε σύγκρουση.
Αυτό μπορεί να είναι ** πραγματικά ** χρήσιμο για να μας δώσει γρήγορα το πλαίσιο που χρειαζόμαστε για να καταλάβουμε γιατί κάτι συγκρούσεις και πώς να το επιλύσουμε πιο έξυπνα.

===== Συνδυασμένη μορφή Diff

Εφόσον το Git επεξεργάζεται όλα τα αποτελέσματα συγχώνευσης που είναι επιτυχημένα, όταν εκτελούμε το `git diff`, ενώ βρισκόμαστε σε μια κατάσταση σύγκρουσης συγχώνευσης, αποκτάμε μόνο ό, τι είναι ακόμα σε σύγκρουση.
Αυτό μπορεί να μας βοηθήσει να δούμε τι πρέπει ακόμα να επιλύσουμε.

Όταν τρέχουμε το `git diff` αμέσως μετά από μια σύγκρουση συγχώνευσης, θα μας δώσει πληροφορίες σε μια μάλλον μοναδική μορφή εξόδου diff.

[πηγή, κονσόλα]
----
$ git diff
diff - cc hello.rb
δείκτης 0399cd5,59727f0..0000000
--- a / hello.rb
+++ β / hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! / usr / bin / env ruby

  def hello
++ <<<<<<< HEAD
 + βάζει "κόσμο hola"
++ =======
+ βάζει 'hello mundo'
++ >>>>>>> mundo
  τέλος

  Χαίρετε()
----

Η μορφή ονομάζεται `` Combined Diff '' και μας δίνει δύο στήλες δεδομένων δίπλα σε κάθε γραμμή.
Η πρώτη στήλη δείχνει αν αυτή η γραμμή είναι διαφορετική (προστιθέμενη ή καταργηθείσα) μεταξύ του κλάδου `` μας '' και του αρχείου στον κατάλογο εργασίας μας και η δεύτερη στήλη κάνει το ίδιο μεταξύ του κλάδου `` theirs '' και του αντιγράφου του καταλόγου εργασίας .

Έτσι σε αυτό το παράδειγμα μπορούμε να δούμε ότι οι γραμμές <<<<<<< »και` >>>>>>> `βρίσκονται στο αντίγραφο εργασίας αλλά δεν βρίσκονται σε καμία πλευρά της συγχώνευσης.
Αυτό έχει νόημα επειδή το εργαλείο συγχώνευσης τους κολλήσει εκεί για το περιβάλλον μας, αλλά αναμένεται να τα αφαιρέσουμε.

Αν επιλύσουμε τη σύγκρουση και εκκινήσουμε ξανά το `git diff`, θα δούμε το ίδιο πράγμα, αλλά είναι λίγο πιο χρήσιμο.

[πηγή, κονσόλα]
----
$ vim hello.rb
$ git diff
diff - cc hello.rb
δείκτης 0399cd5,59727f0..0000000
--- a / hello.rb
+++ β / hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! / usr / bin / env ruby

  def hello
- βάζει "κόσμο hola"
 - βάζει 'hello mundo'
++ βάζει 'hola mundo'
  τέλος

  Χαίρετε()
----

Αυτό μας δείχνει ότι το `` hola world '' ήταν στο πλευρό μας, αλλά όχι στο αντίγραφο εργασίας, ότι `` hello mundo '' ήταν στο πλευρό τους αλλά όχι στο αντίγραφο εργασίας και τέλος ότι `` hola mundo '' δεν ήταν κάθε πλευρά αλλά τώρα βρίσκεται στο αντίγραφο εργασίας.
Αυτό μπορεί να είναι χρήσιμο για έλεγχο πριν από τη δέσμευση της ανάλυσης.

Μπορούμε επίσης να πάρουμε αυτό από το `git log 'για οποιαδήποτε συγχώνευση μετά το γεγονός για να δούμε πώς κάτι επιλύθηκε μετά το γεγονός.
Το Git θα εκτυπώσει αυτή τη μορφή αν εκτελέσουμε το `git show` σε μια διεπαφή συγχώνευσης ή εάν προσθέσουμε μια επιλογή` - cc 'σε ένα `git log -p` (το οποίο από προεπιλογή εμφανίζει μόνο επιθέματα για μη συγχωνεύσεις).

[πηγή, κονσόλα]
----
$ git log - cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Συγχώνευση: f1270f7 e3eb223
Συντάκτης: Scott Chacon <schacon@gmail.com>
Ημερομηνία: Παρ 19 Σεπτεμβρίου 18:14:49 2014 +0200

    Συγχώνευση κλάδο 'mundo'

    Συγκρούσεις:
        hello.rb

diff - cc hello.rb
δείκτης 0399cd5,59727f0..e1d0799
--- a / hello.rb
+++ β / hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! / usr / bin / env ruby

  def hello
- βάζει "κόσμο hola"
 - βάζει 'hello mundo'
++ βάζει 'hola mundo'
  τέλος

  Χαίρετε()
----

[[_undoing_merges]]
==== Αναίρεση συγχώνευσης

Τώρα που ξέρουμε πώς να δημιουργήσουμε μια δέσμευση συγχώνευσης, θα κάνουμε πιθανώς κάποια κατά λάθος.
Ένα από τα σπουδαία πράγματα για τη συνεργασία με το Git είναι ότι είναι εντάξει να κάνουμε λάθη, επειδή είναι δυνατόν (και σε πολλές περιπτώσεις εύκολο) να τα διορθώσουμε.

Οι υποβολές συγχώνευσης δεν διαφέρουν.
Ας υποθέσουμε ότι ξεκινήσαμε να εργαζόμαστε σε ένα κλάδο θεμάτων, συγχωνεύσαμε τον κατά λάθος σε `master` και τώρα το ιστορικό των αποστολών μας μοιάζει με αυτό:

.Υποχρεωτική συγχώνευση
image :: images / undomerge-start.png [Εμπιστευτική συγχώνευση].

Υπάρχουν δύο τρόποι προσέγγισης αυτού του προβλήματος, ανάλογα με το επιθυμητό αποτέλεσμα.

===== Διορθώστε τις αναφορές

Εάν η ανεπιθύμητη δέσμευση συγχώνευσης υπάρχει μόνο στο τοπικό αποθετήριο, η πιο εύκολη και βέλτιστη λύση είναι να μετακινήσουμε τους κλάδους ώστε να δείχνουν εκεί που θέλουμε.
Στις περισσότερες περιπτώσεις, αν ακολουθήσουμε την παράλειψη `git merge 'με` git reset --hard HEAD ~ `, αυτό θα επαναφέρει τους δείκτες κλάδων έτσι ώστε να μοιάζουν με αυτό:

.Η ιστορία μετά από `git reset --hard HEAD ~`
image :: images / undomerge-reset.png [Ιστορικό μετά το `git reset --hard HEAD ~`.]

Καλύψαμε την επαναφορά στο << _git_reset >>, επομένως δεν πρέπει να είναι πολύ δύσκολο να καταλάβουμε τι συμβαίνει εδώ.
Εδώ είναι μια γρήγορη ανανέωση: 'reset - hard' συνήθως περνάει από τρία βήματα:

. Μετακινήστε τα σημεία κλάδου HEAD στο.
  Σε αυτήν την περίπτωση, θέλουμε να μετακινήσουμε τον `κύριο` στον τόπο που ήταν πριν από τη συνένωση συγχώνευσης (` C6`).
. Κάντε τον δείκτη να μοιάζει με HEAD.
. Κάντε τον κατάλογο εργασίας να μοιάζει με τον ευρετήριο.

Το μειονέκτημα αυτής της προσέγγισης είναι ότι πρόκειται για επανεγγραφή ιστορικού, το οποίο μπορεί να είναι προβληματικό με ένα κοινό αποθετήριο.

Δούμε το << _ rebase_peril >> για περισσότερα σχετικά με το τι μπορεί να συμβεί. η σύντομη έκδοση είναι ότι αν άλλοι άνθρωποι έχουν τις υποβολές που ξαναγράφουμε, θα πρέπει πιθανώς να αποφύγουμε την 'επαναφορά'.
Αυτή η προσέγγιση επίσης δεν θα λειτουργήσει εάν έχουν δημιουργηθεί άλλες υποβολές από τη συγχώνευση. η μετακίνηση των αναφορών θα χάσει αποτελεσματικά αυτές τις αλλαγές.

[[_reverse_commit]]
===== Αντίστροφη δέσμευση

Εάν μετακινήσουμε τους δείκτες κλάδων γύρω μας δεν πρόκειται να λειτουργήσει για εσάς, το Git μας δίνει τη δυνατότητα να κάνουμε μια νέα δέσμευση, η οποία ακυρώνει όλες τις αλλαγές από μία υπάρχουσα.
Το Git ονομάζει αυτή την ενέργεια μια `` επαναφορά '', και σε αυτό το συγκεκριμένο σενάριο, θα το χρησιμοποιήσουμε ως εξής:

[πηγή, κονσόλα]
----
$ git επιστρέφει -m 1 HEAD
[master b1d8379] Επαναφορά του θέματος "Συγχώνευση κλάδου" "
----

Η σημαία `-m 1` υποδεικνύει ποιος γονέας είναι` `mainline '' και θα πρέπει να τηρείται.
Όταν ξεκινάμε μια συγχώνευση σε `HEAD '(` git merge theme'), η νέα δέσμευση έχει δύο γονείς: ο πρώτος είναι `HEAD` (` C6`) και ο δεύτερος είναι η κορυφή του κλάδου που συγχωνεύεται «C4»).
Σε αυτήν την περίπτωση, θέλουμε να αναιρέσουμε όλες τις αλλαγές που εισήχθησαν με τη συγχώνευση στο γονικό # 2 (`C4`), διατηρώντας όλο το περιεχόμενο από τον γονέα # 1 (` C6`).

Η ιστορία με την αναστροφή commit εμφανίζεται ως εξής:

.History μετά το `git revert -m 1`
image :: images / undomerge-revert.png [Ιστορικό μετά από `git revert -m 1`.]

Η νέα δέσμη `^ M 'έχει ακριβώς το ίδιο περιεχόμενο με το` C6`, οπότε ξεκινώντας από εδώ είναι σαν να μην συνέβη ποτέ η συγχώνευση, εκτός από το γεγονός ότι οι υποβολές που τώρα δεν έχουν μεσολαβήσει εξακολουθούν να βρίσκονται στην ιστορία `HEAD`.
Το Git θα μπερδευτεί αν προσπαθήσουμε να συγχωνεύσουμε ξανά το θέμα στο master:

[πηγή, κονσόλα]
----
Θέμα συγχώνευσης $ git
Ήδη ενημερωμένη.
----

Δεν υπάρχει τίποτα στο `θέμα 'που δεν είναι ήδη προσβάσιμο από το` master`.
Τι είναι χειρότερο, αν προσθέσουμε εργασία στο `θέμα 'και συγχωνεύσουμε ξανά, το Git θα φέρει μόνο τις αλλαγές _since_ την αναστροφή συγχώνευση:

.Η ιστορία με μια κακή συγχώνευση
image :: images / undomerge-revert2.png [Ιστορία με κακή συγχώνευση.]

Ο καλύτερος τρόπος γύρω από αυτό είναι να μη επαναφέρουμε την αρχική συγχώνευση, αφού τώρα θέλουμε να φέρουμε τις αλλαγές που έχουν επανέλθει, * στη συνέχεια * δημιουργήστε μια νέα δέσμευση συγχώνευσης:

[πηγή, κονσόλα]
----
$ git επιστρέφει ^ M
[master 09f0126] Επαναφορά "Επαναφορά" Συγχώνευση κλάδο 'θέμα' ""
Θέμα συγχώνευσης $ git
----

.History μετά την επανασύνδεση μιας επαναφοράς συγχώνευσης
image :: images / undomerge-revert3.png [Ιστορικό μετά την επανασύνδεση μιας επαναφοράς συγχώνευσης.]

Σε αυτό το παράδειγμα, το `M` και το` ^ M` ακυρώνονται.
Το `^^ M` ουσιαστικά συγχωνεύεται στις αλλαγές από` C3` και `C4`, και` C8` συγχωνεύεται στις αλλαγές από `C7`, έτσι τώρα το` θέμα` συγχωνεύεται πλήρως.

==== Άλλοι τύποι συγχωνεύσεων

Μέχρι στιγμής καλύψαμε την κανονική συγχώνευση δύο κλάδων, τα οποία κανονικά αντιμετωπίζονται με τη λεγόμενη `` αναδρομική '' στρατηγική συγχώνευσης.
Υπάρχουν άλλοι τρόποι συγχώνευσης των κλάδων.
Ας καλύψουμε μερικά από αυτά γρήγορα.

===== Προτίμηση μας ή τους

Πρώτα απ 'όλα, υπάρχει ένα άλλο χρήσιμο πράγμα που μπορούμε να κάνουμε με το κανονικό `` αναδρομικό' 'τρόπο συγχώνευσης.
Έχουμε ήδη δει τις επιλογές `ignore-all-space` και 'ignore-space-change` που έχουν περάσει με` -X`, αλλά μπορούμε επίσης να πούμε στο Git να ευνοεί τη μία ή την άλλη πλευρά όταν βλέπει μια σύγκρουση.

Από προεπιλογή, όταν ο Git βλέπει μια σύγκρουση μεταξύ δύο συγχωνευμένων κλάδων, θα προσθέσει δείκτες σύγκλισης συγχώνευσης στον κώδικα μας και θα επισημάνει το αρχείο ως διένεξη και θα μας επιτρέψει να το επιλύσουμε.
Εάν προτιμάμε το Git να επιλέξει απλά μια συγκεκριμένη πλευρά και να αγνοήσει την άλλη πλευρά αντί να μας επιτρέψει να συγχωνεύσουμε με μη αυτόματο τρόπο τη σύγκρουση, μπορούμε να περάσουμε την εντολή `merge` είτε σε ένα `-Xours` είτε σε ένα `-Xtheirs`.

Εάν το Git το βλέπει αυτό, δεν θα προσθέσει δείκτες σύγκρουσης.
Τυχόν διαφορές που μπορούν να συγχωνευθούν, θα συγχωνευθούν.
Οποιεσδήποτε διαφορές που συγκρούονται, απλά θα επιλέξει την πλευρά που καθορίζουμε στο σύνολό της, συμπεριλαμβανομένων των δυαδικών αρχείων.

Εάν επιστρέψουμε στο παράδειγμα `hello world 'που χρησιμοποιήσαμε πριν, μπορούμε να δούμε ότι η συγχώνευση στον κλάδο μας προκαλεί συγκρούσεις.

[πηγή, κονσόλα]
----
$ git merge mundo
Αυτόματη συγχώνευση hello.rb
CONFLICT (περιεχόμενο): Συγχώνευση διενέξεων στο hello.rb
Επιλύθηκε 'hello.rb' με προηγούμενη ανάλυση.
Η αυτόματη συγχώνευση απέτυχε να διορθώσουμε τις συγκρούσεις και στη συνέχεια να υποβάλουμε το αποτέλεσμα.
----

Ωστόσο, αν το τρέχουμε με `-Xours` ή -XTheirs` δεν το κάνει.

[πηγή, κονσόλα]
----
$ git συγχώνευση -Xours mundo
Αυτόματη συγχώνευση hello.rb
Συγχώνευση από την «αναδρομική» στρατηγική.
 hello.rb | 2 + -
 test.sh | 2 ++
 2 αλλαγμένα αρχεία, 3 εισαγωγές (+), 1 διαγραφή (-)
 Δημιουργία λειτουργίας 100644 test.sh
----

Σε αυτή την περίπτωση, αντί να πάρει δείκτες σύγκρουσης στο αρχείο με `hello mundo 'στη μία πλευρά και` `hola world' 'από την άλλη, θα επιλέξει απλά` `hola world' '.
Ωστόσο, όλες οι άλλες μη-αντιφατικές αλλαγές σε αυτόν τον κλάδο συγχωνεύονται με επιτυχία.

Αυτή η επιλογή μπορεί επίσης να μεταβιβαστεί στην εντολή `git merge-file` που είδαμε νωρίτερα τρέχοντας κάτι σαν το` git merge-file --ours 'για μεμονωμένες συγχωνεύσεις αρχείων.

Εάν θέλουμε να κάνουμε κάτι τέτοιο αλλά δεν έχουμε προσπαθήσει να συγχωνεύσουμε τις αλλαγές από την άλλη πλευρά, υπάρχει μια πιο δρακόντεια επιλογή, η οποία είναι η `` ours '' merge _strategy_.
Αυτό είναι διαφορετικό από το `` μας '' recursive merge _option_.

Αυτό θα κάνει βασικά μια ψεύτικη συγχώνευση.

Θα καταγράψει μια νέα δέσμευση συγχώνευσης με τους δύο κλάδους ως γονείς, αλλά δεν θα εξετάσει καν τον κλάδο στον οποίο συγχωνευόμαστε.
Θα καταγράψει απλώς ως αποτέλεσμα της συγχώνευσης τον ακριβή κώδικα στον τρέχοντα κλάδο μας.

[πηγή, κονσόλα]
----
Η $ git συγχώνευση είναι η δική μας μνήμη
Συγχώνευση από τη στρατηγική μας.
$ git diff HEAD HEAD ~
$
----

Μπορούμε να δούμε ότι δεν υπάρχει διαφορά μεταξύ του κλάδου στο οποίο είχαμε και του αποτελέσματος της συγχώνευσης.

Αυτό μπορεί συχνά να είναι χρήσιμο να υπονομεύσει το Git να σκεφτεί ότι ένας κλάδος είναι ήδη συγχωνευμένος όταν κάνει συγχώνευση αργότερα.
Για παράδειγμα, ας πούμε ότι διακλάδασα από έναν κλάδο `` release '' και κάναμε κάποια εργασία σε αυτό που θα θελήσουμε να συγχωνεύσουμε ξανά τον κλάδο '' master '' σε κάποιο σημείο.
Εν τω μεταξύ, κάποια bugfix στο `` master '' πρέπει να επιστραφεί στον κλάδο `release '.
Μπορούμε να συγχωνεύσουμε τον κλάδο bugfix στον κλάδο `release 'και επίσης να συγχωνεύσουμε τον ίδιο κλάδο στον κλάδο` master` (ακόμα κι αν η λύση είναι ήδη εκεί) έτσι ώστε όταν συγχωνεύσουμε ξανά τον κλάδο `release' δεν υπάρχουν συγκρούσεις από τη διόρθωση σφαλμάτων.

περιλαμβάνουν :: subtree-merges.asc []






ΕΝΟΤΗΤΑ 7.9


ΕΝΟΤΗΤΑ 7.10
=== Debugging με το Git

[[_file_annotation]]
==== Σχόλιο αρχείου

[πηγή, κονσόλα]
----
$ git κατηγορεί -L 12,22 simplegit.rb
^ 4832fe2 (Scott Chacon 2008-03-15 10:31:28 -0700 12) εμφάνιση def (tree = 'master')
^ 4832fe2 (εντολή του Scott Chacon 2008-03-15 10:31:28 -0700 13) ("git show # {tree}")
^ 4832fe2 (Scott Chacon 2008-03-15 10:31:28 -0700 14) τέλος
^ 4832fe2 (Σκοτ Chacon 2008-03-15 10:31:28 -0700 15)
9f6560e4 (Scott Chacon 2008-03-17 21:52:20 -0700 16) def log (tree = 'master')
79eaf55d (εντολή του Scott Chacon 2008-04-06 10:15:08 -0700 17) ("git log # {tree}")
9f6560e4 (Scott Chacon 2008-03-17 21:52:20 -0700 18) τέλος
9f6560e4 (Σκοτ Chacon 2008-03-17 21:52:20 -0700 19)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20) def φταίει (διαδρομή)
42cf2861 (εντολή Magnus Chacon 2008-04-13 10:45:01 -0700 21) ("git blame # {path}")
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22) τέλος
----

[πηγή, κονσόλα]
----
$ git κατηγορεί -C -L 141,153 GITPackUpload.m
f344f58d GITServerHandler.m (Scott 2009-01-04 141)
f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (κενό) collectObjectShasFromC
f344f58d GITServerHandler.m (Scott 2009-01-04 143) {
70befddd GITServerHandler.m (Scott 2009-03-22 144) // NSLog (@ "GATHER COMMI
ad11ac80 GITPackUpload.m (Scott 2009-03-24 145)
ad11ac80 GITPackUpload.m (Scott 2009-03-24 146) NSString * parentSha;
ad11ac80 GITPackUpload.m (Scott 2009-03-24 147) GITCommit * δέσμευση = [g
ad11ac80 GITPackUpload.m (Scott 2009-03-24 148)
ad11ac80 GITPackUpload.m (Scott 2009-03-24 149) // NSLog (@ "GATHER COMMI
ad11ac80 GITPackUpload.m (Scott 2009-03-24 150)
56ef2caf GITServerHandler.m (Scott 2009-01-05 151) if (δέσμευση) {
56ef2caf GITServerHandler.m (Scott 2009-01-05 152) [refDict setOb
56ef2caf GITServerHandler.m (Scott 2009-01-05 153)
----


[πηγή, κονσόλα]
----
$ git bisect καλή
Διευκόλυνση: Έχουν απομείνει 3 αναθεωρήσεις μετά από αυτό
[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] ασφαλίστε αυτό το πράγμα
----

[πηγή, κονσόλα]
----
$ git bisect κακό
Διευκόλυνση: 1 αναθεωρήσεις αριστερά για να δοκιμαστεί μετά από αυτό
[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] Πίνακας εξαιρέσεων
----

[πηγή, κονσόλα]
----
$ git bisect καλή
b047b02ea83310a70fd603dc8cd7a6cd13d15c04 είναι πρώτα άσχημα
commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04
Συντάκτης: PJ Hyett <pjhyett@example.com>
Ημερομηνία: Τρι Ιαν 27 14:48:32 2009 -0800

    ασφαλίστε αυτό το πράγμα

: 040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730
f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M config
----

[πηγή, κονσόλα]
----
$ git bisect ξεκινήστε το HEAD v1.0
$ git bisect εκτελέσουμε test-error.sh
----








ΕΝΟΤΗΤΑ 7.11

[[_git_submodules]]
=== Υπομονάδες

Συχνά συμβαίνει ότι ενώ εργαζόμαστε σε ένα έργο, θα πρέπει να χρησιμοποιήσουμε ένα άλλο έργο μέσα από αυτό.
Ίσως πρόκειται για μια βιβλιοθήκη που έχει αναπτυχθεί από ένα τρίτο μέρος ή ότι αναπτύσσεται ξεχωριστά και χρησιμοποιείται σε πολλά γονικά έργα.
Ένα κοινό ζήτημα προκύπτει σε αυτά τα σενάρια: θέλουμε να είμαστε σε θέση να αντιμετωπίζουμε τα δύο έργα ως ξεχωριστά αλλά ακόμα να μπορούμε να τα χρησιμοποιούμε μέσα από το άλλο.

Ακολουθεί ένα παράδειγμα.
Ας υποθέσουμε ότι αναπτύσσουμε έναν ιστότοπο και δημιουργούμε ροές Atom.
Αντί να γράφουμε τον δικό μας κώδικα δημιουργίας ατμόσφαιρας, αποφασίζουμε να χρησιμοποιήσουμε μια βιβλιοθήκη.
Είναι πιθανό να πρέπει να συμπεριλάβουμε αυτόν τον κώδικα από μια κοινόχρηστη βιβλιοθήκη όπως μια εγκατάσταση CPAN ή Ruby gem ή να αντιγράψουμε τον πηγαίο κώδικα στο δικό μας δέντρο έργου.
Το πρόβλημα με τη συμπερίληψη της βιβλιοθήκης είναι ότι είναι δύσκολο να προσαρμόσουμε τη βιβλιοθήκη με οποιονδήποτε τρόπο και συχνά πιο δύσκολο να την αναπτύξουμε, επειδή πρέπει να βεβαιωθούμε ότι κάθε πελάτης διαθέτει αυτή τη βιβλιοθήκη.
Το ζήτημα με την παράδοση του κώδικα στο δικό μας έργο είναι ότι τυχόν προσαρμοσμένες αλλαγές που κάνουμε είναι δύσκολο να συγχωνευθούν όταν είναι διαθέσιμες οι μεταγενέστερες αλλαγές.

Το Git αντιμετωπίζει αυτό το πρόβλημα χρησιμοποιώντας υπομονάδες.
Τα υπομονάδες μας επιτρέπουν να διατηρούμε ένα αποθετήριο Git ως υποκατάλογο άλλης αποθήκης Git.
Αυτό μας επιτρέπει να κλωνοποιήσουμε ένα άλλο αποθετήριο στο έργο μας και να κρατήσουμε ξεχωριστές τις υποβολές μας.

[[_αρχικό_διακίνηση]]
==== Ξεκινώντας με υπομονάδες

Θα ξεπεράσουμε την ανάπτυξη ενός απλού έργου που έχει χωριστεί σε ένα κύριο έργο και σε μερικά υπο-έργα.

Ας αρχίσουμε προσθέτοντας ένα υπάρχον αποθετήριο Git ως υπομονάδα του repository στο οποίο εργαζόμαστε.
Για να προσθέσουμε ένα νέο υπομονάδα χρησιμοποιούμε την εντολή `git submodule add` με την απόλυτη ή σχετική διεύθυνση URL του έργου που θέλουμε να αρχίσουμε να παρακολουθούμε.
Σε αυτό το παράδειγμα, θα προσθέσουμε μια βιβλιοθήκη που ονομάζεται `` DbConnector ''.

[πηγή, κονσόλα]
----
Το $ git submodule προσθέτει https://github.com/chaconinc/DbConnector
Κλωνοποίηση σε 'DbConnector' ...
απομακρυσμένο: Μετρώντας τα αντικείμενα: 11, τελειωμένο.
απομακρυσμένη: Συμπίεση αντικειμένων: 100% (10/10), τελείωσε.
απομακρυσμένη: Σύνολο 11 (δέλτα 0), επαναχρησιμοποίηση 11 (δέλτα 0)
Αποσυμπιέστε αντικείμενα: 100% (11/11), τελείωσε.
Έλεγχος συνδεσιμότητας ... γίνεται.
----

Από προεπιλογή, τα υπομονάδες θα προσθέσουν το υποέργο σε έναν κατάλογο που ονομάζεται το ίδιο με τον αποθετήριο, στην περίπτωση αυτή `` DbConnector ''.
Μπορούμε να προσθέσουμε μια διαφορετική διαδρομή στο τέλος της εντολής, εάν θέλουμε να πάει αλλού.

Εάν εκτελούμε την κατάσταση git σε αυτό το σημείο, θα παρατηρήσουμε μερικά πράγματα.

[πηγή, κονσόλα]
----
$ git status
Στον κύριο κλάδο
Το υποκατάστημά μας είναι ενημερωμένο με τον όρο "προέλευση / κύριο".

Αλλαγές που πρέπει να γίνουν:
  (χρησιμοποιήστε το "git reset HEAD <αρχείο> ..." σε unstage)

νέο αρχείο: .gitmodules
νέο αρχείο: DbConnector
----

Πρώτα θα πρέπει να παρατηρήσουμε το νέο αρχείο .gitmodules.
Αυτό είναι ένα αρχείο διαμόρφωσης που αποθηκεύει τη χαρτογράφηση μεταξύ της διεύθυνσης URL του έργου και του τοπικού κλάδου που τον έχουμε τραβήξει σε:

[πηγή, κονσόλα]
----
$ cat .gitmodules
[υπομονάδα "DbConnector"]
path = DbConnector
url = https://github.com/chaconinc/DbConnector
----

Εάν έχουμε πολλά υπομονάδες, θα έχουμε πολλαπλές καταχωρήσεις σε αυτό το αρχείο.
Είναι σημαντικό να σημειωθεί ότι αυτό το αρχείο είναι ελεγχόμενο από την έκδοση με τα άλλα αρχεία μας, όπως το αρχείο .gitignore.
Είναι ώθησε και τράβηξε με το υπόλοιπο του έργου μας.
Αυτός είναι ο τρόπος με τον οποίο οι άλλοι άνθρωποι που κλωνοποιούν αυτό το έργο γνωρίζουν από πού να πάρουν τα έργα υπομπόλων από.

[ΣΗΜΕΙΩΣΗ]
=====
Δεδομένου ότι η διεύθυνση URL στο αρχείο .gitmodules είναι αυτό που θα προσπαθήσουν πρώτα να κλωνοποιήσουν / προσελκύσουν άλλοι χρήστες, βεβαιωθούμε ότι χρησιμοποιούμε μια διεύθυνση URL που μπορούν να έχουν πρόσβαση εάν είναι δυνατόν.
Για παράδειγμα, αν χρησιμοποιούμε διαφορετική διεύθυνση URL για να πιέσουμε από ό, τι θα έπρεπε να τραβήξουν οι άλλοι, χρησιμοποιήστε αυτήν που έχουν πρόσβαση άλλοι.
Μπορούμε να αντικαταστήσουμε αυτή την τιμή τοπικά με το `git config submodule.DbConnector.url PRIVATE_URL` για δική μας χρήση.
Όταν ισχύει, μια σχετική διεύθυνση URL μπορεί να είναι χρήσιμη.
=====

Η άλλη λίστα στην έξοδο `git status 'είναι η καταχώρηση του φακέλου του έργου.
Εάν εκτελέσουμε το `git diff`, βλέπουμε κάτι ενδιαφέρον:

[πηγή, κονσόλα]
----
$ git diff -cached DbConnector
diff - git a / DbConnector b / DbConnector
νέα λειτουργία αρχείου 160000
δείκτης 0000000..c3f01dc
--- / dev / null
+++ β / DbConnector
@@ -0,0 +1 @@
+ Υποέργο commit c3f01dc8862123d317dd46284b05b6892c7b29bc
----

Αν και ο `DbConnector` είναι ένας υποκατάλογος στον κατάλογο εργασίας μας, το Git το βλέπει ως υπομονάδα και δεν παρακολουθεί τα περιεχόμενά του όταν δεν βρισκόμαστε στον κατάλογο.
Αντ 'αυτού, το Git το θεωρεί ως μια ιδιαίτερη δέσμευση από αυτόν τον αποθετήριο.

Αν θέλουμε λίγο πιο έξυπνη έξοδο diff, μπορούμε να περάσουμε την επιλογή `- submodule` στο` git diff`.

[πηγή, κονσόλα]
----
$ git diff -cached -submodule
diff - git a / .gitmodules b / .gmodmodules
νέος τρόπος αρχείου 100644
δείκτης 0000000..71fc376
--- / dev / null
+++ b / .gmodmodules
@@ -0,0 +1,3 @@
+ [υπομονάδα "DbConnector"]
+ διαδρομή = DbConnector
+ url = https://github.com/chaconinc/DbConnector
Υποσύνολο DbConnector 0000000 ... c3f01dc (νέος υπομοντέλος)
----

Όταν διαπράττουμε, βλέπουμε κάτι τέτοιο:

[πηγή, κονσόλα]
----
Το $ git commit -am 'πρόσθεσε την ενότητα DbConnector'
[master fb9093c] πρόσθεσε την ενότητα DbConnector
 2 αρχεία άλλαξαν, 4 παρενθέσεις
Δημιουργία λειτουργίας 100644 .gitmodules
 δημιουργήστε τη λειτουργία 160000 DbConnector
----

Παρατηρήστε τη λειτουργία `160000` για την καταχώρηση` DbConnector`.
Αυτή είναι μια ειδική λειτουργία στο Git που ουσιαστικά σημαίνει ότι καταγράφουμε μια δέσμευση ως καταχώρηση καταλόγου και όχι ως υποκατάλογο ή αρχείο.

[[_cloning_submodules]]
==== Κλωνοποίηση έργου με υπομονάδες

Εδώ θα κλωνοποιήσουμε ένα έργο με ένα υπομπόριο σε αυτό.
Όταν κλωνοποιούμε ένα τέτοιο έργο, από προεπιλογή εμφανίζονται οι κατάλογοι που περιέχουν υπομονάδες, αλλά κανένα από τα αρχεία μέσα σε αυτά ακόμα:

[πηγή, κονσόλα]
----
$ git clone https://github.com/chaconinc/MainProject
Κλωνοποίηση σε 'MainProject' ...
απομακρυσμένη: Μετρώντας τα αντικείμενα: 14, τελείωσε.
απομακρυσμένη: Συμπίεση αντικειμένων: 100% (13/13), τελείωσε.
απομακρυσμένη: Σύνολο 14 (δέλτα 1), επαναχρησιμοποίηση 13 (δέλτα 0)
Αποσυμπιέστε αντικείμενα: 100% (14/14), τελείωσε.
Έλεγχος συνδεσιμότητας ... γίνεται.
$ cd MainProject
$ ls -la
σύνολο 16
drwxr-xr-x 9 Σκάνων προσωπικό 306 Σεπ 17 15:21.
drwxr-xr-x 7 μέλη του προσωπικού schakon 238 Σεπ 17 15:21 ..
drwxr-xr-x 13 προσωπικό σκάνων 442 Σεπ 17 15:21 .git
-rw-r-r-- 1 σχacon προσωπικό 92 Σεπ 17 15:21 .gitmodules
drwxr-xr-x 2 Προσωπικό σκάνων 68 Σεπ 17 15:21 DbConnector
-rw-r-r-- 1 staff schacon 756 Σεπ 17 15:21 Makefile
drwxr-xr-x 3 προσωπικό σκάνων 102 Σεπ 17 15:21 περιλαμβάνει
drwxr-xr-x 4 Προσωπικό σκάνων 136 Σεπ 17 15:21 σενάρια
drwxr-xr-x 4 Προσωπικό σκάνων 136 Σεπ 17 15:21 src
$ cd DbConnector /
$ ls
$
----

Ο κατάλογος `DbConnector` είναι εκεί, αλλά κενός.
Πρέπει να εκτελέσουμε δύο εντολές: `git submodule init` για την αρχικοποίηση του τοπικού μας αρχείου ρυθμίσεων και` git update submodule` για να συγκεντρώσει όλα τα δεδομένα από το έργο και να ελέγξει την κατάλληλη δέσμευση που αναφέρεται στο superproject μας:

[πηγή, κονσόλα]
----
$ git submodule init
Υπομονάδα 'DbConnector' (https://github.com/chaconinc/DbConnector) καταχωρημένο για τη διαδρομή 'DbConnector'
$ git ενημέρωση υποσυστήματος
Κλωνοποίηση σε 'DbConnector' ...
απομακρυσμένο: Μετρώντας τα αντικείμενα: 11, τελειωμένο.
απομακρυσμένη: Συμπίεση αντικειμένων: 100% (10/10), τελείωσε.
απομακρυσμένη: Σύνολο 11 (δέλτα 0), επαναχρησιμοποίηση 11 (δέλτα 0)
Αποσυμπιέστε αντικείμενα: 100% (11/11), τελείωσε.
Έλεγχος συνδεσιμότητας ... γίνεται.
Διαδρομή υποσύνδεσης 'DbConnector': Έλεγχος 'c3f01dc8862123d317dd46284b05b6892c7b29bc'
----

Τώρα ο υποκατάλογος `DbConnector` μας βρίσκεται στην ακριβή κατάσταση που ήταν όταν υποβάλλαμε νωρίτερα.

Υπάρχει ένας άλλος τρόπος για να γίνει αυτό, το οποίο όμως είναι λίγο πιο απλό.
Αν περάσουμε `--recursive` στην εντολή` git clone`, αυτόματα θα προετοιμάσει και θα ενημερώσει κάθε υπομόνιο στο αποθετήριο.

[πηγή, κονσόλα]
----
$ git clone - αναδρομική https://github.com/chaconinc/MainProject
Κλωνοποίηση σε 'MainProject' ...
απομακρυσμένη: Μετρώντας τα αντικείμενα: 14, τελείωσε.
απομακρυσμένη: Συμπίεση αντικειμένων: 100% (13/13), τελείωσε.
απομακρυσμένη: Σύνολο 14 (δέλτα 1), επαναχρησιμοποίηση 13 (δέλτα 0)
Αποσυμπιέστε αντικείμενα: 100% (14/14), τελείωσε.
Έλεγχος συνδεσιμότητας ... γίνεται.
Υπομονάδα 'DbConnector' (https://github.com/chaconinc/DbConnector) καταχωρημένο για τη διαδρομή 'DbConnector'
Κλωνοποίηση σε 'DbConnector' ...
απομακρυσμένο: Μετρώντας τα αντικείμενα: 11, τελειωμένο.
απομακρυσμένη: Συμπίεση αντικειμένων: 100% (10/10), τελείωσε.
απομακρυσμένη: Σύνολο 11 (δέλτα 0), επαναχρησιμοποίηση 11 (δέλτα 0)
Αποσυμπιέστε αντικείμενα: 100% (11/11), τελείωσε.
Έλεγχος συνδεσιμότητας ... γίνεται.
Διαδρομή υποσύνδεσης 'DbConnector': Έλεγχος 'c3f01dc8862123d317dd46284b05b6892c7b29bc'
----

==== Εργασία σε ένα έργο με υπομονάδες

Τώρα έχουμε ένα αντίγραφο ενός έργου με υπομονάδες σε αυτό και θα συνεργαστούμε με τους συμπαίκτες μας τόσο για το κύριο έργο όσο και για το υποσύνολο έργου.

===== Τραβήξτε τις μεταγενέστερες αλλαγές

Το απλούστερο μοντέλο χρήσης υπομονάδων σε ένα έργο θα ήταν αν καταναλώνουμε απλά ένα υποέργο και ήθελα να λαμβάνουμε ενημερώσεις από αυτό κατά καιρούς αλλά δεν τροποποιούσαμε τίποτα στην παραγγελία μας.
Ας περάσουμε από ένα απλό παράδειγμα εκεί.

Αν θέλουμε να ελέγξουμε για νέα εργασία σε υπομονάδα, μπορούμε να μεταβούμε στον κατάλογο και να εκτελέσουμε `git fetch` και` git merge 'για να ενημερώσουμε τον τοπικό κώδικα.

[πηγή, κονσόλα]
----
$ git fetch
Από τη διεύθυνση https://github.com/chaconinc/DbConnector
   c3f01dc..d0354fc master -> προέλευση / κύριο
$ git συγχώνευση προέλευσης / κύριος
Ενημέρωση c3f01dc..d0354fc
Γρήγορη προώθηση
 scripts / connect.sh | 1 +
 src / db.c | 1 +
 2 αρχεία άλλαξαν, 2 εισαγωγές (+)
----

Τώρα, αν επιστρέψουμε στο κύριο έργο και εκτελέσουμε το `git diff --submodule`, μπορούμε να δούμε ότι το υπομοντέλο ενημερώθηκε και να πάρουμε μια λίστα υποβολών που προστέθηκαν σε αυτό.
Εάν δεν θέλουμε να πληκτρολογούμε `--submodule` κάθε φορά που τρέχουμε το` git diff`, μπορούμε να το ορίσουμε ως προεπιλεγμένη μορφή ρυθμίζοντας την τιμή config του `diff.submodule` στο` `log ''.

[πηγή, κονσόλα]
----
$ git config - αρχείο συνολικού διαφορικού
$ git diff
Υπομονάδα DbConnector c3f01dc..d0354fc:
  > πιο αποτελεσματική ρουτίνα db
  > καλύτερη ρουτίνα σύνδεσης
----

Εάν υποβάλλούμε σε αυτό το σημείο τότε θα κλειδώσουμε το υπομοντέλο να έχει τον νέο κώδικα όταν ενημερώνονται άλλοι άνθρωποι.

Υπάρχει ένας ευκολότερος τρόπος για να γίνει αυτό επίσης, αν προτιμάμε να μην φέρουμε και να συγχωνεύσουμε με μη αυτόματο τρόπο τον υποκατάλογο.
Εάν εκτελέσουμε την `git update submodule --remote ', το Git θα μεταβεί στα submodules μας και θα φέρω και θα ενημερώσει για εσάς.

[πηγή, κονσόλα]
----
Ενημέρωση υπομονάδας $ git --remote DbConnector
απομακρυσμένη: Καταμέτρηση αντικειμένων: 4, τελείωσε.
απομακρυσμένη: Συμπίεση αντικειμένων: 100% (2/2), τελείωσε.
απομακρυσμένη: Σύνολο 4 (δέλτα 2), επαναχρησιμοποίηση 4 (δέλτα 2)
Αποσυμπιέστε αντικείμενα: 100% (4/4), τελείωσε.
Από τη διεύθυνση https://github.com/chaconinc/DbConnector
   3f19983..d0354fc master -> προέλευση / κύριο
Διαδρομή υπομπόρου 'DbConnector': Έλεγχος 'd0354fc054692d3906c85c3af05ddce39a1c0644'
----

Αυτή η εντολή θα υποθέσει από προεπιλογή ότι θέλουμε να ενημερώσουμε το checkout στον κλάδο `master` του αποθετηρίου υπομπόλων.
Ωστόσο, μπορούμε να ορίσουμε κάτι διαφορετικό αν θέλουμε.
Για παράδειγμα, εάν θέλουμε να παρακολουθήσουμε τον υπομονάδα DbConnector στον κλάδο `` stable '' του αποθετηρίου, μπορούμε να τον ορίσουμε είτε στο αρχείο .gitmodules, είτε στο τοπικό `.git / config`.
Ας το ορίσουμε στο αρχείο `.gitmodules`:

[πηγή, κονσόλα]
----
$ git config -f .gitmodules submodule.DbConnector.branch σταθερό

Ανανέωση υπομονάδας $ git --remote
απομακρυσμένη: Καταμέτρηση αντικειμένων: 4, τελείωσε.
απομακρυσμένη: Συμπίεση αντικειμένων: 100% (2/2), τελείωσε.
απομακρυσμένη: Σύνολο 4 (δέλτα 2), επαναχρησιμοποίηση 4 (δέλτα 2)
Αποσυμπιέστε αντικείμενα: 100% (4/4), τελείωσε.
Από τη διεύθυνση https://github.com/chaconinc/DbConnector
   27cf5d3..c87d55d σταθερή -> προέλευση / σταθερή
Διαδρομή υποστοιχείωσης 'DbConnector': Έλεγχος έξω 'c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687'
----

Αν αφήσουμε τα `-f .gmodmodules ', θα κάνει μόνο την αλλαγή για μας, αλλά πιθανότατα είναι πιο λογικό να παρακολουθούμε αυτές τις πληροφορίες με το χώρο αποθήκευσης έτσι ώστε όλοι οι άλλοι να το κάνουν.

Όταν τρέχουμε `git status 'σε αυτό το σημείο, το Git θα μας δείξει ότι έχουμε` `νέα υποβολές' 'στο submodule.

[πηγή, κονσόλα]
----
$ git status
Στον κύριο κλάδο
Το υποκατάστημά μας είναι ενημερωμένο με τον όρο "προέλευση / κύριο".

Αλλαγές που δεν έχουν διοργανωθεί για διεκπεραίωση:
  (χρησιμοποιήστε το "git add <file> ..." για να ενημερώσουμε τι θα υποβληθεί)
  (χρησιμοποιήστε το "git checkout - <αρχείο> ..." για να απορρίψουμε τις αλλαγές στον κατάλογο εργασίας)

  τροποποιημένα: .gitmodules
  τροποποιημένο: DbConnector (νέες υποβολές)

δεν έχουν προστεθεί αλλαγές στο commit (χρησιμοποιήστε το "git add" και / ή "git commit -a")
----

Εάν ορίσουμε τη ρύθμιση διαμόρφωσης "status.submodulesummary", το Git θα μας δείξει επίσης μια σύντομη περίληψη των αλλαγών στα υπομονάδα μας:

[πηγή, κονσόλα]
----
$ git status.submodulesummary 1

$ git status
Στον κύριο κλάδο
Το υποκατάστημά μας είναι ενημερωμένο με τον όρο "προέλευση / κύριο".

Αλλαγές που δεν έχουν διοργανωθεί για διεκπεραίωση:
  (χρησιμοποιήστε το "git add <file> ..." για να ενημερώσουμε τι θα υποβληθεί)
  (χρησιμοποιήστε το "git checkout - <αρχείο> ..." για να απορρίψουμε τις αλλαγές στον κατάλογο εργασίας)

τροποποιημένα: .gitmodules
τροποποιημένο: DbConnector (νέες υποβολές)

Τα submodules άλλαξαν αλλά δεν ενημερώθηκαν:

* DbConnector c3f01dc ... c87d55d (4):
  > να πιάσει μη τερματισμένες γραμμές
----

Σε αυτό το σημείο, αν εκτελέσουμε το `git diff`, μπορούμε να δούμε και ότι έχουμε τροποποιήσει το αρχείο` .gitmodules` και επίσης ότι υπάρχουν αρκετοί δεσμοί που έχουμε τραβήξει προς τα κάτω και είμαστε έτοιμοι να υποβάλλούμε για το υποσύνολο του έργου μας.

[πηγή, κονσόλα]
----
$ git diff
diff - git a / .gitmodules b / .gmodmodules
ευρετήριο 6fc0b3d..fd1cc29 100644
--- a / .gmodmodules
+++ b / .gmodmodules
@@ -1,3 +1,4 @@
 [υπομονάδα "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+ κλάδο = σταθερό
 Υπομονάδα DbConnector c3f01dc..c87d55d:
  > να πιάσει μη τερματισμένες γραμμές
  > πιο ισχυρό χειρισμό σφαλμάτων
  > πιο αποτελεσματική ρουτίνα db
  > καλύτερη ρουτίνα σύνδεσης
----

Αυτό είναι πολύ δροσερό, καθώς μπορούμε πραγματικά να δούμε το ημερολόγιο υποβολών που πρόκειται να υποβάλλούμε στο submodule μας.
Αφού υποβληθεί, μπορούμε να δούμε αυτές τις πληροφορίες και μετά το γεγονός όταν τρέχουμε το `git log -p`.

[πηγή, κονσόλα]
----
$ git log -p - υπομονάδα
commit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7ae
Συντάκτης: Scott Chacon <schacon@gmail.com>
Ημερομηνία: Τετ 17 Σεπτεμβρίου 16:37:02 2014 +0200

    ενημερώνοντας το DbConnector για διορθώσεις σφαλμάτων

diff - git a / .gitmodules b / .gmodmodules
ευρετήριο 6fc0b3d..fd1cc29 100644
--- a / .gmodmodules
+++ b / .gmodmodules
@@ -1,3 +1,4 @@
 [υπομονάδα "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+ κλάδο = σταθερό
Υπομονάδα DbConnector c3f01dc..c87d55d:
  > να πιάσει μη τερματισμένες γραμμές
  > πιο ισχυρό χειρισμό σφαλμάτων
  > πιο αποτελεσματική ρουτίνα db
  > καλύτερη ρουτίνα σύνδεσης
----

Το Git θα προσπαθήσει από προεπιλογή να ενημερώσει ** όλα τα ** υπομονάδα μας όταν τρέχουμε την `git update submodule --remote ', οπότε αν έχουμε πολλά από αυτά, ίσως θέλουμε να περάσουμε το όνομα μόνο του υποσυστήματος που θέλουμε να δοκιμάσουμε για ενημέρωση.

===== Εργασία σε υπομονάδα

Είναι πολύ πιθανό ότι αν χρησιμοποιούμε υπομονάδες, το κάνουμε επειδή θέλουμε πραγματικά να εργαστούμε στον κώδικα στο υποσύνολο ταυτόχρονα με την εργασία μας στον κώδικα στο κύριο έργο (ή σε πολλά υπομονάδες) .
Διαφορετικά, πιθανότατα θα χρησιμοποιούσαμε ένα απλούστερο σύστημα διαχείρισης εξάρτησης (όπως Maven ή Rubygems).

Τώρα, λοιπόν, να δούμε ένα παράδειγμα να κάνουμε αλλαγές στο υποσύνολο ταυτόχρονα με το κύριο έργο και να υποβάλλουμε και να δημοσιεύουμε αυτές τις αλλαγές ταυτόχρονα.

Μέχρι στιγμής, όταν έχουμε εκτελέσει την εντολή `update submodule git 'για να μεταφέρει τις αλλαγές από τα αποθετήρια υπομονάδων, ο Git θα πάρει τις αλλαγές και θα ενημερώσει τα αρχεία στον υποκατάλογο, αλλά θα αφήσει το sub-repository σε αυτό που ονομάζεται` `detached HEAD '' κατάσταση.
Αυτό σημαίνει ότι δεν υπάρχει τοπικός κλάδος εργασίας (όπως το `` master '', για παράδειγμα) παρακολούθηση αλλαγών.
Επομένως, οι αλλαγές που κάνουμε δεν παρακολουθούνται καλά.

Προκειμένου να ρυθμίσουμε το υπομονάδα μας ώστε να είναι ευκολότερο να εισέλθουμε και να ακουμπάτε, πρέπει να κάνουμε δύο πράγματα.
Πρέπει να πάμε σε κάθε υπομοντέλο και να δούμε έναν κλάδο για να εργαστούμε.
Στη συνέχεια, πρέπει να πούμε στο Git τι πρέπει να κάνουμε αν έχουμε κάνει αλλαγές και στη συνέχεια `git update submodule --remote 'τραβάει νέα εργασία από την ανάντη.
Οι επιλογές είναι ότι μπορούμε να τις συγχωνεύσουμε στην τοπική δουλειά μας ή μπορούμε να δοκιμάσουμε να αναδιοργανώσουμε την τοπική εργασία μας πάνω από τις νέες αλλαγές.

Πρώτα απ 'όλα, ας πάμε στον κατάλογο υποσυστήματός μας και να δούμε έναν κλάδο.

[πηγή, κονσόλα]
----
$ git checkout σταθερό
Έχει μετατραπεί σε κλάδο 'σταθερό'
----

Ας το δοκιμάσουμε με την επιλογή `` συγχώνευση ''.
Για να το καθορίσουμε με το χέρι, μπορούμε απλά να προσθέσουμε την επιλογή `-merge` στην κλήση` update '.
Εδώ θα δούμε ότι υπήρξε μια αλλαγή στον εξυπηρετητή για αυτό το υποσύνολο και γίνεται συγχώνευση.

[πηγή, κονσόλα]
----
Ανανέωση υπομονάδας $ git --remote --merge
απομακρυσμένη: Καταμέτρηση αντικειμένων: 4, τελείωσε.
απομακρυσμένη: Συμπίεση αντικειμένων: 100% (2/2), τελείωσε.
απομακρυσμένη: Σύνολο 4 (δέλτα 2), επαναχρησιμοποίηση 4 (δέλτα 2)
Αποσυμπιέστε αντικείμενα: 100% (4/4), τελείωσε.
Από τη διεύθυνση https://github.com/chaconinc/DbConnector
   c87d55d..92c7337 σταθερό -> προέλευση / σταθερό
Ενημέρωση c87d55d..92c7337
Γρήγορη προώθηση
 src / main.c | 1 +
 1 αρχείο άλλαξε, 1 εισαγωγή (+)
Διαδρομή υποστοιχείωσης 'DbConnector': συγχωνεύθηκε στο '92c7337b30ef9e0893e758dac2459d07362ab5ea'
----

Εάν εισέλθουμε στον κατάλογο DbConnector, έχουμε τις νέες αλλαγές που έχουν ήδη συγχωνευθεί στον τοπικό κλάδο `stable`.
Τώρα ας δούμε τι συμβαίνει όταν κάνουμε τη δική μας τοπική αλλαγή στη βιβλιοθήκη και κάποιος άλλος προωθεί μια άλλη αλλαγή ανάντη την ίδια στιγμή.

[πηγή, κονσόλα]
----
$ cd DbConnector /
$ vim src / db.c
$ git commit -am 'υποστήριξη unicode'
[σταθερή f906e16] υποστήριξη unicode
 1 αρχείο άλλαξε, 1 εισαγωγή (+)
----

Τώρα, αν ενημερώσουμε το υποσύνολο μας, μπορούμε να δούμε τι συμβαίνει όταν έχουμε κάνει μια τοπική αλλαγή και ανάντη έχει επίσης μια αλλαγή που πρέπει να ενσωματώσουμε.

[πηγή, κονσόλα]
----
Ανανέωση υπομονάδας $ git --remote --rebase
Αρχικά, επανατοποθετήστε το κεφάλι για να επαναλάβουμε την εργασία μας πάνω από το ...
Εφαρμογή: υποστήριξη unicode
Διαδρομή υποστοιχείωσης 'DbConnector': επαναδιατυπώθηκε σε '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'
----

Εάν ξεχάσουμε το `--rebase` ή το` --merge`, το Git θα ενημερώσει μόνο το υπομοντέλο σε ό, τι βρίσκεται στο διακομιστή και θα επαναφέρει το έργο μας σε αποσπασμένη κατάσταση HEAD.

[πηγή, κονσόλα]
----
Ανανέωση υπομονάδας $ git --remote
Διαδρομή υποσύνδεσης 'DbConnector': Έγγραφο '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'
----

Αν συμβεί κάτι τέτοιο, μην ανησυχούμε, μπορούμε απλά να επιστρέψουμε στον κατάλογο και να ελέγξουμε ξανά τον κλάδο μας (το οποίο θα εξακολουθεί να περιέχει την εργασία μας) και να συγχωνεύσουμε ή να επαναφέρουμε την "προέλευση / σταθερή" (ή ό,τι απομακρυσμένο κλάδο θέλετε) χειροκίνητα.

Αν δεν έχουμε αναλάβει τις αλλαγές στο υπομοντέλο μας και εκτελέσουμε μια ενημέρωση υποσυστήματος που θα μπορούσε να προκαλέσει προβλήματα, το Git θα ανακτήσει τις αλλαγές αλλά δεν θα αντικαταστήσει τη μη αποθηκευμένη εργασία στον κατάλογο υπομονάδων μας.

[πηγή, κονσόλα]
----
Ανανέωση υπομονάδας $ git --remote
απομακρυσμένη: Καταμέτρηση αντικειμένων: 4, τελείωσε.
απομακρυσμένη: Συμπίεση αντικειμένων: 100% (3/3), τελείωσε.
απομακρυσμένη: Σύνολο 4 (δέλτα 0), επαναχρησιμοποίηση 4 (δέλτα 0)
Αποσυμπιέστε αντικείμενα: 100% (4/4), τελείωσε.
Από τη διεύθυνση https://github.com/chaconinc/DbConnector
   5d60ef9..c75e92a σταθερό -> προέλευση / σταθερό
σφάλμα: Οι τοπικές αλλαγές στα παρακάτω αρχεία θα αντικατασταθούν από το checkout:
scripts / setup.sh
Παρακαλούμε, υποβάλλ τις αλλαγές μας ή τις αποθηκεύσουμε για να μπορέσουμε να αλλάξουμε κλάδους.
Ακύρωση
Δεν είναι δυνατή η ολοκλήρωση του ελέγχου 'c75e92a2b3855c9e5b66f915308390d9db204aca' στη διαδρομή υποτροπών 'DbConnector'
----

Εάν κάναμε αλλαγές που έρχονται σε αντίθεση με κάτι που άλλαξε upstream, το Git θα μας ενημερώσει όταν εκτελούμε την ενημέρωση.

[πηγή, κονσόλα]
----
Ανανέωση υπομονάδας $ git --remote --merge
Αυτόματα συγχώνευση σεναρίων / setup.sh
CONFLICT (περιεχόμενο): Συγχώνευση διενέξεων σε σενάρια / setup.sh
Εγγραφή προεπισκόπησης για 'scripts / setup.sh'
Η αυτόματη συγχώνευση απέτυχε να διορθώσουμε τις συγκρούσεις και στη συνέχεια να υποβάλλουμε το αποτέλεσμα.
Δεν είναι δυνατή η συγχώνευση του 'c75e92a2b3855c9e5b66f915308390d9db204aca' στη διαδρομή υποτροπών 'DbConnector'
----

Μπορούμε να μεταβούμε στον κατάλογο υπομονάδων και να διορθώσουμε τη σύγκρουση όπως θα κάναμε κανονικά.

[[_publishing_submodules]]
===== Δημοσίευση αλλαγών σε υπομονάδες

Τώρα έχουμε κάποιες αλλαγές στον κατάλογο υπομπόδων μας.
Ορισμένα από αυτά εισήχθησαν από τις προηγούμενες ενημερώσεις μας και άλλα έγιναν σε τοπικό επίπεδο και δεν είναι διαθέσιμα σε κανέναν ακόμα επειδή δεν τα έχουμε πιέσει ακόμα.

[πηγή, κονσόλα]
----
$ git diff
Υπομονάδα DbConnector c87d55d..82d2ad3:
  > Συγχώνευση από την προέλευση / σταθερό
  > ενημερωμένο σενάριο εγκατάστασης
  > υποστήριξη unicode
  > αφαιρέστε την περιττή μέθοδο
  > προσθήκη νέας επιλογής για τη συγκέντρωση conn
----

Εάν υποβάλλουμε στο κύριο έργο και το ωθήσουμε χωρίς να πιέσουμε τα υποσυστήματα να αλλάζουν, άλλοι άνθρωποι που προσπαθούν να ελέγξουν τις αλλαγές μας θα αντιμετωπίσουν πρόβλημα, αφού δεν θα έχουν τρόπο να πάρουν τις αλλαγές των υποσυστημάτων που εξαρτώνται από .
Αυτές οι αλλαγές θα υπάρχουν μόνο στο τοπικό αντίγραφό μας.

Για να βεβαιωθούμε ότι αυτό δεν συμβαίνει, μπορούμε να ζητήσουμε από τον Git να ελέγξει ότι όλα τα υποσυστήματά μας έχουν ωθηθεί σωστά πριν προωθήσουμε το κύριο έργο.
Η εντολή `git push` παίρνει το επιχείρημα `--recurse-submodules` το οποίο μπορεί να ρυθμιστεί είτε σε `check` είτε σε `on-demand`.
Η επιλογή `` check '' θα κάνει `push 'απλά να αποτύχει εάν κάποια από τις μεταβιβαζόμενες αλλαγές του υποσυστήματος δεν έχει ωθηθεί.

[πηγή, κονσόλα]
----
$ git ώθηση - recurse-submodules = έλεγχος
Οι ακόλουθες διαδρομές υπομονάδων περιέχουν αλλαγές που μπορούν
δεν μπορεί να βρεθεί σε κανένα τηλεχειριστήριο:
  DbConnector

Παρακαλώ προσπάθησε

git push -recurse-submodules = κατ 'απαίτηση

ή cd στη διαδρομή και τη χρήση

git push

για να τα σπρώξουμε σε ένα τηλεχειριστήριο.
----

Όπως μπορούμε να δούμε, μας δίνει επίσης κάποιες χρήσιμες συμβουλές για το τι θα θέλαμε να κάνουμε στη συνέχεια.
Η απλή επιλογή είναι να εισέλθουμε σε κάθε υπομοντέλο και να πιέζουμε χειροκίνητα τα τηλεχειριστήρια για να βεβαιωθούμε ότι είναι εξωτερικά διαθέσιμα και, στη συνέχεια, δοκιμάστε ξανά αυτό το πάτημα.

Η άλλη επιλογή είναι να χρησιμοποιήσουμε την τιμή `` on-demand '', η οποία θα προσπαθήσει να το κάνει αυτό για εσάς.

[πηγή, κονσόλα]
----
$ git push --recurse-submodules = κατ 'απαίτηση
Πατώντας τον υπομοντέλο 'DbConnector'
Μετρώντας αντικείμενα: 9, τελείωσε.
Συμπίεση Delta χρησιμοποιώντας έως και 8 νήματα.
Συμπίεση αντικειμένων: 100% (8/8), τελείωσε.
Γράψιμο αντικειμένων: 100% (9/9), 917 bytes 0 byte / s, τελείωσε.
Σύνολο 9 (δέλτα 3), επαναχρησιμοποίηση 0 (δέλτα 0)
Για να https://github.com/chaconinc/DbConnector
   c75e92a..82d2ad3 σταθερή -> σταθερή
Μετρώντας αντικείμενα: 2, τελείωσε.
Συμπίεση Delta χρησιμοποιώντας έως και 8 νήματα.
Συμπίεση αντικειμένων: 100% (2/2), τελείωσε.
Γράψιμο αντικειμένων: 100% (2/2), 266 byte | 0 byte / s, τελείωσε.
Σύνολο 2 (δέλτα 1), επαναχρησιμοποίηση 0 (δέλτα 0)
Για να https://github.com/chaconinc/MainProject
   3d6d338..9a377d1 master -> πλοίαρχος
----

Όπως βλέπουμε εκεί, ο Git μπήκε στη μονάδα DbConnector και τον έσπρωξε πριν προωθήσει το κύριο έργο.
Εάν η ώθηση του υποσυστήματος αποτύχει για κάποιο λόγο, η κύρια ώθηση του έργου θα αποτύχει επίσης.

===== Συγχώνευση αλλαγών υπομπόλων

Εάν αλλάξουμε μια παραπομπή υποσυστήματος ταυτόχρονα με κάποιον άλλο, ενδέχεται να αντιμετωπίσουμε κάποια προβλήματα.
Δηλαδή, εάν τα ιστορικά υποσυστήματα έχουν αποκλίνει και έχουν υποβληθεί σε διαφορετικά κλάδους σε ένα υπερ-σχέδιο, μπορεί να χρειαστεί κάποια δουλειά για να τα διορθώσουμε.

Εάν μία από τις υποβολές είναι ένας άμεσος πρόγονος του άλλου (μια γρήγορη συγχώνευση), τότε ο Git θα επιλέξει απλά τον τελευταίο για τη συγχώνευση, έτσι ώστε να λειτουργεί καλά.

Ωστόσο, το Git δεν θα επιχειρήσει ακόμη και μια τετριμμένη συγχώνευση για εσάς.
Εάν το υπομοντέλο υποβάλλει να αποκλίνει και πρέπει να συγχωνευθεί, θα πάρουμε κάτι που μοιάζει με αυτό:

[πηγή, κονσόλα]
----
$ git pull
απομακρυσμένη: Μετρώντας τα αντικείμενα: 2, τελειώσει.
απομακρυσμένη: Συμπίεση αντικειμένων: 100% (1/1), τελείωσε.
απομακρυσμένη: Σύνολο 2 (δέλτα 1), επαναχρησιμοποίηση 2 (δέλτα 1)
Αποσυμπιέστε αντικείμενα: 100% (2/2), τελείωσε.
Από το https://github.com/chaconinc/MainProject
   9a377d1..eb974f8 master -> προέλευση / κύριο
Λήψη του υποσυστήματος DbConnector
προειδοποίηση: Δεν ήταν δυνατή η συγχώνευση του υποσυστήματος DbConnector (συγχώνευση μετά τις υποβολές που δεν βρέθηκαν)
Αυτόματη συγχώνευση του DbConnector
CONFLICT (υπομοντέλο): Συγχώνευση σύγκρουσης στο DbConnector
Η αυτόματη συγχώνευση απέτυχε να διορθώσουμε τις συγκρούσεις και στη συνέχεια να υποβάλλουμε το αποτέλεσμα.
----

Έτσι, βασικά, αυτό που συνέβη εδώ είναι ότι ο Git έχει καταλάβει ότι οι δύο κλάδοι καταγράφουν σημεία στην ιστορία του υποσυστήματος που είναι διαφορετικά και πρέπει να συγχωνευθούν.
Το εξηγεί ως `` συγχώνευση μετά τις υποβολές που δεν βρέθηκαν '', το οποίο είναι συγκεχυμένο, αλλά θα εξηγήσουμε γιατί αυτό είναι σε λίγο.

Για να λύσουμε το πρόβλημα, θα πρέπει να υπολογίσουμε σε ποια κατάσταση θα πρέπει να βρίσκεται το υπομοντέλο.
Παραδόξως, το Git δεν μας δίνει πραγματικά πολλές πληροφορίες για να βοηθήσουμε εδώ, ούτε καν τα SHA-1s των υποβολών και των δύο πλευρών της ιστορίας.
Ευτυχώς, είναι απλό να καταλάβεις.
Αν εκτελέσουμε το `git diff`, μπορούμε να λάβουμε τα SHA-1 των υποβολών που καταγράφηκαν και στα δύο κλάδους που προσπαθούσαμε να συγχωνεύσουμε.

[πηγή, κονσόλα]
----
$ git diff
diff - cc DbConnector
ευρετήριο eb41d76, c771610..0000000
--- a / DbConnector
+++ β / DbConnector
----

Έτσι, στην περίπτωση αυτή, `eb41d76` είναι η δέσμευση στο υπομονάδα μας ότι * είχαμε και το` c771610` είναι η δέσμευση που είχε προηγουμένως.
Αν πάμε στον κατάλογο υπομονάδων μας, θα έπρεπε να είναι ήδη στο `eb41d76` καθώς η συγχώνευση δεν θα τον άγγιζε.
Εάν για οποιονδήποτε λόγο δεν είναι, μπορούμε απλά να δημιουργήσουμε και να ελέγξουμε έναν κλάδο που δείχνει σε αυτό.

Αυτό που είναι σημαντικό είναι το SHA-1 της δέσμευσης από την άλλη πλευρά.
Αυτό θα πρέπει να συγχωνεύσουμε και να επιλύσουμε.
Μπορούμε είτε να δοκιμάσουμε απευθείας τη συγχώνευση με το SHA-1 απευθείας είτε μπορούμε να δημιουργήσουμε έναν κλάδο για αυτό και στη συνέχεια να προσπαθήσουμε να το συγχωνεύσουμε.
Θα το προτείνουμε το τελευταίο, έστω και μόνο για να κάνει ένα καλύτερο μήνυμα συγχώνευσης.

Έτσι, θα πάμε στον κατάλογο υπομονάδων μας, θα δημιουργήσουμε έναν κλάδο βασισμένο σε αυτό το δεύτερο SHA-1 από το `git diff` και θα συγχωνεύσουμε με το χέρι.

[πηγή, κονσόλα]
----
$ cd DbConnector

$ git rev-parse HEAD
eb41d764bccf88be77aced643c13a7fa86714135

$ git branch tr

$ git κλάδο try-συγχώνευση c771610
(DbConnector) $ git συγχώνευση try-συγχώνευση
Αυτόματη συγχώνευση src / main.c
CONFLICT (περιεχόμενο): Συγχώνευση σύγκρουσης στο src / main.c
Εγγραφή προεπισκόπησης για 'src / main.c'
Η αυτόματη συγχώνευση απέτυχε να διορθώσουμε τις συγκρούσεις και στη συνέχεια να υποβάλλουμε το αποτέλεσμα.
----

Έχουμε μια πραγματική σύγκρουση συγχώνευσης εδώ, οπότε αν το επιλύσουμε και θα την υποβάλλουμε, τότε μπορούμε απλά να ενημερώσουμε το κύριο έργο με το αποτέλεσμα.

[πηγή, κονσόλα]
----
$ vim src / main.c <1>
$ git προσθέστε src / main.c
$ git commit -am 'συγχώνευσε τις αλλαγές μας'
Καταγεγραμμένη ανάλυση για το 'src / main.c'.
[master 9fd905e] συγχώνευσε τις αλλαγές μας

$ cd .. <2>
$ git diff <3>
diff - cc DbConnector
ευρετήριο eb41d76, c771610..0000000
--- a / DbConnector
+++ β / DbConnector
@@@ -1,1 -1,1 +1,1 @@@
- Υποέργο commit eb41d764bccf88be77aced643c13a7fa86714135
 -Συμπληρωματικό εγχείρημα c77161012afbbe1f58b5053316ead08f4b7e6d1d
++ Υποέργο commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a
$ git προσθέστε DbConnector <4>

$ git commit -m "Συγχώνευση αλλαγών του Tom" <5>
[master 10d2c60] Συγχώνευση των αλλαγών του Tom
----

<1> Αρχικά επιλύουμε τη σύγκρουση
<2> Μετά επιστρέφουμε στον κύριο κατάλογο έργων
<3> Μπορούμε ξανά να ελέγξουμε τα SHA-1
<4> Επιλύστε την καταχώρηση αλληλεξάρτησης που βρίσκεται σε διένεξη
<5> Αναθέστε τη συγχώνευσή μας

Μπορεί να είναι λίγο συγκεχυμένη, αλλά δεν είναι πραγματικά πολύ δύσκολο.

Είναι ενδιαφέρον ότι υπάρχει μια άλλη περίπτωση που το Git χειρίζεται.
Εάν υπάρχει υποβολή συγχώνευσης στον κατάλογο υπομονάδων που περιέχει ** και τα δύο υποβάλλει ** στο ιστορικό του, το Git θα μας το προτείνει ως μια πιθανή λύση.
Βλέπει ότι σε κάποιο σημείο του έργου υποσυστήματος κάποιος συνένωσε κλάδους που περιέχουν αυτές τις δύο υποβολές, οπότε ίσως θα το θελήσουμε.

Αυτός είναι ο λόγος για τον οποίο το μήνυμα λάθους από πριν ήταν `` συγχώνευση ακολουθώντας τις υποβολές που δεν βρέθηκαν '', επειδή δεν μπορούσε να κάνει * αυτό *.
Είναι συγκεχυμένη γιατί ποιος θα περίμενε ** να προσπαθήσει ** να το κάνει αυτό;

Εάν διαπιστώσει ότι υπάρχει μία αποδεκτή δέσμευση συγχώνευσης, θα δούμε κάτι παρόμοιο:

[πηγή, κονσόλα]
----
$ git συγχώνευση προέλευσης / κύριος
προειδοποίηση: Δεν μπόρεσε να συγχωνεύσει τον υπομοντέλο DbConnector (όχι γρήγορο προς τα εμπρός)
Βρήκε μια πιθανή ανάλυση συγχώνευσης για το υπομοντέλο:
 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a:> συγχώνευσαν τις αλλαγές μας
Εάν αυτό είναι σωστό, απλά προσθέστε το στο ευρετήριο για παράδειγμα
με τη χρήση:

  git ενημέρωση-δείκτη - cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a "DbConnector"

η οποία θα δεχθεί αυτήν την πρόταση.
Αυτόματη συγχώνευση του DbConnector
CONFLICT (υπομοντέλο): Συγχώνευση σύγκρουσης στο DbConnector
Η αυτόματη συγχώνευση απέτυχε να διορθώσουμε τις συγκρούσεις και στη συνέχεια να υποβάλλουμε το αποτέλεσμα.
----

Αυτό που υποδηλώνει ότι κάνουμε είναι να ενημερώσουμε τον ευρετήριο όπως είχαμε εκτελέσει το `git add`, το οποίο καθαρίζει τη σύγκρουση και κατόπιν υποβάλλει. Πιθανότατα δεν πρέπει να το κάνουμε αυτό όμως. Μπορούμε επίσης εύκολα να μεταβούμε στον κατάλογο των υπομοντέλων, να δούμε ποια είναι η διαφορά, να προχωρήσουμε γρήγορα σε αυτή τη δέσμευση, να το δοκιμάσουμε σωστά και στη συνέχεια να την υποβάλλουμε.

[πηγή, κονσόλα]
----
$ cd DbConnector /
$ git συγχώνευση 9fd905e
Ενημέρωση eb41d76..9fd905e
Γρήγορη προώθηση

$ cd ..
$ git προσθέστε το DbConnector
$ git commit -am 'Γρήγορη προώθηση σε ένα κοινό παιδί υπομοντέλων'
----

Αυτό ολοκληρώνει το ίδιο πράγμα, αλλά τουλάχιστον με αυτόν τον τρόπο μπορούμε να επαληθεύσουμε ότι λειτουργεί και έχουμε τον κώδικα στον κατάλογο υπομονάδων μας όταν τελειώσουμε.


==== Συμβουλές υποσυστήματος

Υπάρχουν μερικά πράγματα που μπορούμε να κάνουμε για να κάνουμε την εργασία με τους υπομοντέλους λίγο πιο εύκολη.

===== Υπομονάδα Foreach

Υπάρχει μια εντολή submodule `foreach` για να εκτελέσουμε κάποια αυθαίρετη εντολή σε κάθε υπομονάδα.
Αυτό μπορεί να είναι πραγματικά χρήσιμο εάν έχουμε έναν αριθμό υπομονάδων στο ίδιο έργο.

Για παράδειγμα, ας υποθέσουμε ότι θέλουμε να ξεκινήσουμε μια νέα λειτουργία ή να κάνουμε μια διόρθωση σφαλμάτων και έχουμε εργασία που συμβαίνει σε διάφορα υπομονάδες.
Μπορούμε εύκολα να αποθηκεύσουμε όλη τη δουλειά σε όλες τις υπομονάδες μας.

[πηγή, κονσόλα]
----
$ git submodule foreach 'git stash'
Εισάγοντας το 'CryptoLibrary'
Δεν υπάρχουν τοπικές αλλαγές για αποθήκευση
Εισαγωγή 'DbConnector'
Αποθηκευμένος κατάλογος εργασίας και κατάσταση ευρετηρίου WIP σε σταθερό: 82d2ad3 Συγχώνευση από προέλευση / σταθερό
Το HEAD βρίσκεται τώρα στο 82d2ad3 Συγχώνευση από την προέλευση / σταθερό
----

Στη συνέχεια, μπορούμε να δημιουργήσουμε έναν νέο κλάδο και να το αλλάξουμε σε όλα τα υπομονάδα μας.

[πηγή, κονσόλα]
----
$ git submodule foreach 'git checkout -b χαρακτηριστικόA'
Εισάγοντας το 'CryptoLibrary'
Μετάβαση σε νέο κλάδο 'featureA'
Εισαγωγή 'DbConnector'
Μετάβαση σε νέο κλάδο 'featureA'
----

Έχουμε την ιδέα.
Ένα πραγματικά χρήσιμο πράγμα που μπορούμε να κάνουμε είναι να παράγουμε μια ωραία ενοποιημένη διαφορά από αυτό που αλλάζει στο κύριο έργο μας και όλα τα υποπρογράμματά μας επίσης.

[πηγή, κονσόλα]
----
$ git diff; git submodule foreach 'git diff'
Το υποσύνολο DbConnector περιέχει τροποποιημένο περιεχόμενο
diff - git a / src / main.c b / src / main.c
ευρετήριο 210f1ae..1f0acdc 100644
--- a / src / main.c
+++ β / src / main.c
@@ -245,6 +245,8 @@ στατική int handle_alias (int * argcp, const char *** argv)

      commit_pager_choice ();

+ url = url_decode (url_orig).
+
      / * δημιουργία alias_argv * /
      alias_argv = xmalloc (μέγεθοςof (* alias_argv) * (argc + 1)).
      alias_argv [0] = alias_string + 1.
Εισαγωγή 'DbConnector'
diff - git a / src / db.c b / src / db.c
δείκτης 1aaefb6..5297645 100644
--- a / src / db.c
+++ β / src / db.c
@@ -93,6 +93,11 @@ char * url_decode_mem (const char * url, int len)
        επιστροφή url_decode_internal (& url, len, NULL, & out, 0);
 }}

+ char * url_decode (const char * url)
+ {
+ επιστροφή url_decode_mem (url, strlen (url));
+}
+
 char * url_decode_parameter_name (ερώτημα const είδος **)
 {
        δομή strbuf out = STRBUF_INIT;
----

Εδώ μπορούμε να δούμε ότι ορίζουμε μια λειτουργία σε ένα υπομοντέλο και το καλούμε στο κύριο έργο.
Αυτό είναι προφανώς ένα απλοποιημένο παράδειγμα, αλλά ελπίζουμε ότι μας δίνει μια ιδέα για το πώς αυτό μπορεί να είναι χρήσιμο.

===== Χρήσιμα ψευδώνυμα

Μπορεί να θέλουμε να ορίσουμε ορισμένα ψευδώνυμα για ορισμένες από αυτές τις εντολές, καθώς μπορεί να είναι αρκετά μεγάλη και δεν μπορούμε να ορίσουμε επιλογές διαμόρφωσης για τους περισσότερους από αυτούς για να τις κάνουμε προεπιλογές.
Καλύψαμε τη δημιουργία των ψευδωνύμων Git στο << _git_aliases >>, αλλά εδώ είναι ένα παράδειγμα του τι μπορεί να θέλουμε να ρυθμίσουμε εάν σχεδιάζουμε να δουλεύουμε με υπομονάδες στο Git πολύ.

[πηγή, κονσόλα]
----
$ git config alias.sdiff '!' "git diff && git υποδιαμορφωτής foreach 'git diff'"
$ git config alias.spush 'push -recurse-submodules = κατ' απαίτηση '
Ανανέωση υπομονάδας $ git config alias.supdate'remote --merge '
----

Με αυτό τον τρόπο μπορούμε απλά να εκτελέσουμε το `git supdate` όταν θέλουμε να ενημερώσουμε τα υποσυστήματα μας, ή το` git spush` για να πιέσουμε με τον έλεγχο εξάρτησης υποσυστήματος.

==== Ζητήματα με υπομονάδες

Η χρήση υπομονάδων δεν είναι χωρίς λόξιμο, ωστόσο.

Για παράδειγμα, η εναλλαγή κλαδιών με υπομονάδες σε αυτά μπορεί επίσης να είναι δύσκολη.
Εάν δημιουργήσουμε ένα νέο κλάδο, προσθέστε ένα υπομοντέλο εκεί και, στη συνέχεια, μεταβούμε σε ένα κλάδο χωρίς αυτό το υποσύνολο, εξακολουθούμε να έχουμε τον κατάλογο υποστοιχείων ως έναν μη κρυπτογραφημένο κατάλογο:

[πηγή, κονσόλα]
----
$ git checkout -b add-crypto
Μετάβαση σε νέο κλάδο 'add-crypto'

Το $ git submodule προσθέτει https://github.com/chaconinc/CryptoLibrary
Κλωνοποίηση σε 'CryptoLibrary' ...
...

$ git commit -am 'προσθέτοντας κρυπτογραφική βιβλιοθήκη'
[add-crypto 4445836] προσθήκη βιβλιοθήκης κρυπτογράφησης
 2 αρχεία άλλαξαν, 4 εισαγωγές (+)
 δημιουργήστε τη λειτουργία 160000 CryptoLibrary

$ git master checkout
προειδοποίηση: δεν είναι δυνατό να rmdir CryptoLibrary: Ο κατάλογος δεν είναι κενός
Μετάβαση στο κλάδο 'master'
Το υποκατάστημά μας είναι ενημερωμένο με τον όρο "προέλευση / κύριο".

$ git status
Στον κύριο κλάδο
Το υποκατάστημά μας είναι ενημερωμένο με τον όρο "προέλευση / κύριο".

Μη σπασμένα αρχεία:
  (χρησιμοποιήστε το "git add <file> ..." για να συμπεριλάβουμε σε αυτό που θα υποβληθεί)

CryptoLibrary /

τίποτα δεν προστέθηκε για να υποβληθούν, αλλά τα untracked αρχεία παρόντα (χρησιμοποιήστε το "git add" στο κομμάτι)
----

Η κατάργηση του καταλόγου δεν είναι δύσκολη, αλλά μπορεί να είναι λίγο συγκεχυμένη η ύπαρξη εκεί.
Αν το αφαιρέσουμε και μετά επιστρέψουμε στον κλάδο που έχει αυτό το υπομονάδα, θα χρειαστεί να εκτελέσουμε την `update submodule - init 'για να την επαναδημιουργήσουμε ξανά.

[πηγή, κονσόλα]
----
$ git clean -fdx
Αφαίρεση του CryptoLibrary /

$ git checkout add-crypto
Μετάβαση στον κλάδο 'add-crypto'

$ ls CryptoLibrary /

Ενημέρωση υπομονάδας $ git --init
Υποδομή διαδρομής 'CryptoLibrary': Έλεγχος 'b8dda6aa182ea4464f3f3264b11e0268545172af'

$ ls CryptoLibrary /
Το makefile περιλαμβάνει δέσμες ενεργειών src
----

Και πάλι, δεν είναι πραγματικά πολύ δύσκολο, αλλά μπορεί να είναι λίγο συγκεχυμένη.

Η άλλη κύρια προειδοποίηση την οποία αντιμετωπίζουν πολλοί άνθρωποι περιλαμβάνει τη μετάβαση από τους υποκαταλόγους σε υπομονάδες.
Αν παρακολουθούμε αρχεία στο έργο μας και θέλουμε να τα μετακινήσουμε σε υπομονάδα, πρέπει να είστε προσεκτικοί ή ο Git θα μας θυμώνει.
Ας υποθέσουμε ότι έχουμε αρχεία σε έναν υποκατάλογο του έργου μας και θέλουμε να το αλλάξουμε σε υπομονάδα.
Αν διαγράψουμε τον υποκατάλογο και στη συνέχεια εκτελέσουμε το `submodule add`, ο Git μάς φωνάζει:

[πηγή, κονσόλα]
----
$ rm -Rf CryptoLibrary /
Το $ git submodule προσθέτει https://github.com/chaconinc/CryptoLibrary
Το 'CryptoLibrary' υπάρχει ήδη στο ευρετήριο
----

Πρέπει πρώτα να αποσυμπιέσουμε τον κατάλογο `CryptoLibrary`.
Στη συνέχεια, μπορούμε να προσθέσουμε το υπομοντέλο:

[πηγή, κονσόλα]
----
$ git rm -r CryptoLibrary
Το $ git submodule προσθέτει https://github.com/chaconinc/CryptoLibrary
Κλωνοποίηση σε 'CryptoLibrary' ...
απομακρυσμένο: Μετρώντας τα αντικείμενα: 11, τελειωμένο.
απομακρυσμένη: Συμπίεση αντικειμένων: 100% (10/10), τελείωσε.
απομακρυσμένη: Σύνολο 11 (δέλτα 0), επαναχρησιμοποίηση 11 (δέλτα 0)
Αποσυμπιέστε αντικείμενα: 100% (11/11), τελείωσε.
Έλεγχος συνδεσιμότητας ... γίνεται.
----

Τώρα υποθέστε ότι το κάναμε σε έναν κλάδο.
Αν προσπαθήσουμε να επιστρέψουμε σε κλάδο όπου αυτά τα αρχεία βρίσκονται ακόμα στο πραγματικό δέντρο και όχι σε ένα υπομονάδα - λαμβάνουμε αυτό το σφάλμα:

[πηγή, κονσόλα]
----
$ git master checkout
σφάλμα: Τα ακόλουθα μη επεξεργασμένα αρχεία δέντρου εργασίας θα αντικατασταθούν από το checkout:
  CryptoLibrary / Makefile
  CryptoLibrary / περιλαμβάνει / crypto.h
  ...
Μετακινήστε ή αφαιρέστε τις πριν να μπορέσουμε να αλλάξουμε κλάδους.
Ακύρωση
----

Μπορούμε να τον αναγκάσουμε να μεταβούμε με το `checkout -f`, αλλά να είστε προσεκτικοί ώστε να μην έχουμε μη αποθηκευμένες αλλαγές εκεί καθώς θα μπορούσαν να αντικατασταθούν με αυτή την εντολή.

[πηγή, κονσόλα]
----
$ git checkout -f master
προειδοποίηση: δεν είναι δυνατό να rmdir CryptoLibrary: Ο κατάλογος δεν είναι κενός
Μετάβαση στο κλάδο 'master'
----

Στη συνέχεια, όταν γυρίζουμε πίσω, παίρνουμε έναν κενό κατάλογο `CryptoLibrary` για κάποιο λόγο και η` git update submodule` δεν μπορεί να το διορθώσει.
Ενδέχεται να χρειαστεί να μεταβούμε στον κατάλογο υπομονάδων μας και να εκτελέσουμε ένα 'git checkout' για να επιστρέψουμε όλα τα αρχεία μας.
Θα μπορούσαμε να το εκτελέσουμε σε ένα σενάριο `submodule foreach` για να το εκτελέσουμε για πολλαπλές υπομονάδες.

Είναι σημαντικό να σημειώσουμε ότι οι υπομονάδες αυτές τις μέρες διατηρούν όλα τα δεδομένα Git στον κατάλογο `.git` του κορυφαίου έργου, έτσι αντίθετα από πολύ παλιότερες εκδόσεις του Git, καταστρέφοντας έναν κατάλογο υπομονάδων, δεν θα χάσουμε τίποτα υποβολές ή κλάδους που είχατε.

Με αυτά τα εργαλεία, οι υπομονάδες μπορούν να είναι μια αρκετά απλή και αποτελεσματική μέθοδος για την ανάπτυξη σε πολλά σχετικά αλλά ξεχωριστά έργα ταυτόχρονα.










ΕΝΟΤΗΤΑ 7.12

[[_bundling]]
=== Συστοιχία

Αν και καλύψαμε τους συνήθεις τρόπους μεταφοράς των δεδομένων Git μέσω δικτύου (HTTP, SSH κ.λπ.), υπάρχει πράγματι ένας ακόμη τρόπος να το κάνουμε αυτό που δεν χρησιμοποιείται συνήθως, αλλά μπορεί πραγματικά να είναι πολύ χρήσιμος.

Το Git είναι ικανό να «συνδέει» τα δεδομένα του σε ένα μόνο αρχείο.
Αυτό μπορεί να είναι χρήσιμο σε διάφορα σενάρια.
Ίσως το δίκτυό μας να είναι κάτω και θέλουμε να στείλουμε αλλαγές στους συναδέλφους μας.
Ίσως εργαζόμαστε κάπου εκτός τόπου και δεν έχουμε πρόσβαση στο τοπικό δίκτυο για λόγους ασφαλείας.
Ίσως η κάρτα μας ασύρματου / ethernet μόλις έσπασε.
Ίσως να μην έχουμε επί του παρόντος πρόσβαση σε έναν κοινόχρηστο διακομιστή, θέλουμε να στείλουμε μηνύματα ηλεκτρονικού ταχυδρομείου σε κάποιον χρήστη και δεν θέλουμε να μεταφέρουμε 40 υποβολές μέσω του `format-patch`.

Αυτό είναι όπου η εντολή `git bundle` μπορεί να είναι χρήσιμη.
Η εντολή `bundle` θα συσκευάσει όλα όσα θα έπρεπε κανονικά να ωθηθούν πάνω στο καλώδιο με μια εντολή` git push 'σε ένα δυαδικό αρχείο το οποίο μπορούμε να στείλουμε email σε κάποιον ή να τοποθετήσουμε μια μονάδα flash και στη συνέχεια να ξεδιπλώσουμε σε άλλο αποθετήριο.

Ας δούμε ένα απλό παράδειγμα.
Ας υποθέσουμε ότι έχουμε ένα αποθετήριο με δύο υποβολές:

[πηγή, κονσόλα]
----
$ git log
commit 9a466c572fe88b195efd356c3f2bbeccdb504102
Συντάκτης: Scott Chacon <schacon@gmail.com>
Ημερομηνία: Τετ Μαρ 10 07:34:10 2010 -0800

    Δεύτερη δέσμευση

commit b1ec3248f39900d2a406049d762aa68e9641be25
Συντάκτης: Scott Chacon <schacon@gmail.com>
Ημερομηνία: Τετ Μαρ 10 07:34:01 2010 -0800

    πρώτη δέσμευση
----

Εάν θέλουμε να στείλουμε αυτόν τον αποθετήριο σε κάποιον και δεν έχουμε πρόσβαση σε αποθετήριο για να πιέσουμε ή απλά δεν θέλουμε να το ορίσουμε, μπορούμε να τον συνδέσουμε με το `git bundle create`.

[πηγή, κονσόλα]
----
$ git πακέτο δημιουργία repo.bundle master HEAD
Μετρώντας τα αντικείμενα: 6, τελείωσε.
Συμπίεση Delta χρησιμοποιώντας μέχρι 2 σπειρώματα.
Συμπίεση αντικειμένων: 100% (2/2), τελείωσε.
Γράψιμο αντικειμένων: 100% (6/6), 441 bytes, τελείωσε.
Σύνολο 6 (δέλτα 0), επαναχρησιμοποίηση 0 (δέλτα 0)
----

Τώρα έχουμε ένα αρχείο με το όνομα `repo.bundle` που έχει όλα τα δεδομένα που απαιτούνται για να δημιουργηθεί εκ νέου ο κλάδος` master` του αποθετηρίου.
Με την εντολή `δέσμη 'πρέπει να παραθέσουμε κάθε αναφορά ή συγκεκριμένο εύρος υποβολών που θέλουμε να συμπεριλάβουμε.
Αν σκοπεύουμε να κλωνοποιηθεί αυτό κάπου αλλού, θα πρέπει να προσθέσουμε HEAD ως αναφορά, όπως επίσης και εδώ.

Μπορούμε να στείλουμε μήνυμα ηλεκτρονικού ταχυδρομείου σε αυτό το αρχείο `repo.bundle` σε κάποιον άλλο, ή να το τοποθετήσουμε σε μια μονάδα USB και να το περπατήσουμε.

Από την άλλη πλευρά, πούμε ότι έχουμε στείλει αυτό το αρχείο `repo.bundle` και θέλουμε να εργαστούμε στο έργο.
Μπορούμε να κλωνοποιήσουμε από το δυαδικό αρχείο σε έναν κατάλογο, όπως θα κάναμε από μια διεύθυνση URL.

[πηγή, κονσόλα]
----
$ git κλώνο repo.bundle repo
Αρχικό κενό αποθετήριο Git στο /private/tmp/bundle/repo/.git/
$ cd repo
$ git log -online
9a466c5 δεύτερη δέσμευση
b1ec324 πρώτη δέσμευση
----

Εάν δεν συμπεριλαμβάνουμε HEAD στις αναφορές, πρέπει επίσης να καθορίσουμε το `-b master` ή οποιονδήποτε κλάδο περιλαμβάνεται επειδή αλλιώς δεν θα ξέρει τι κλάδο να ελέγξει έξω.

Τώρα ας υποθέσουμε ότι κάνουμε τρεις υποβολές σε αυτό και θέλουμε να στείλουμε τις νέες υποβολές πίσω μέσω μιας δέσμης σε ένα stick USB ή ένα ηλεκτρονικό ταχυδρομείο.

[πηγή, κονσόλα]
----
$ git log -online
71b84da τελευταία δέσμευση - δεύτερη repo
c99cf5b τέταρτο commit - δεύτερη repo
7011d3d τρίτη δέσμευση - δεύτερη επαναγορά
9a466c5 δεύτερη δέσμευση
b1ec324 πρώτη δέσμευση
----

Πρώτα πρέπει να καθορίσουμε το εύρος υποβολών που θέλουμε να συμπεριλάβουμε στη δέσμη.
Σε αντίθεση με τα πρωτόκολλα δικτύου που καθορίζουν το ελάχιστο σύνολο δεδομένων που θα μεταφερθούν μέσω του δικτύου για εμάς, θα πρέπει να το καταλάβουμε χειροκίνητα.
 Τώρα, θα μπορούσαμε να κάνουμε το ίδιο πράγμα και να συνδέσουμε ολόκληρο το αποθετήριο, το οποίο θα λειτουργήσει, αλλά είναι καλύτερα να συνδυάσουμε τη διαφορά - ακριβώς τις τρεις υποβολές που κάναμε τοπικά.

Για να γίνει αυτό, θα πρέπει να υπολογίσουμε τη διαφορά.
Όπως περιγράψαμε στο << _ commit_ranges >>, μπορούμε να καθορίσουμε μια σειρά υποβολών με διάφορους τρόπους.
Για να πάρουμε τις τρεις υποβολές που έχουμε στον κύριο κλάδο μας που δεν ήταν στον κλάδο που αρχικά κλωνοποιήσαμε, μπορούμε να χρησιμοποιήσουμε κάτι σαν `origine / master..master` ή 'master ^ origin / master`.
Μπορούμε να το δοκιμάσουμε με την εντολή `log`.

[πηγή, κονσόλα]
----
$ git log - αρχική γραμμή master ^ προέλευση / master
71b84da τελευταία δέσμευση - δεύτερη repo
c99cf5b τέταρτο commit - δεύτερη repo
7011d3d τρίτη δέσμευση - δεύτερη επαναγορά
----

Τώρα λοιπόν που έχουμε τον κατάλογο των υποβολών που θέλουμε να συμπεριλάβουμε στη δέσμη, ας τις συσσωρεύσουμε.
Το κάνουμε αυτό με την εντολή `git bundle create`, δίνοντάς του ένα όνομα αρχείου που θέλουμε να είναι το πακέτο μας και το φάσμα των υποβολών που θέλουμε να το κάνουμε.

[πηγή, κονσόλα]
----
Η δέσμη $ git δημιουργεί comits.bundle master ^ 9a466c5
Μετρώντας αντικείμενα: 11, τελείωσε.
Συμπίεση Delta χρησιμοποιώντας μέχρι 2 σπειρώματα.
Συμπίεση αντικειμένων: 100% (3/3), τελείωσε.
Γράφοντας αντικειμένων: 100% (9/9), 775 byte, τελείωσε.
Σύνολο 9 (δέλτα 0), επαναχρησιμοποίηση 0 (δέλτα 0)
----

Τώρα έχουμε ένα αρχείο `commits.bundle` στον κατάλογό μας.
Αν το πάρουμε αυτό και θα το στείλουμε στον συνεργάτη μας, τότε μπορεί να το εισάγει στο αρχικό αποθετήριο, ακόμα κι αν έχει γίνει περισσότερη δουλειά εκεί εν τω μεταξύ.

Όταν παίρνει τη δέσμη, μπορεί να το επιθεωρήσει για να δει τι περιέχει πριν την εισάγει στο αποθετήριο της.
Η πρώτη εντολή είναι η εντολή `verify bundle 'που θα βεβαιωθεί ότι το αρχείο είναι στην πραγματικότητα μια έγκυρη δέσμη Git και ότι έχουμε όλους τους απαραίτητους προγόνους για να την ανασυστήσουμε σωστά.

[πηγή, κονσόλα]
----
Η δέσμη $ git επαληθεύει ../commits.bundle
Η δέσμη περιέχει 1 αναφ
71b84daaf49abed142a373b6e5c59a22dc6560dc refs / κεφάλια / κύριο
Η δέσμη απαιτεί αυτά τα 1 σχ
9a466c572fe88b195efd356c3f2bbeccdb504102 δεύτερη δέσμευση
../commits.bundle είναι εντάξει
----

Αν ο παγιδευτής είχε δημιουργήσει μια δέσμη μόνο των δύο τελευταίων υποβολών που είχαν πράξει, και όχι και οι τρεις, ο αρχικός χώρος αποθήκευσης δεν θα μπορούσε να το εισαγάγει, δεδομένου ότι λείπει η απαιτούμενη ιστορία.
Η εντολή `verify 'θα έμοιαζε έτσι:

[πηγή, κονσόλα]
----
Η δέσμη $ git επαληθεύει ../commits-bad.bundle
σφάλμα: Στο χώρο αποθήκευσης δεν υπάρχουν οι προαπαιτούμενοι υποβολές:
σφάλμα: 7011d3d8fc200abe0ad561c011c3852a4b7bbe95 τρίτη δέσμευση - δεύτερη repo
----

Ωστόσο, η πρώτη μας δέσμη είναι έγκυρη, έτσι μπορούμε να φέρουμε υποβολές από αυτήν.
Αν θέλουμε να δούμε ποιοι κλάδοι βρίσκονται στη δέσμη που μπορεί να εισαχθεί, υπάρχει επίσης μια εντολή για τη λίστα των κεφαλών:

[πηγή, κονσόλα]
----
$ git δέσμες γραμμών-κεφαλαίων ../commits.bundle
71b84daaf49abed142a373b6e5c59a22dc6560dc refs / κεφάλια / κύριο
----

Η δευτερεύουσα εντολή `verify` θα μας πει και τα κεφάλια.
Το σημείο είναι να δούμε τι μπορεί να τραβηχτεί, ώστε να μπορούμε να χρησιμοποιήσουμε τις εντολές `fetch` ή` pull` για να εισάγουμε υποβολές από αυτή τη δέσμη.
Εδώ θα φέρουμε τον «κύριο» κλάδο της δέσμης σε έναν κλάδο που ονομάζεται «άλλος-κύριος» στο αποθετήριο μας:

[πηγή, κονσόλα]
----
$ git fetch ../commits.bundle πλοίαρχος: other-master
Από ../commits.bundle
 * [νέο κλάδο] master -> άλλο-master
----

Τώρα μπορούμε να δούμε ότι έχουμε τις εισαγόμενες υποβολές στον κλάδο «άλλου κύριου» καθώς και τις υποβολές που έχουμε κάνει εν τω μεταξύ στο δικό μας «κύριο» κλάδο.

[πηγή, κονσόλα]
----
$ git log --online --decorate --graph - όλα
* 8255d41 (HEAD, master) τρίτη δέσμευση - πρώτη repo
| * 71b84da (άλλο-master) τελευταία δέσμευση - δεύτερη repo
| * c99cf5b τέταρτο commit - δεύτερο repo
| * 7011d3d τρίτη δέσμευση - δεύτερη repo
| /
* 9a466c5 δεύτερη δέσμευση
* b1ec324 πρώτη δέσμευση
----

Έτσι, το `git bundle` μπορεί να είναι πραγματικά χρήσιμο για να μοιραστούμε ή να κάνουμε πράξεις τύπου δικτύου όταν δεν έχουμε το κατάλληλο δίκτυο ή κοινόχρηστο αποθετήριο για να το κάνουμε αυτό.




ΕΝΟΤΗΤΑ 7.13
[[_αντικαθιστώ]]
=== Αντικατάσταση

Τα αντικείμενα του Git είναι αμετάβλητα, αλλά παρέχουν έναν ενδιαφέροντα τρόπο για να προσποιούνται ότι αντικαθιστούν αντικείμενα στη βάση δεδομένων του με άλλα αντικείμενα.

Η εντολή `replace 'σάς επιτρέπει να ορίσουμε ένα αντικείμενο στο Git και να λέτε« κάθε φορά που βλέπουμε αυτό, υποκριθούμε ότι είναι αυτό το άλλο πράγμα ».
Αυτό είναι συνήθως χρήσιμο για την αντικατάσταση μιας δέσμευσης στο ιστορικό μας με ένα άλλο.

Για παράδειγμα, ας υποθέσουμε ότι έχουμε ένα τεράστιο ιστορικό κώδικα και θέλουμε να χωρίσουμε το αποθετήριό μας σε μια σύντομη ιστορία για νέους προγραμματιστές και μια πολύ μεγαλύτερη και μεγαλύτερη ιστορία για ανθρώπους που ενδιαφέρονται για την εξόρυξη δεδομένων.
Μπορούμε να μεταμοσχεύσουμε ένα ιστορικό στο άλλο με «αντικατάσταση» της πρώτης δέσμευσης στη νέα γραμμή με την πιο πρόσφατη αποστολή στην παλαιότερη.
Αυτό είναι ωραίο γιατί σημαίνει ότι δεν χρειάζεται να ξαναγράψουμε κάθε δέσμευση στη νέα ιστορία, όπως θα έπρεπε κανονικά να κάνουμε για να τα ενώσουμε μαζί (επειδή η συγγένεια επηρεάζει τα SHA-1).

Ας το δοκιμάσουμε.
Ας πάρουμε ένα υπάρχον αποθετήριο, χωρίσαμε το σε δύο αποθετήρια, ένα πρόσφατο και ένα ιστορικό, και στη συνέχεια θα δούμε πώς μπορούμε να τα ανασυνδυάσουμε χωρίς να αλλάξουμε τις πρόσφατες τιμές αποθεμάτων SHA-1 μέσω `αντικαταστήστε '.

Θα χρησιμοποιήσουμε ένα απλό αποθετήριο με πέντε απλές υποβολές:

[πηγή, κονσόλα]
----
$ git log -online
ef989d8 πέμπτη δέσμευση
c6e1e95 τέταρτη δέσμευση
9c68fdc τρίτη δέσμευση
945704c δεύτερη δέσμευση
c1822cf πρώτα υποβάλλουμε
----

Θέλουμε να το χωρίσουμε σε δύο γραμμές της ιστορίας.
Μια γραμμή πηγαίνει από τη δέσμευση ενός για την δέσμευση τεσσάρων - αυτό θα είναι το ιστορικό.
Η δεύτερη γραμμή θα υποβάλλει τέσσερα και πέντε - αυτό θα είναι το πρόσφατο ιστορικό.

εικόνα :: images / replace1.png []

Λοιπόν, η δημιουργία της ιστορικής ιστορίας είναι εύκολη, μπορούμε απλά να βάλουμε έναν κλάδο στην ιστορία και στη συνέχεια να προωθήσουμε αυτόν τον κλάδο στον κύριο κλάδο ενός νέου απομακρυσμένου αποθετηρίου.

[πηγή, κονσόλα]
----
Ιστορικό κλάδου $ git c6e1e95
$ git log --online - διακόσμηση
ef989d8 (HEAD, master) πέμπτη δέσμευση
c6e1e95 (ιστορία) τέταρτη δέσμευση
9c68fdc τρίτη δέσμευση
945704c δεύτερη δέσμευση
c1822cf πρώτα υποβάλλουμε
----

εικόνα :: images / replace2.png []

Τώρα μπορούμε να σπρώξουμε τον νέο κλάδο `history 'στον κλάδο` master` του νέου αποθετηρίου μας:

[πηγή, κονσόλα]
----
$ git απομακρυσμένη προσθήκη ιστορικού έργου https://github.com/schacon/project-history
$ git push έργο-ιστορικό ιστορίας: κύριος
Μετρώντας τα αντικείμενα: 12, τελείωσε.
Συμπίεση Delta χρησιμοποιώντας μέχρι 2 σπειρώματα.
Συμπίεση αντικειμένων: 100% (4/4), τελείωσε.
Γράφοντας αντικείμενα: 100% (12/12), 907 bytes, τελείωσε.
Σύνολο 12 (δέλτα 0), επαναχρησιμοποίηση 0 (δέλτα 0)
Αποσυμπιέστε αντικείμενα: 100% (12/12), τελείωσε.
Για το git@github.com: schacon / project-history.git
 * [νέο κλάδο] ιστορία -> master
----

Εντάξει, έτσι η ιστορία μας δημοσιεύεται.
Τώρα το σκληρότερο κομμάτι περικόπτει το πρόσφατο ιστορικό μας και έτσι είναι μικρότερο.
Χρειαζόμαστε μια επικάλυψη, ώστε να μπορέσουμε να αντικαταστήσουμε μια δέσμευση σε μία με μια ισοδύναμη δέσμευση στην άλλη, οπότε πρόκειται να το κόψουμε για να διαπράξουμε τέσσερις και πέντε (έτσι υποβάλλουμε τέσσερις αλληλεπικαλύψεις).

[πηγή, κονσόλα]
----
$ git log --online - διακόσμηση
ef989d8 (HEAD, master) πέμπτη δέσμευση
c6e1e95 (ιστορία) τέταρτη δέσμευση
9c68fdc τρίτη δέσμευση
945704c δεύτερη δέσμευση
c1822cf πρώτα υποβάλλουμε
----

Είναι χρήσιμο σε αυτή την περίπτωση να δημιουργήσουμε μια δέσμευση βάσης που έχει οδηγίες σχετικά με τον τρόπο επέκτασης του ιστορικού, έτσι ώστε άλλοι προγραμματιστές να γνωρίζουν τι πρέπει να κάνουν αν πετύχουν την πρώτη δέσμευση στο αποκομμένο ιστορικό και χρειάζονται περισσότερα.
Λοιπόν, αυτό που πρόκειται να κάνουμε είναι να δημιουργήσουμε ένα αρχικό αντικείμενό της ως βασικό σημείο με οδηγίες και στη συνέχεια να αναδιοργανώσουμε τις υπόλοιπες υποβολές (τέσσερα και πέντε) πάνω από αυτό.

Για να γίνει αυτό, πρέπει να επιλέξουμε ένα σημείο για να χωρίσουμε, το οποίο για εμάς είναι η τρίτη δέσμευση, η οποία είναι `9c68fdc` στο SHA-speak.
Έτσι, η βάση της δέσμευσής μας θα βασίζεται σε αυτό το δέντρο.
Μπορούμε να δημιουργήσουμε τη δέσμευσή μας χρησιμοποιώντας την εντολή commit-tree, η οποία παίρνει ακριβώς ένα δέντρο και θα μας δώσει ένα ολοκαίνουργιο αντικείμενό της, που δεν αντέχει στο SHA-1, πίσω.

[πηγή, κονσόλα]
----
$ echo 'πάρει ιστορία από το blah blah blah' | git δέσμευση-δέντρο 9c68fdc ^ {δέντρο}
622e88e9cbfbacfb75b5279245b9fb38dfea10cf
----

[ΣΗΜΕΙΩΣΗ]
=====
Η εντολή "commit-tree" είναι ένα από ένα σύνολο εντολών που συνήθως αναφέρονται ως εντολές «υδραυλικών».
Αυτές είναι εντολές που δεν προορίζονται γενικά για άμεση χρήση, αλλά χρησιμοποιούνται από ** άλλες ** εντολές Git για να κάνουν μικρότερες εργασίες.
Σε ορισμένες περιπτώσεις, όταν κάνουμε πιο περίπλοκα πράγματα όπως αυτό, μας επιτρέπουν να κάνουμε πραγματικά πράγματα χαμηλού επιπέδου, αλλά δεν προορίζονται για καθημερινή χρήση.
Μπορούμε να διαβάσουμε περισσότερα σχετικά με τις εντολές υδραυλικών στο << _ plumbing_porcelain >>
=====

εικόνα :: images / replace3.png []

Εντάξει, τώρα που έχουμε μια βάση διαπραγμάτευσης, μπορούμε να αναδιοργανώσουμε το υπόλοιπο της ιστορίας μας πάνω από αυτό με το «git rebase - toto».
Το επιχείρημα `--onto` θα είναι το SHA-1 που μόλις επιστρέψαμε από το` commit-tree` και το σημείο rebase θα είναι το τρίτο commit (ο γονέας της πρώτης δέσμευσης που θέλουμε να κρατήσουμε, `9c68fdc`):

[πηγή, κονσόλα]
----
$ git rebase - στο 622e88 9c68fdc
Αρχικά, επανατοποθετήστε το κεφάλι για να επαναλάβουμε την εργασία μας πάνω από το ...
Εφαρμογή: τέταρτη δέσμευση
Εφαρμογή: πέμπτη δέσμευση
----

εικόνα :: images / replace4.png []

Εντάξει, οπότε τώρα έχουμε ξαναγράψει την πρόσφατη ιστορία μας πάνω από μια βάση απόρριψης που έχει τώρα οδηγίες

Εντάξει, οπότε τώρα έχουμε ξαναγράψει την πρόσφατη ιστορία μας πάνω από μια βάση απόρριψης που υποβάλλει ότι τώρα έχει οδηγίες σε αυτό για το πώς να ανακατασκευάσει ολόκληρη την ιστορία αν θέλαμε.
Μπορούμε να προωθήσουμε αυτή τη νέα ιστορία σε ένα νέο έργο και τώρα που οι άνθρωποι κλωνοποιούν αυτό το αποθετήριο, θα δουν μόνο τις πιο πρόσφατες δύο υποβολές και έπειτα μια βάση διαπράττει οδηγίες.

Ας αλλάξουμε τώρα τους ρόλους σε κάποιον που κλωνοποιεί το έργο για πρώτη φορά που θέλει ολόκληρο το ιστορικό.
Για να αποκτήσουμε τα δεδομένα ιστορικού μετά την κλωνοποίηση αυτού του αποκομμένου αποθετηρίου, κάποιος θα πρέπει να προσθέσει ένα δεύτερο απομακρυσμένο για το ιστορικό αποθετήριο και να φέρω:

[πηγή, κονσόλα]
----
$ git clone https://github.com/schacon/project
$ cd project

$ git log - αρχική γραμμή γραμμής
e146b5f πέμπτη δέσμευση
81a708d τέταρτη δέσμευση
622e88e πάρει ιστορία από το μπλα μπλα μπλα

$ git απομακρυσμένη προσθήκη ιστορικού έργου https://github.com/schacon/project-history
$ git fetch project-history
Από https://github.com/schacon/project-history
 * [νέο κλάδο] master -> project-history / master
----

Τώρα ο συνεργάτης θα έχει τις πρόσφατες υποβολές του στον κλάδο «master» και τα ιστορικά υποβάλλει στον κλάδο `project-history/master`.

[πηγή, κονσόλα]
----
$ git log - αρχική γραμμή γραμμής
e146b5f πέμπτη δέσμευση
81a708d τέταρτη δέσμευση
622e88e πάρει ιστορία από το μπλα μπλα μπλα

$ git log - αρχικό έργο-ιστορικό / κύριο
c6e1e95 τέταρτη δέσμευση
9c68fdc τρίτη δέσμευση
945704c δεύτερη δέσμευση
c1822cf πρώτα υποβάλλουμε
----

Για να τα συνδυάσουμε, μπορούμε απλά να καλέσουμε το `git replace` με τη δέσμευση που θέλουμε να αντικαταστήσουμε και στη συνέχεια την εντολή που θέλουμε να την αντικαταστήσουμε.
Επομένως, θέλουμε να αντικαταστήσουμε την "τέταρτη" δέσμευση στον κύριο κλάδο με την "τέταρτη" δέσμευση στον κλάδο `project-history / master`:

[πηγή, κονσόλα]
----
$ git αντικαθιστά το 81a708d c6e1e95
----

Τώρα, αν κοιτάξουμε την ιστορία του κλάδου `master`, φαίνεται να μοιάζει με αυτό:

[πηγή, κονσόλα]
----
$ git log - αρχική γραμμή γραμμής
e146b5f πέμπτη δέσμευση
81a708d τέταρτη δέσμευση
9c68fdc τρίτη δέσμευση
945704c δεύτερη δέσμευση
c1822cf πρώτα υποβάλλουμε
----

Καλά, σωστά; Χωρίς να χρειάζεται να αλλάξουμε όλα τα SHA-1s upstream, μπορέσαμε να αντικαταστήσουμε μια δέσμευση στην ιστορία μας με μια εντελώς διαφορετική δέσμευση και όλα τα κανονικά εργαλεία («bisect», «φταίει» κ.λπ.) θα δουλεύουν με τον τρόπο που θα περίμενε κανείς να .

εικόνα :: images / replace5.png []

Είναι ενδιαφέρον ότι εξακολουθεί να εμφανίζει το στοιχείο `81a708d` ως SHA-1, παρόλο που χρησιμοποιεί πραγματικά τα` `c6e1e95` 'δεδομένα αποστολής με τα οποία το αντικαταστήσαμε.
Ακόμα και αν εκτελέσουμε μια εντολή όπως `cat-file`, θα μας δείξει τα αντικατασταθέντα δεδομένα:

[πηγή, κονσόλα]
----
$ git γάτα-αρχείο -p 81a708d
δέντρο 7bc544cf438903b65ca9104a1e30345eee6c083d
γονέας 9c68fdceee073230f19ebb8b5e7fc71b479c0252
συγγραφέας Scott Chacon <schacon@gmail.com> 1268712581 -0700
σκηνοθετήστε Scott Chacon <schacon@gmail.com> 1268712581 -0700

τέταρτη δέσμευση
----

Θυμηθούμε ότι ο πραγματικός γονέας του `81a708d` ήταν ο εντοπισμός των εντολών κράτησης θέσης (` 622e88e`), όχι `9c68fdce` όπως δηλώνεται εδώ.

Ένα άλλο ενδιαφέρον είναι ότι αυτά τα δεδομένα διατηρούνται στις αναφορές μας:

[πηγή, κονσόλα]
----
$ git for-each-ref
e146b5f14e79d4935160c0e83fb9ebe526b8da0d Συμπληρώστε refs / heads / master
c6e1e95051d41771a649f3145423f8809d1a74d4 Εμπιστευθούμε / remotes / history / master
e146b5f14e79d4935160c0e83fb9ebe526b8da0d Εμπιστευθούμε / remotes / προέλευση / HEAD
e146b5f14e79d4935160c0e83fb9ebe526b8da0d Συμπληρώστε τις αναφορές / απομακρυσμένα / προέλευση / κύριο
c6e1e95051d41771a649f3145423f8809d1a74d4 Επαναλάβουμε / αντικαταστήστε / 81a708dd0e167a3f691541c7a6463343bc457040
----

Αυτό σημαίνει ότι είναι εύκολο να μοιραστούμε την αντικατάστασή μας με άλλους, διότι μπορούμε να το προωθήσουμε στο διακομιστή μας και άλλοι άνθρωποι μπορούν εύκολα να το κατεβάσουν.
Αυτό δεν είναι τόσο χρήσιμο στο σενάριο εμβολιασμού ιστορίας που έχουμε πάει εδώ (αφού όλοι θα κατεβάζονταν και οι δύο ιστορίες ούτως ή άλλως, οπότε γιατί να τις χωρίσετε;) αλλά μπορεί να είναι χρήσιμο και σε άλλες περιπτώσεις.





ΕΝΟΤΗΤΑ 7.14
[[_credential_caching]]
=== Αποθήκευση διαπιστευτηρίων

(((διαπιστευτήρια)))
(((εντολές git, διαπιστευτήρια)))
Εάν χρησιμοποιούμε τη μεταφορά SSH για τη σύνδεση με τηλεχειριστήρια, είναι πιθανό να έχουμε ένα κλειδί χωρίς μια φράση πρόσβασης, η οποία μας επιτρέπει να μεταφέρουμε δεδομένα με ασφάλεια χωρίς να πληκτρολογήσουμε το όνομα χρήστη και τον κωδικό πρόσβασής μας.
Ωστόσο, αυτό δεν είναι δυνατό με τα πρωτόκολλα HTTP - κάθε σύνδεση χρειάζεται ένα όνομα χρήστη και έναν κωδικό πρόσβασης.
Αυτό γίνεται ακόμα πιο δύσκολο για συστήματα με έλεγχο ταυτότητας δύο παραγόντων, όπου το διακριτικό που χρησιμοποιούμε για έναν κωδικό πρόσβασης παράγεται τυχαία και δεν μπορεί να προωθηθεί.

Ευτυχώς, το Git διαθέτει ένα σύστημα διαπιστευτηρίων που μπορεί να βοηθήσει σε αυτό.
Το Git διαθέτει μερικές επιλογές στο κουτί:

* Η προεπιλογή δεν είναι καθόλου κρυμμένη.
  Κάθε σύνδεση θα μας ζητήσει το όνομα χρήστη και τον κωδικό πρόσβασής μας.
* Η λειτουργία `` cache '' διατηρεί τα διαπιστευτήρια στη μνήμη για ορισμένο χρονικό διάστημα.
  Κανένας από τους κωδικούς πρόσβασης δεν αποθηκεύεται ποτέ στο δίσκο και καθαρίζονται από την προσωρινή μνήμη μετά από 15 λεπτά.
* Η λειτουργία `` store '' αποθηκεύει τα διαπιστευτήρια σε ένα αρχείο απλού κειμένου στο δίσκο και δεν λήγει ποτέ.
  Αυτό σημαίνει ότι μέχρι να αλλάξουμε τον κωδικό πρόσβασης για τον κεντρικό υπολογιστή Git, δεν θα χρειαστεί ποτέ να πληκτρολογήσουμε ξανά τα διαπιστευτήριά μας.
  Το μειονέκτημα αυτής της προσέγγισης είναι ότι οι κωδικοί πρόσβασης αποθηκεύονται σε καθαρό κείμενο σε ένα απλό αρχείο στον προσωπικό μας κατάλογο.
* Εάν χρησιμοποιούμε Mac, το Git έρχεται με μια λειτουργία `` osxkeychain '', η οποία αποθηκεύει τα διαπιστευτήρια στο ασφαλές μπρελόκ που είναι συνδεδεμένο με το λογαριασμό μας στο σύστημα.
  Αυτή η μέθοδος αποθηκεύει τα διαπιστευτήρια στο δίσκο και δεν λήγει ποτέ, αλλά είναι κρυπτογραφημένα με το ίδιο σύστημα που αποθηκεύει τα πιστοποιητικά HTTPS και το αυτόματο συμπλήρωμα του Safari.
* Εάν χρησιμοποιούμε Windows, μπορούμε να εγκαταστήσουμε έναν βοηθό που ονομάζεται `` winstore. ''
  Αυτό είναι παρόμοιο με τον βοηθό `` osxkeychain '' που περιγράφεται παραπάνω, αλλά χρησιμοποιεί το Windows Credential Store για τον έλεγχο ευαίσθητων πληροφοριών.
  Μπορεί να βρεθεί στο https://gitcredentialstore.codeplex.com [].

Μπορούμε να επιλέξουμε μία από αυτές τις μεθόδους ρυθμίζοντας μια τιμή διαμόρφωσης Git:

[πηγή, κονσόλα]
----
$ git config --Γενική cache της credential.helper
----

Μερικοί από αυτούς τους βοηθούς έχουν επιλογές.
Ο βοηθός `` store '' μπορεί να πάρει ένα `--file <path>` argument, το οποίο προσαρμόζεται όπου αποθηκεύεται το αρχείο plaintext (το προεπιλεγμένο είναι τα "~ / .git-credentials").
Ο βοηθός `` cache '' δέχεται την επιλογή `--timeout <δευτερόλεπτα ', η οποία αλλάζει την ώρα που ο δαίμονας συνεχίζει να τρέχει (η προεπιλογή είναι` `900' 'ή 15 λεπτά).
Ακολουθεί ένα παράδειγμα του πώς θα ρυθμίσουμε τον βοηθό `` store '' με ένα όνομα προσαρμοσμένου αρχείου:

[πηγή, κονσόλα]
----
$ git config - global credential.helper store - αρχείο ~ / .my-διαπιστευτήρια
----

Το Git ακόμη μας επιτρέπει να ρυθμίσουμε διάφορες βοήθειες.
Όταν αναζητάμε διαπιστευτήρια για έναν συγκεκριμένο κεντρικό υπολογιστή, το Git θα τα ερωτά με σειρά και θα σταματήσει μετά την πρώτη απάντηση.
Κατά την αποθήκευση διαπιστευτηρίων, το Git θα στείλει το όνομα χρήστη και τον κωδικό πρόσβασης σε * όλους * τους βοηθούς της λίστας και μπορούν να επιλέξουν τι πρέπει να κάνουν μαζί τους.
Ακολουθεί το παράδειγμα ενός `.gitconfig` αν είχαμε ένα αρχείο διαπιστευτηρίων σε μια μονάδα αντίχειρα, αλλά ήθελε να χρησιμοποιήσει την προσωρινή μνήμη της μνήμης για να εξοικονομήσει κάποια πληκτρολόγηση εάν η μονάδα δεν είναι συνδεδεμένη:

[πηγή, ini]
----
[πιστοποιητικό]
    helper = κατάστημα - αρχείο /mnt/thumbdrive/.git-credentials
    helper = cache --timeout 30000
----

==== Κάτω από την κουκούλα

Πώς λειτουργεί αυτό;
Η εντολή ρίζας του Git για το σύστημα βοηθητικών διαπιστευτηρίων είναι η `git credential`, η οποία παίρνει μια εντολή ως επιχείρημα, και στη συνέχεια περισσότερες εισροές μέσω του stdin.

Αυτό μπορεί να είναι ευκολότερο να κατανοηθεί με ένα παράδειγμα.
Ας υποθέσουμε ότι έχει ρυθμιστεί ένας βοηθός διαπιστευτηρίων και ο βοηθός έχει αποθηκεύσει τα διαπιστευτήρια για το "mygithost".
Ακολουθεί μια περίοδος λειτουργίας που χρησιμοποιεί την εντολή `` fill '', η οποία ενεργοποιείται όταν ο Git προσπαθεί να βρει διαπιστευτήρια για έναν κεντρικό υπολογιστή:

[πηγή, κονσόλα]
----
$ git συμπληρώνει τα στοιχεία <1>
πρωτόκολλο = https <2>
host = mygithost
<3>
πρωτόκολλο = https <4>
host = mygithost
username = bob
κωδικός πρόσβασης = s3cre7
$ git συμπληρώνει τα στοιχεία <5>
πρωτόκολλο = https
host = unknownhost

Όνομα χρήστη για 'https: // unknownhost': bob
Κωδικός πρόσβασης για το 'https: // bob @ unknownhost':
πρωτόκολλο = https
host = unknownhost
username = bob
κωδικός πρόσβασης = s3cre7
----

<1> Αυτή είναι η γραμμή εντολών που ενεργοποιεί την αλληλεπίδραση.
<2> Το Git-credential στη συνέχεια περιμένει την είσοδο στο stdin.
    Το παρέχουμε με τα πράγματα που γνωρίζουμε: το πρωτόκολλο και το όνομα του κεντρικού υπολογιστή.
<3> Μια κενή γραμμή υποδεικνύει ότι η είσοδος είναι πλήρης και το σύστημα διαπιστευτηρίων πρέπει να απαντά με αυτό που γνωρίζει.
<4> Το Git-credential στη συνέχεια αναλαμβάνει και γράφει στο stdout με τα κομμάτια των πληροφοριών που βρήκε.
<5> Εάν δεν εντοπιστούν τα διαπιστευτήρια, ο Git ζητάει από το χρήστη το όνομα χρήστη και τον κωδικό πρόσβασης και τα επαναφέρει στην κλήση του stdout (εδώ είναι συνδεδεμένα στην ίδια κονσόλα).

Το σύστημα διαπιστευτηρίων επικαλείται ένα πρόγραμμα που είναι ξεχωριστό από το ίδιο το Git. ποιος και πώς εξαρτάται από την τιμή διαμόρφωσης `credential.helper`.
Υπάρχουν διάφορες μορφές που μπορεί να πάρει:

[επιλογές = "κεφαλίδα"]
| ======
| Τιμή διαμόρφωσης η ΣΥΜΠΕΡΙΦΟΡΑ
| `foo` | Εκτελεί το `git-credential-foo`
| `foo -a -opt = bcd` | Εκτελεί το git-credential-foo -a -opt = bcd
| `/ απόλυτο / μονοπάτι / foo -xyz` | Εκτελεί το `/ απόλυτο / μονοπάτι / foo -xyz`
| `! f () {echo" κωδικός πρόσβασης = s3cre7 "; }, f` | Κωδικός μετά την αξιολόγηση!!
| ======

Έτσι οι βοηθοί που περιγράφηκαν παραπάνω ονομάζονται πραγματικά git-credential-cache, git-credential-store και ούτω καθεξής και μπορούμε να τις ρυθμίσουμε ώστε να λάβουν επιχειρήματα γραμμής εντολών.
Η γενική μορφή για αυτό είναι `` git-credential-foo [args] <action>. ''
Το πρωτόκολλο stdin / stdout είναι το ίδιο με το git-credential, αλλά χρησιμοποιούν ένα ελαφρώς διαφορετικό σύνολο ενεργειών:

* `` get 'είναι ένα αίτημα για ένα ζεύγος ονόματος χρήστη / κωδικού πρόσβασης.
* Το 'store' είναι ένα αίτημα για να αποθηκεύσουμε ένα σύνολο διαπιστευτηρίων στη μνήμη αυτού του βοηθού.
* `delete 'καθαρίστε τα διαπιστευτήρια για τα δεδομένα properties από τη μνήμη αυτού του βοηθού.

Για τις ενέργειες `store 'και` delete', δεν απαιτείται απάντηση (το Git το αγνοεί ούτως ή άλλως).
Για τη δράση `get`, ωστόσο, ο Git ενδιαφέρεται πολύ για το τι έχει να πει ο βοηθός.
Αν ο βοηθός δεν γνωρίζει τίποτα χρήσιμο, μπορεί απλά να βγεί χωρίς έξοδο, αλλά αν το γνωρίζει, θα πρέπει να αυξήσει τις παρεχόμενες πληροφορίες με τις πληροφορίες που έχει αποθηκεύσει.
Η έξοδος αντιμετωπίζεται σαν μια σειρά δηλώσεων εκχώρησης. οτιδήποτε παρέχεται θα αντικαταστήσει αυτό που ήδη γνωρίζει ο Git.

Ακολουθεί το ίδιο παράδειγμα από πάνω, αλλά παρακάμπτοντας το git-credential και πηγαίνοντας κατ 'ευθείαν στο git-credential-store:

[πηγή, κονσόλα]
----
$ git store-credentials-store -file ~ / git.store <1>
πρωτόκολλο = https
host = mygithost
username = bob
κωδικός πρόσβασης = s3cre7
$ git πιστοποίηση-κατάστημα - αρχείο ~ / git.store πάρει <2>
πρωτόκολλο = https
host = mygithost

username = bob <3>
κωδικός πρόσβασης = s3cre7
----

<1> Εδώ λέμε στο «git-credential-store» για να αποθηκεύσουμε κάποια διαπιστευτήρια: το username `` bob '' και ο κωδικός `` s3cre7 '' πρέπει να χρησιμοποιηθούν όταν προσπελαστεί `https: // mygithost`.
<2> Τώρα θα ανακτήσουμε αυτά τα διαπιστευτήρια.
    Παρέχουμε τα μέρη της σύνδεσης που ήδη γνωρίζουμε (`https: // mygithost`) και μια κενή γραμμή.
<3> Το 'git-credential-store' απαντά με το όνομα χρήστη και τον κωδικό πρόσβασης που αποθηκεύσαμε παραπάνω.

Ακολουθεί το παράδειγμα του αρχείου `~ / git.store`:

[πηγή]
----
https: // bob: s3cre7 @ mygithost
----

Πρόκειται μόνο για μια σειρά γραμμών, κάθε μία από τις οποίες περιέχει μια διεύθυνση URL διακοσμημένη με πιστοποιήσεις.
Οι βοηθοί `osxkeychain` και` winstore` χρησιμοποιούν την εγγενή μορφή των καταστημάτων υποστήριξης, ενώ η `cache` χρησιμοποιεί τη δική της μορφή μνήμης (η οποία δεν διαβάζει καμία άλλη διαδικασία).

==== Μία προσωρινή μνήμη παραληπτών διαπιστευτηρίων

Δεδομένου ότι το git-credential-store και οι φίλοι είναι ξεχωριστά προγράμματα από το Git, δεν είναι πολύ άλμα για να συνειδητοποιήσουμε ότι κάποιο πρόγραμμα μπορεί να είναι βοηθός πιστοποίησης Git.
Οι βοηθοί που παρέχονται από το Git καλύπτουν πολλές κοινές περιπτώσεις χρήσης, αλλά όχι όλες.
Για παράδειγμα, ας υποθέσουμε ότι η ομάδα μας έχει ορισμένα διαπιστευτήρια που μοιράζονται με ολόκληρη την ομάδα, ίσως για ανάπτυξη.
Αυτά αποθηκεύονται σε κοινόχρηστο κατάλογο, αλλά δεν θέλουμε να τα αντιγράψουμε στο δικό μας κατάστημα διαπιστευτηρίων, επειδή αλλάζουν συχνά.
Κανένας από τους υπάρχοντες βοηθούς δεν καλύπτει αυτήν την περίπτωση. ας δούμε τι θα χρειαζόταν για να γράψουμε το δικό μας.
Υπάρχουν πολλά βασικά χαρακτηριστικά που πρέπει να έχει αυτό το πρόγραμμα:

. Η μόνη ενέργεια που πρέπει να δώσουμε προσοχή είναι `πάρτε '? `αποθήκευση` και` διαγραφή 'είναι εγγραφές, επομένως θα βγούμε καθαρά όταν λάβουμε.
. Η μορφή αρχείου του αρχείου κοινόχρηστων διαπιστευτηρίων είναι ίδια με αυτή που χρησιμοποιείται από το `git-credential-store '.
. Η τοποθεσία αυτού του αρχείου είναι αρκετά τυπική, αλλά θα πρέπει να επιτρέψουμε στον χρήστη να περάσει μια προσαρμοσμένη διαδρομή μόνο σε περίπτωση.

Για άλλη μια φορά, θα γράψουμε αυτή την επέκταση σε Ruby, αλλά οποιαδήποτε γλώσσα θα λειτουργήσει όσο Git μπορεί να εκτελέσει το τελικό προϊόν.
Εδώ είναι ο πλήρης πηγαίος κώδικας του νέου μας βοηθού πιστοποίησης:

[πηγή, ρουμπίνι]
--------
περιλαμβάνουν: ../ git-credential-μόνο για ανάγνωση []
--------

<1> Εδώ αναλύουμε τις επιλογές της γραμμής εντολών, επιτρέποντας στον χρήστη να καθορίσει το αρχείο εισόδου. Η προεπιλογή είναι "~ / .git-διαπιστευτήρια".
<2> Αυτό το πρόγραμμα ανταποκρίνεται μόνο εάν η ενέργεια είναι `get` και το αρχείο backing-store υπάρχει.
<3> Αυτός ο βρόχος διαβάζει από τον stdin μέχρι να φτάσει η πρώτη κενή γραμμή.
    Οι είσοδοι αποθηκεύονται στο γνωστό κατακερματισμό για μεταγενέστερη αναφορά.
<4> Αυτός ο βρόχος διαβάζει τα περιεχόμενα του αρχείου αποθήκευσης αναζητώντας αντιστοιχίες.
    Εάν το πρωτόκολλο και ο κεντρικός υπολογιστής από το `γνωστό 'ταιριάζουν με αυτή τη γραμμή, το πρόγραμμα εκτυπώνει τα αποτελέσματα σε stdout και έξοδο.

Θα σώσουμε τον βοηθό μας ως "git-credential-read-only", το βάζουμε κάπου στο `PATH 'και το επισημόνουμε εκτελέσιμο.
Ακολουθεί μια εμφάνιση μιας διαδραστικής περιόδου σύνδεσης:

[πηγή, κονσόλα]
----
$ git πιστοποίηση-μόνο για ανάγνωση --file = / mnt / shared / creds get
πρωτόκολλο = https
host = mygithost

πρωτόκολλο = https
host = mygithost
username = bob
κωδικός πρόσβασης = s3cre7
----

Επειδή το όνομά του ξεκινάει με `` git- '', μπορούμε να χρησιμοποιήσουμε την απλή σύνταξη για την τιμή διαμόρφωσης:

[πηγή, κονσόλα]
----
$ git config --global credential.helper μόνο για ανάγνωση --file / mnt / shared / creds
----

Όπως μπορούμε να δούμε, η επέκταση αυτού του συστήματος είναι αρκετά απλή και μπορεί να λύσει μερικά κοινά προβλήματα για εσάς και την ομάδα μας.


ΕΝΟΤΗΤΑ 7.15
=== Summary

You’ve seen a number of advanced tools that allow you to manipulate your commits and staging area more precisely.
When you notice issues, you should be able to easily figure out what commit introduced them, when, and by whom.
If you want to use subprojects in your project, you’ve learned how to accommodate those needs.
At this point, you should be able to do most of the things in Git that you’ll need on the command line day to day and feel comfortable doing so.




