[[_advanced_merging]]
=== Advanced Merging

Merging in Git is typically fairly easy.
Since Git makes it easy to merge another branch multiple times, it means that you can have a very long lived branch but you can keep it up to date as you go, solving small conflicts often, rather than be surprised by one enormous conflict at the end of the series.

Η συγχώνευση στο Git είναι συνήθως αρκετά εύκολη.
Εφόσον το Git καθιστά εύκολη τη συγχώνευση ενός άλλου κλάδου πολλές φορές, αυτό σημαίνει ότι μπορούμε να έχουμε έναν πολύ μακρόβιο κλάδο, αλλά μπορούμε να το κρατάμε ενημερωμένο καθώς πηγαίνουμε, επιλύοντας συχνά μικρές συγκρούσεις, αντί να εκπλαγούμε από μια τεράστια σύγκρουση στο τέλος της σειράς.

Εντούτοις, μερικές φορές προκύπτουν δύσκολες συγκρούσεις.
Σε αντίθεση με κάποια άλλα συστήματα ελέγχου έκδοσης, το Git δεν προσπαθεί να είναι υπερβολικά έξυπνο για τη λύση της επίλυσης συγκρούσεων.
Η φιλοσοφία του Git είναι να είναι έξυπνη για να προσδιορίσει πότε μια λύση συγχώνευσης είναι ξεκάθαρη, αλλά αν υπάρχει σύγκρουση, δεν προσπαθεί να είναι έξυπνος για την αυτόματη επίλυσή της.
Επομένως, αν περιμένουμε πολύ για να συγχωνεύσουμε δύο κλάδους που αποκλίνουν γρήγορα, μπορούμε να αντιμετωπίσουμε ορισμένα ζητήματα.

However, sometimes tricky conflicts do occur.
Unlike some other version control systems, Git does not try to be overly clever about merge conflict resolution.
Git's philosophy is to be smart about determining when a merge resolution is unambiguous, but if there is a conflict, it does not try to be clever about automatically resolving it.
Therefore, if you wait too long to merge two branches that diverge quickly, you can run into some issues.

Σε αυτή την ενότητα, θα αναφερθούμε σε ποια από αυτά τα θέματα θα μπορούσαν να είναι και τι εργαλεία Git μας δίνει για να βοηθήσουμε να χειριστούμε αυτές τις πιο δύσκολες καταστάσεις.
Θα καλύψουμε επίσης μερικούς από τους διαφορετικούς, μη τυποποιημένους τύπους συγχώνευσης που μπορούμε να κάνουμε, καθώς και να δούμε πώς μπορούμε να αποφύγουμε συγχωνεύσεις που έχουμε κάνει.

In this section, we'll go over what some of those issues might be and what tools Git gives you to help handle these more tricky situations.
We'll also cover some of the different, non-standard types of merges you can do, as well as see how to back out of merges that you've done.

==== Συγκρούσεις συγχωνεύσεων

While we covered some basics on resolving merge conflicts in <<_basic_merge_conflicts>>, for more complex conflicts, Git provides a few tools to help you figure out what's going on and how to better deal with the conflict.

Ενώ καλύψαμε κάποια βασικά στοιχεία για την επίλυση των συγκρούσεων συγχώνευσης σε <<_basic_merge_conflicts>>, για πιο πολύπλοκες συγκρούσεις, το Git παρέχει μερικά εργαλεία για να μας βοηθήσει να καταλάβουμε τι συμβαίνει και πώς να αντιμετωπίσουμε καλύτερα τη σύγκρουση.

Πρώτα απ 'όλα, αν είναι δυνατόν, προσπαθούμε να βεβαιωθούμε ότι ο κατάλογος εργασίας μας είναι καθαρός πριν κάνουμε μια συγχώνευση που μπορεί να έχει συγκρούσεις.
Εάν έχουμε εργασία σε εξέλιξη, είτε την υποβάλουμε σε έναν προσωρινό κλάδο είτε την αποθηκεύσουμε.
Αυτό το καθιστά έτσι ώστε να μπορούμε να ακυρώσουμε * οτιδήποτε * δοκιμάσουμε εδώ.
Εάν έχουμε μη αποθηκευμένες αλλαγές στον κατάλογο εργασίας μας όταν δοκιμάζουμε συγχώνευση, ορισμένες από αυτές τις συμβουλές μπορεί να μας βοηθήσουν να χάσουμε αυτήν την εργασία.

First of all, if at all possible, try to make sure your working directory is clean before doing a merge that may have conflicts.
If you have work in progress, either commit it to a temporary branch or stash it.
This makes it so that you can undo *anything* you try here.
If you have unsaved changes in your working directory when you try a merge, some of these tips may help you lose that work.

Ας δούμε ένα πολύ απλό παράδειγμα.
Έχουμε ένα εξαιρετικά απλό αρχείο Ruby που εκτυπώνει 'hello world'.

[source,ruby]
----
#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()
----

Στο αποθετήριό μας, δημιουργούμε έναν νέο κλάδο που ονομάζεται «κενό διάστημα» και προχωράμε στην αλλαγή όλων των τερματισμών της γραμμής Unix σε τερματισμούς γραμμής DOS, αλλάζοντας ουσιαστικά κάθε γραμμή του αρχείου, αλλά μόνο με κενά.
Στη συνέχεια, αλλάζουμε τη γραμμή `` hello world '' στο 'hello mundo' '.

In our repository, we create a new branch named `whitespace` and proceed to change all the Unix line endings to DOS line endings, essentially changing every line of the file, but just with whitespace.
Then we change the line ``hello world'' to ``hello mundo''.

[source,console]
----
$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'converted hello.rb to DOS'
[whitespace 3270f76] converted hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -b
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
 end

 hello()

$ git commit -am 'hello mundo change'
[whitespace 6d338d2] hello mundo change
 1 file changed, 1 insertion(+), 1 deletion(-)
----

Τώρα επιστρέφουμε στον κλάδο `master` και προσθέτουμε κάποια τεκμηρίωση για τη συνάρτηση.

[source,console]
----
$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello world'
 end

$ git commit -am 'document the function'
[master bec6336] document the function
 1 file changed, 1 insertion(+)
----

Τώρα προσπαθούμε να συγχωνευθούμε στον κλάδο μας `whitespace` και θα έχουμε συγκρούσεις εξαιτίας των αλλαγών στα λευκά διαστήματα.

[source,console]
----
$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.
----

[[_abort_merge]]
===== Aborting a Merge

Έχουμε τώρα μερικές επιλογές.
Πρώτον, ας καλύψουμε πώς να βγούμε από αυτή την κατάσταση.
Εάν ίσως δεν περίμεναν συγκρούσεις και δεν θέλεις να ασχοληθείς με την κατάσταση ακόμα, μπορείς απλά να βγεις από τη συγχώνευση με το `git merge --abort`.

We now have a few options.
First, let's cover how to get out of this situation.
If you perhaps weren't expecting conflicts and don't want to quite deal with the situation yet, you can simply back out of the merge with `git merge --abort`.

[source,console]
----
$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master
----

The `git merge --abort` option tries to revert back to your state before you ran the merge.
The only cases where it may not be able to do this perfectly would be if you had unstashed, uncommitted changes in your working directory when you ran it, otherwise it should work fine.

Η επιλογή `git merge --abort` προσπαθεί να επιστρέψει στην κατάστασή μας πριν εκτελέσουμε τη συγχώνευση.
Οι μόνες περιπτώσεις στις οποίες μπορεί να μην είναι σε θέση να το κάνει τέλεια θα ήταν εάν είχαμε ασταθείς, μη υποβλημένες αλλαγές στον κατάλογο εργασίας όταν την έτρεχε, αλλιώς θα έπρεπε να δουλέψει καλά.

Αν για κάποιο λόγο θέλουμε απλώς να αρχίσουμε πάλι, μπορούμε επίσης να εκτελέσουμε το `git reset --hard HEAD` και η αποθήκη μας θα επιστρέψει στην τελευταία αφοσιωμένη κατάσταση.
Θυμηθούμε ότι οποιαδήποτε εργασία δεν έχει υποβληθεί θα χαθεί, οπότε πρέπει να βεβαιωθούμε ότι δεν θέλουμε τις αλλαγές μας.

If for some reason you just want to start over, you can also run `git reset --hard HEAD`, and your repository will be back to the last committed state.
Remember that any uncommitted work will be lost, so make sure you don't want any of your changes.

===== Ignoring Whitespace

In this specific case, the conflicts are whitespace related.
We know this because the case is simple, but it's also pretty easy to tell in real cases when looking at the conflict because every line is removed on one side and added again on the other.
By default, Git sees all of these lines as being changed, so it can't merge the files.

Στη συγκεκριμένη περίπτωση, οι συγκρούσεις σχετίζονται με το κενό.
Γνωρίζουμε αυτό γιατί η υπόθεση είναι απλή, αλλά είναι επίσης πολύ εύκολο να το πεις σε πραγματικές περιπτώσεις όταν εξετάζεις τη σύγκρουση επειδή κάθε γραμμή έχει αφαιρεθεί από τη μια πλευρά και έχει προστεθεί ξανά από την άλλη.
Από προεπιλογή, το Git βλέπει όλες αυτές τις γραμμές να αλλάζουν, οπότε δεν μπορεί να συγχωνεύσει τα αρχεία.

Η προεπιλεγμένη στρατηγική συγχώνευσης μπορεί να πάρει επιχειρήματα αν και μερικά από αυτά είναι για να αγνοούν σωστά τις αλλαγές στο κενό.
Αν δούμε ότι έχουμε πολλά προβλήματα στο κενό σε μια συγχώνευση, μπορούμε απλά να το ακυρώσουμε και να το κάνουμε ξανά, αυτή τη φορά με το "-Xignore-all-space" ή το "-Xignore-space-change".
Η πρώτη επιλογή αγνοεί τον κενό χώρο ** εντελώς ** κατά τη σύγκριση γραμμών, η δεύτερη αντιμετωπίζει τις αλληλουχίες ενός ή περισσότερων χαρακτήρων κενής θέσης ως ισοδύναμα.

The default merge strategy can take arguments though, and a few of them are about properly ignoring whitespace changes.
If you see that you have a lot of whitespace issues in a merge, you can simply abort it and do it again, this time with `-Xignore-all-space` or `-Xignore-space-change`.
The first option ignores whitespace **completely** when comparing lines, the second treats sequences of one or more whitespace characters as equivalent.

[source,console]
----
$ git merge -Xignore-space-change whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
----

Since in this case, the actual file changes were not conflicting, once we ignore the whitespace changes, everything merges just fine.

Δεδομένου ότι σε αυτήν την περίπτωση, οι πραγματικές αλλαγές του αρχείου δεν ήταν συγκρούονταν, όταν αγνοήσαμε τις αλλαγές στα κενά διαστήαμτα, όλα πάνε μια χαρά.

Αυτό είναι ένα lifesaver εάν έχουμε κάποιον στην ομάδα μας που του αρέσει να περιστοιχίζει περιστασιακά τα πάντα από διαστήματα σε καρτέλες ή αντίστροφα.

This is a lifesaver if you have someone on your team who likes to occasionally reformat everything from spaces to tabs or vice-versa.

[[_manual_remerge]]
===== Manual File Re-merging

Though Git handles whitespace pre-processing pretty well, there are other types of changes that perhaps Git can't handle automatically, but are scriptable fixes.
As an example, let's pretend that Git could not handle the whitespace change and we needed to do it by hand.

Παρόλο που ο Git επεξεργάζεται την προεπεξεργασία των λευκών χώρων αρκετά καλά, υπάρχουν και άλλοι τύποι αλλαγών που ίσως το Git δεν μπορεί να χειριστεί αυτόματα, αλλά είναι διορθωμένες σε στίγματα.
Για παράδειγμα, ας υποθέσουμε ότι ο Git δεν μπόρεσε να χειριστεί την αλλαγή του λευκού χώρου και έπρεπε να το κάνουμε με το χέρι.

Αυτό που πραγματικά πρέπει να κάνουμε είναι να εκτελέσουμε το αρχείο που προσπαθούμε να συγχωνεύσουμε μέσω ενός προγράμματος `dos2unix` προτού δοκιμάσουμε την πραγματική συγχώνευση αρχείων.
Πώς θα το κάναμε έτσι;

What we really need to do is run the file we're trying to merge in through a `dos2unix` program before trying the actual file merge.
So how would we do that?

Πρώτον, μπαίνουμε στην κατάσταση σύγκρουσης συγχώνευσης.
Στη συνέχεια, θέλουμε να λάβουμε αντίγραφα της έκδοσης του αρχείου, της έκδοσής τους (από τον κλάδο που συγχωνεύουμε) και της κοινής έκδοσης (από όπου και οι δύο πλευρές διακλαδίζονται).
Στη συνέχεια, θέλουμε να διορθώσουμε είτε την πλευρά τους είτε την πλευρά μας και να ξαναδοκιμάσουμε τη συγχώνευση και πάλι μόνο για αυτό το μοναδικό αρχείο.

First, we get into the merge conflict state.
Then we want to get copies of my version of the file, their version (from the branch we're merging in) and the common version (from where both sides branched off).
Then we want to fix up either their side or our side and re-try the merge again  for just this single file.

Η λήψη των τριών εκδόσεων αρχείων είναι πραγματικά εύκολη.
Το Git αποθηκεύει όλες αυτές τις εκδόσεις στο ευρετήριο κάτω από τα `` στάδια '' τα οποία ο καθένας έχει τους αριθμούς που σχετίζονται με αυτά.
Το στάδιο 1 είναι ο κοινός πρόγονος, το στάδιο 2 είναι η έκδοση μας και το στάδιο 3 είναι από το `MERGE_HEAD`, την έκδοση που συγχωνεύουμε (` `theirs '').

Getting the three file versions is actually pretty easy.
Git stores all of these versions in the index under ``stages'' which each have numbers associated with them.
Stage 1 is the common ancestor, stage 2 is your version and stage 3 is from the `MERGE_HEAD`, the version you're merging in (``theirs'').

Μπορούμε να εξαγάγουμε ένα αντίγραφο από κάθε μία από αυτές τις εκδόσεις του αρχείου που βρίσκεται σε διένεξη με την εντολή `git show` και μια ειδική σύνταξη.

You can extract a copy of each of these versions of the conflicted file with the `git show` command and a special syntax.

[source,console]
----
$ git show :1:hello.rb > hello.common.rb
$ git show :2:hello.rb > hello.ours.rb
$ git show :3:hello.rb > hello.theirs.rb
----

Αν θέλουμε να πάρουμε λίγο περισσότερο σκληρό πυρήνα, μπορούμε επίσης να χρησιμοποιήσουμε την εντολή `ls-files -u` για να λάβουμε τα πραγματικά SHA-1s των Git blobs για κάθε ένα από αυτά τα αρχεία.

If you want to get a little more hard core, you can also use the `ls-files -u` plumbing command to get the actual SHA-1s of the Git blobs for each of these files.

[source,console]
----
$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb
----

Το `:1:hello.rb` είναι απλά μια συντομογραφία για να αναζητά κανείς τον αριθμό SHA-1 εκείνου του blob.

The `:1:hello.rb` is just a shorthand for looking up that blob SHA-1.

Τώρα που έχουμε το περιεχόμενο και των τριών σταδίων στον κατάλογο εργασίας μας, μπορούμε να διορθώσουμε χειροκίνητα τη δική τους για να διορθώσουμε το πρόβλημα του κεντρικού χώρου και να συγχωνεύσουμε ξανά το αρχείο με την ελάχιστα γνωστή εντολή `git merge-file` που κάνει ακριβώς αυτό.

Now that we have the content of all three stages in our working directory, we can manually fix up theirs to fix the whitespace issue and re-merge the file with the little-known `git merge-file` command which does just that.

[source,console]
----
$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb

$ git diff -b
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts 'hello world'
+   puts 'hello mundo'
  end

  hello()
----

At this point we have nicely merged the file.
In fact, this actually works better than the `ignore-space-change` option because this actually fixes the whitespace changes before merge instead of simply ignoring them.
In the `ignore-space-change` merge, we actually ended up with a few lines with DOS line endings, making things mixed.

Σε αυτό το σημείο έχουμε συγχωνεύσει ωραία το αρχείο.
Στην πραγματικότητα, αυτό λειτουργεί καλύτερα από την επιλογή `ignore-space-change ', διότι αυτό στην πραγματικότητα επιδιορθώνει τις αλλαγές του κεντρικού χώρου πριν από τη συγχώνευση αντί να τις αγνοεί απλώς.
Στη συγχώνευση `ignore-space-change`, καταλήξαμε με μερικές γραμμές με τερματισμούς γραμμής DOS, κάνοντας τα πράγματα μικτά.

Εάν θέλουμε να πάρουμε μια ιδέα πριν τελειώσουμε αυτήν τη υποβολή για το τι πραγματικά άλλαξε μεταξύ της μιας πλευράς ή της άλλης, μπορούμε να ζητήσουμε από το `git diff` να συγκρίνουμε τι υπάρχει στον κατάλογο εργασίας που πρόκειται να υποβάλουμε ως αποτέλεσμα συγχώνευση σε οποιοδήποτε από αυτά τα στάδια.
Ας περάσουμε από όλα αυτά.

If you want to get an idea before finalizing this commit about what was actually changed between one side or the other, you can ask `git diff` to compare what is in your working directory that you're about to commit as the result of the merge to any of these stages.
Let's go through them all.

Για να συγκρίνουμε το αποτέλεσμά μας με αυτό που είχαμε στον κλάδο μας πριν από τη συγχώνευση, με άλλα λόγια, για να δούμε τι εισήγαγε η συγχώνευση, μπορούμε να εκτελέσουμε την `git diff --ours`

[source,console]
----
$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

 # prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()
----

So here we can easily see that what happened in our branch, what we're actually introducing to this file with this merge, is changing that single line.

Έτσι, εδώ μπορούμε εύκολα να δούμε ότι αυτό που συνέβη στον κλάδο μας, αυτό που εισάγουμε στην πραγματικότητα σε αυτό το αρχείο με αυτήν τη συγχώνευση, αλλάζει αυτή τη μοναδική γραμμή.

Αν θέλουμε να δούμε πώς το αποτέλεσμα της συγχώνευσης διέφερε από αυτό που ήταν στο πλευρό τους, μπορούμε να εκτελέσουμε το `git diff --their`.
Σε αυτό και στο ακόλουθο παράδειγμα, πρέπει να χρησιμοποιήσουμε το `-b` για να καταργήσουμε το κενό επειδή το συγκρίνουμε με αυτό που υπάρχει στο Git, όχι το καθαρισμένο αρχείο` hello.theirs.rb`.

If we want to see how the result of the merge differed from what was on their side, you can run `git diff --theirs`.
In this and the following example, we have to use `-b` to strip out the whitespace because we're comparing it to what is in Git, not our cleaned up `hello.theirs.rb` file.

[source,console]
----
$ git diff --theirs -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello mundo'
 end
----

Τέλος, μπορούμε να δούμε πως το αρχείο έχει αλλάξει και από τις δύο πλευρές με το `git diff --base`.

Finally, you can see how the file has changed from both sides with `git diff --base`.

[source,console]
----
$ git diff --base -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()
----

Σε αυτό το σημείο μπορούμε να χρησιμοποιήσουμε την εντολή `git clean` για να ξεκαθαρίσουμε τα επιπλέον αρχεία που δημιουργήσαμε για να κάνουμε τη χειροκίνητη συγχώνευση αλλά δεν χρειάζεται πλέον.

At this point we can use the `git clean` command to clear out the extra files we created to do the manual merge but no longer need.

[source,console]
----
$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb
----

[[_checking_out_conflicts]]
===== Checking Out Conflicts

Perhaps we're not happy with the resolution at this point for some reason, or maybe manually editing one or both sides still didn't work well and we need more context.

Ίσως δεν είμαστε ευχαριστημένοι με το ψήφισμα σε αυτό το σημείο για κάποιο λόγο, ή ίσως η χειροκίνητη επεξεργασία μιας ή και των δύο πλευρών ακόμα δεν λειτούργησε καλά και χρειαζόμαστε περισσότερο περιβάλλον.

Ας αλλάξουμε λίγο το παράδειγμα.
Για αυτό το παράδειγμα, έχουμε δυο κλάδοι μεγαλύτερης διάρκειας ζωής, οι οποίοι έχουν μερικές υποβολές, αλλά δημιουργούν μια νόμιμη σύγκρουση περιεχομένου όταν συγχωνευθούν.

Let's change up the example a little.
For this example, we have two longer lived branches that each have a few commits in them but create a legitimate content conflict when merged.

[source,console]
----
$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) update README
* 9af9d3b add a README
* 694971d update phrase to hola world
| * e3eb223 (mundo) add more tests
| * 7cff591 add testing script
| * c3ffff1 changed text to hello mundo
|/
* b7dcc89 initial hello world code
----

Τώρα έχουμε τρεις μοναδικές υποβολές που ζουν μόνο στον κλάδο `master` και τρεις άλλες που ζουν στον κλάδο `mundo`.
Αν προσπαθήσουμε να συγχωνεύσουμε τον κλάδο `mundo`, παίρνουμε μία σύγκρουση.

We now have three unique commits that live only on the `master` branch and three others that live on the `mundo` branch.
If we try to merge the `mundo` branch in, we get a conflict.

[source,console]
----
$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.
----

Θα θέλαμε να δούμε τι είναι αυτή η σύγκρουση.
Αν ανοίξουμε το αρχείο, θα δούμε κάτι τέτοιο:

[source,ruby]
----
#! /usr/bin/env ruby

def hello
<<<<<<< HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
>>>>>>> mundo
end

hello()
----

Both sides of the merge added content to this file, but some of the commits modified the file in the same place that caused this conflict.

Και οι δύο πλευρές της συγχώνευσης πρόσθεσαν περιεχόμενο σε αυτό το αρχείο, αλλά μερικές από τις υποβολές τροποποίησαν το αρχείο στον ίδιο χώρο που προκάλεσε αυτή τη σύγκρουση.

Ας διερευνήσουμε μερικά εργαλεία που έχουμε τώρα στη διάθεσή μας για να καθορίσουμε πώς προέκυψε αυτή η σύγκρουση.
Ίσως δεν είναι προφανές πώς ακριβώς πρέπει να διορθώσουμε αυτή τη σύγκρουση.
Χρειαζόμαστε περισσότερο περιβάλλον.

Let's explore a couple of tools that you now have at your disposal to determine how this conflict came to be.
Perhaps it's not obvious how exactly you should fix this conflict.
You need more context.

One helpful tool is `git checkout` with the `--conflict' option.
This will re-checkout the file again and replace the merge conflict markers.
This can be useful if you want to reset the markers and try to resolve them again.

Ένα χρήσιμο εργαλείο είναι το `git checkout` με την επιλογή` --conflict '.
Αυτό θα ξανά εκτελεί το αρχείο και θα αντικαταστήσει τους δείκτες σύγκλισης συγχώνευσης.
Αυτό μπορεί να είναι χρήσιμο αν θέλουμε να επαναφέρουμε τους δείκτες και να προσπαθήσουμε να τις λύσουμε ξανά.

Μπορούμε να περάσουμε `--conflict` είτε 'diff3` είτε ' merge '(που είναι η προεπιλογή).
Εάν το περάσουμε το `diff3`, το Git θα χρησιμοποιήσει μια ελαφρώς διαφορετική έκδοση σημάτων σύγκρουσης, όχι μόνο να μας δώσει τις εκδόσεις` `ours '' και` `s '' αλλά και την έκδοση `` base '' inline για να μας δώσει περισσότερο.

You can pass `--conflict` either `diff3` or `merge` (which is the default).
If you pass it `diff3`, Git will use a slightly different version of conflict markers, not only giving you the ``ours'' and ``theirs'' versions, but also the ``base'' version inline to give you more context.

[source,console]
----
$ git checkout --conflict=diff3 hello.rb
----

Μόλις το τρέξουμε, το αρχείο θα μοιάζει με αυτό:

[source,ruby]
----
#! /usr/bin/env ruby

def hello
<<<<<<< ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
>>>>>>> theirs
end

hello()
----

Εάν μας αρέσει αυτή η μορφή, μπορούμε να την ορίσουμε ως προεπιλογή για μελλοντικές συγκρούσεις συγχώνευσης, θέτοντας την τιμή της `merge.conflictstyle` σε `diff3`.

[source,console]
----
$ git config --global merge.conflictstyle diff3
----

The `git checkout` command can also take `--ours` and `--theirs` options, which can be a really fast way of just choosing either one side or the other without merging things at all.

Η εντολή "git checkout" μπορεί επίσης να πάρει τις επιλογές `--ours 'και` --their', οι οποίες μπορεί να είναι ένας πολύ γρήγορος τρόπος για να επιλέξουμε απλά τη μια πλευρά ή την άλλη χωρίς να συγχωνεύσουμε τα πράγματα καθόλου.

Αυτό μπορεί να είναι ιδιαίτερα χρήσιμο για συγκρούσεις δυαδικών αρχείων, όπου μπορούμε απλά να επιλέξουμε μία πλευρά ή όπου θέλουμε να συγχωνεύσουμε μόνο ορισμένα αρχεία από άλλον κλάδο -- μπορούμε να κάνουμε συγχώνευση και στη συνέχεια να ολοκληρώσουμε την ολοκλήρωση κάποιων αρχείων από τη μια πλευρά ή την άλλη πριν από τη υποβολή.

This can be particularly useful for conflicts of binary files where you can simply choose one side, or where you only want to merge certain files in from another branch - you can do the merge and then checkout certain files from one side or the other before committing.

[[_merge_log]]
===== Συγχώνευση μητρώου

Another useful tool when resolving merge conflicts is `git log`.
This can help you get context on what may have contributed to the conflicts.
Reviewing a little bit of history to remember why two lines of development were touching the same area of code can be really helpful sometimes.

Ένα άλλο χρήσιμο εργαλείο κατά την επίλυση συγχωνεύσεων συγχώνευσης είναι το `git log`.
Αυτό μπορεί να μας βοηθήσει να αποκτήσουμε περιεχόμενο σχετικά με το τι μπορεί να συνέβαλε στις συγκρούσεις.
Αναθεώρηση λίγη ιστορία για να θυμόμαστε γιατί δύο γραμμές ανάπτυξης έρχονται σε επαφή με την ίδια περιοχή του κώδικα μπορεί να είναι πραγματικά χρήσιμη μερικές φορές.

Για να πάρουμε μια πλήρη λίστα με όλες τις μοναδικές υποβολές που συμπεριλήφθηκαν σε οποιονδήποτε κλάδο που συμμετέχει σε αυτήν τη συγχώνευση, μπορούμε να χρησιμοποιήσουμε τη σύνταξη `` τριπλής κουκίδας '' που μάθαμε στο <<_triple_dot>>.

To get a full list of all of the unique commits that were included in either branch involved in this merge, we can use the ``triple dot'' syntax that we learned in <<_triple_dot>>.

[source,console]
----
$ git log --oneline --left-right HEAD...MERGE_HEAD
< f1270f7 update README
< 9af9d3b add a README
< 694971d update phrase to hola world
> e3eb223 add more tests
> 7cff591 add testing script
> c3ffff1 changed text to hello mundo
----

That's a nice list of the six total commits involved, as well as which line of development each commit was on.

Αυτή είναι μια ωραία λίστα των έξι συνολικών υποβολών που εμπλέκονται, καθώς και ποια γραμμή ανάπτυξης ανέλαβε κάθε υποβολή.

Μπορούμε να απλουστεύσουμε περαιτέρω αυτό το γεγονός αν και να μας δώσουμε πολύ πιο συγκεκριμένο πλαίσιο.
Αν προσθέσουμε την επιλογή `--merge 'στο` git log`, θα εμφανιστούν μόνο οι υποβολές σε κάθε πλευρά της συγχώνευσης που αγγίζουν ένα αρχείο που βρίσκεται σε διένεξη.

We can further simplify this though to give us much more specific context.
If we add the `--merge` option to `git log`, it will only show the commits in either side of the  merge that touch a file that's currently conflicted.

[source,console]
----
$ git log --oneline --left-right --merge
< 694971d update phrase to hola world
> c3ffff1 changed text to hello mundo
----

Αν τρέξουμε αυτό με την επιλογή `-p`, αντί να πάρουμε μόνο τις διαφορές στο αρχείο που κατέληξε σε σύγκρουση.
Αυτό μπορεί να είναι ** πραγματικά ** χρήσιμο για να μας δώσει γρήγορα το πλαίσιο που χρειαζόμαστε για να καταλάβουμε γιατί κάτι συγκρούσεις και πώς να το επιλύσουμε πιο έξυπνα.

If you run that with the `-p` option instead, you get just the diffs to the file that ended up in conflict.
This can be **really** helpful in quickly giving you the context you need to help understand why something conflicts and how to more intelligently resolve it.

===== Combined Diff Format

Since Git stages any merge results that are successful, when you run `git diff` while in a conflicted merge state, you only get what is currently still in conflict.
This can be helpful to see what you still have to resolve.

Εφόσον το Git επεξεργάζεται όλα τα αποτελέσματα συγχώνευσης που είναι επιτυχημένα, όταν εκτελούμε το `git diff`, ενώ βρισκόμαστε σε μια κατάσταση σύγκρουσης συγχώνευσης, αποκτάμε μόνο ό, τι είναι ακόμα σε σύγκρουση.
Αυτό μπορεί να μας βοηθήσει να δούμε τι πρέπει ακόμα να επιλύσουμε.

Όταν τρέχουμε το `git diff` αμέσως μετά από μια σύγκρουση συγχώνευσης, θα μας δώσει πληροφορίες σε μια μάλλον μοναδική μορφή εξόδου diff.

When you run `git diff` directly after a merge conflict, it will give you information in a rather unique diff output format.

[source,console]
----
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++<<<<<<< HEAD
 +  puts 'hola world'
++=======
+   puts 'hello mundo'
++>>>>>>> mundo
  end

  hello()
----

The format is called ``Combined Diff'' and gives you two columns of data next to each line.
The first column shows you if that line is different (added or removed) between the ``ours'' branch and the file in your working directory and the second column does the same between the ``theirs'' branch and your working directory copy.

Η μορφή ονομάζεται `` Combined Diff '' και μας δίνει δύο στήλες δεδομένων δίπλα σε κάθε γραμμή.
Η πρώτη στήλη δείχνει αν αυτή η γραμμή είναι διαφορετική (προστιθέμενη ή καταργηθείσα) μεταξύ του κλάδου `` μας '' και του αρχείου στον κατάλογο εργασίας μας και η δεύτερη στήλη κάνει το ίδιο μεταξύ του κλάδου `` theirs '' και του αντιγράφου του καταλόγου εργασίας .

Έτσι σε αυτό το παράδειγμα μπορούμε να δούμε ότι οι γραμμές <<<<<<< »και`>>>>>>> `βρίσκονται στο αντίγραφο εργασίας αλλά δεν βρίσκονται σε καμία πλευρά της συγχώνευσης.
Αυτό έχει νόημα επειδή το εργαλείο συγχώνευσης τους κολλήσει εκεί για το περιβάλλον μας, αλλά αναμένεται να τα αφαιρέσουμε.

So in that example you can see that the `<<<<<<<` and `>>>>>>>` lines are in the working copy but were not in either side of the merge.
This makes sense because the merge tool stuck them in there for our context, but we're expected to remove them.

Αν επιλύσουμε τη σύγκρουση και τρέξουμε ξανά την `git diff`, θα δούμε το ίδιο πράγμα αλλά είναι λίγο πιο χρήσιμο.

If we resolve the conflict and run `git diff` again, we'll see the same thing, but it's a little more useful.

[source,console]
----
$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()
----

This shows us that ``hola world'' was in our side but not in the working copy, that ``hello mundo'' was in their side but not in the working copy and finally that ``hola mundo'' was not in either side but is now in the working copy.
This can be useful to review before committing the resolution.

Αυτό μας δείχνει ότι το `` hola world '' ήταν στο πλευρό μας, αλλά όχι στο αντίγραφο εργασίας, ότι `` hello mundo '' ήταν στο πλευρό τους αλλά όχι στο αντίγραφο εργασίας και τέλος ότι `` hola mundo '' δεν ήταν κάθε πλευρά αλλά τώρα βρίσκεται στο αντίγραφο εργασίας.
Αυτό μπορεί να είναι χρήσιμο για έλεγχο πριν από τη υποβολή της ανάλυσης.

Μπορούμε επίσης να πάρουμε αυτό από το `git log 'για οποιαδήποτε συγχώνευση μετά το γεγονός για να δούμε πώς κάτι επιλύθηκε μετά το γεγονός.
Το Git θα εκτυπώσει αυτή τη μορφή αν εκτελέσουμε το `git show` σε μια διεπαφή συγχώνευσης ή εάν προσθέσουμε μια επιλογή` - cc 'σε ένα `git log -p` (το οποίο από προεπιλογή εμφανίζει μόνο επιθέματα για μη συγχωνεύσεις).

You can also get this from the `git log` for any merge after the fact to see how something was resolved after the fact.
Git will output this format if you run `git show` on a merge commit, or if you add a `--cc` option to a `git log -p` (which by default only shows patches for non-merge commits).

[source,console]
----
$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()
----

[[_undoing_merges]]
==== Αναίρεση συγχώνευσης

Τώρα που ξέρουμε πώς να δημιουργήσουμε μια υποβολή συγχώνευσης, θα κάνουμε πιθανώς κάποια κατά λάθος.
Ένα από τα σπουδαία πράγματα για τη συνεργασία με το Git είναι ότι είναι εντάξει να κάνουμε λάθη, επειδή είναι δυνατόν (και σε πολλές περιπτώσεις εύκολο) να τα διορθώσουμε.

Now that you know how to create a merge commit, you'll probably make some by mistake.
One of the great things about working with Git is that it's okay to make mistakes, because it's possible (and in many cases easy) to fix them.

Οι υποβολές συγχώνευσης δεν διαφέρουν.
Ας υποθέσουμε ότι ξεκινήσαμε να εργαζόμαστε σε ένα κλάδο θεμάτων, συγχωνεύσαμε τον κατά λάθος σε `master` και τώρα το ιστορικό των αποστολών μας μοιάζει με αυτό:

Merge commits are no different.
Let's say you started work on a topic branch, accidentally merged it into `master`, and now your commit history looks like this:

.Accidental merge commit
image::images/undomerge-start.png[Accidental merge commit.]

Υπάρχουν δύο τρόποι προσέγγισης αυτού του προβλήματος, ανάλογα με το ποιο επιθυμούμε να είναι το αποτέλεσμα.

===== Fix the references

Εάν η ανεπιθύμητη υποβολή συγχώνευσης υπάρχει μόνο στο τοπικό αποθετήριο, η πιο εύκολη και βέλτιστη λύση είναι να μετακινήσουμε τους κλάδους ώστε να δείχνουν εκεί που θέλουμε.
Στις περισσότερες περιπτώσεις, αν ακολουθήσουμε την παράλειψη `git merge 'με` git reset --hard HEAD ~ `, αυτό θα επαναφέρει τους δείκτες κλάδων έτσι ώστε να μοιάζουν με αυτό:

If the unwanted merge commit only exists on your local repository, the easiest and best solution is to move the branches so that they point where you want them to.
In most cases, if you follow the errant `git merge` with `git reset --hard HEAD~`, this will reset the branch pointers so they look like this:

.Το ιστορικό μετά την `git reset --hard HEAD~`.
image::images/undomerge-reset.png[Το ιστορικό μετά την `git reset --hard HEAD~`.]

We covered `reset` back in <<_git_reset>>, so it shouldn't be too hard to figure out what's going on here.
Here's a quick refresher: `reset --hard` usually goes through three steps:

Καλύψαμε την επαναφορά στο <<_git_reset>>, επομένως δεν πρέπει να είναι πολύ δύσκολο να καταλάβουμε τι συμβαίνει εδώ.
Εδώ είναι μια γρήγορη ανανέωση: 'reset - hard' συνήθως περνάει από τρία βήματα:

. Μετακινήστε τα σημεία κλάδου HEAD στο.
  Σε αυτήν την περίπτωση, θέλουμε να μετακινήσουμε τον `κύριο` στον τόπο που ήταν πριν από τη συνένωση συγχώνευσης (` C6`).
. Κάντε τον δείκτη να μοιάζει με HEAD.
. Κάντε τον κατάλογο εργασίας να μοιάζει με τον ευρετήριο.

. Move the branch HEAD points to.
  In this case, we want to move `master` to where it was before the merge commit (`C6`).
. Make the index look like HEAD.
. Make the working directory look like the index.

Το μειονέκτημα αυτής της προσέγγισης είναι ότι πρόκειται για επανεγγραφή ιστορικού, το οποίο μπορεί να είναι προβληματικό με ένα κοινό αποθετήριο.
Δούμε το <<_rebase_peril>> για περισσότερα σχετικά με το τι μπορεί να συμβεί. η σύντομη έκδοση είναι ότι αν άλλοι άνθρωποι έχουν τις υποβολές που ξαναγράφουμε, θα πρέπει πιθανώς να αποφύγουμε την 'επαναφορά'.
Αυτή η προσέγγιση επίσης δεν θα λειτουργήσει εάν έχουν δημιουργηθεί άλλες υποβολές από τη συγχώνευση. η μετακίνηση των αναφορών θα χάσει αποτελεσματικά αυτές τις αλλαγές.

The downside of this approach is that it's rewriting history, which can be problematic with a shared repository.
Check out <<_rebase_peril>> for more on what can happen; the short version is that if other people have the commits you're rewriting, you should probably avoid `reset`.
This approach also won't work if any other commits have been created since the merge; moving the refs would effectively lose those changes.

[[_reverse_commit]]
===== Reverse the commit

Εάν μετακινήσουμε τους δείκτες κλάδων γύρω μας δεν πρόκειται να λειτουργήσει για εσάς, το Git μας δίνει τη δυνατότητα να κάνουμε μια νέα υποβολή, η οποία ακυρώνει όλες τις αλλαγές από μία υπάρχουσα.
Το Git ονομάζει αυτή την ενέργεια μια `` επαναφορά '', και σε αυτό το συγκεκριμένο σενάριο, θα το χρησιμοποιήσουμε ως εξής:

If moving the branch pointers around isn't going to work for you, Git gives you the option of making a new commit which undoes all the changes from an existing one.
Git calls this operation a ``revert'', and in this particular scenario, you'd invoke it like this:

[source,console]
----
$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"
----

The `-m 1` flag indicates which parent is the ``mainline'' and should be kept.
When you invoke a merge into `HEAD` (`git merge topic`), the new commit has two parents: the first one is `HEAD` (`C6`), and the second is the tip of the branch being merged in (`C4`).
In this case, we want to undo all the changes introduced by merging in parent #2 (`C4`), while keeping all the content from parent #1 (`C6`).

Η σημαία `-m 1` υποδεικνύει ποιος γονέας είναι` `mainline '' και θα πρέπει να τηρείται.
Όταν ξεκινάμε μια συγχώνευση σε `HEAD '(` git merge theme'), η νέα υποβολή έχει δύο γονείς: ο πρώτος είναι `HEAD` (` C6`) και ο δεύτερος είναι η κορυφή του κλάδου που συγχωνεύεται «C4»).
Σε αυτήν την περίπτωση, θέλουμε να αναιρέσουμε όλες τις αλλαγές που εισήχθησαν με τη συγχώνευση στο γονικό # 2 (`C4`), διατηρώντας όλο το περιεχόμενο από τον γονέα # 1 (` C6`).

Η ιστορία με την αναστροφή commit εμφανίζεται ως εξής:

The history with the revert commit looks like this:

.History after `git revert -m 1`
image::images/undomerge-revert.png[History after `git revert -m 1`.]

Η νέα δέσμη `^ M 'έχει ακριβώς το ίδιο περιεχόμενο με το` C6`, οπότε ξεκινώντας από εδώ είναι σαν να μην συνέβη ποτέ η συγχώνευση, εκτός από το γεγονός ότι οι υποβολές που τώρα δεν έχουν μεσολαβήσει εξακολουθούν να βρίσκονται στην ιστορία `HEAD`.
Το Git θα μπερδευτεί αν προσπαθήσουμε να συγχωνεύσουμε ξανά το θέμα στο master:

The new commit `^M` has exactly the same contents as `C6`, so starting from here it's as if the merge never happened, except that the now-unmerged commits are still in `HEAD`'s history.
Git will get confused if you try to merge `topic` into `master` again:

[source,console]
----
$ git merge topic
Already up-to-date.
----

Δεν υπάρχει τίποτα στο `θέμα 'που δεν είναι ήδη προσβάσιμο από το` master`.
Τι είναι χειρότερο, αν προσθέσουμε εργασία στο `θέμα 'και συγχωνεύσουμε ξανά, το Git θα φέρει μόνο τις αλλαγές _since_ την αναστροφή συγχώνευση:

There's nothing in `topic` that isn't already reachable from `master`.
What's worse, if you add work to `topic` and merge again, Git will only bring in the changes _since_ the reverted merge:

.History with a bad merge
image::images/undomerge-revert2.png[History with a bad merge.]

Ο καλύτερος τρόπος γύρω από αυτό είναι να μη επαναφέρουμε την αρχική συγχώνευση, αφού τώρα θέλουμε να φέρουμε τις αλλαγές που έχουν επανέλθει, * στη συνέχεια * δημιουργήστε μια νέα υποβολή συγχώνευσης:

The best way around this is to un-revert the original merge, since now you want to bring in the changes that were reverted out, *then* create a new merge commit:

[source,console]
----
$ git revert ^M
[master 09f0126] Revert "Revert "Merge branch 'topic'""
$ git merge topic
----

.History after re-merging a reverted merge
image::images/undomerge-revert3.png[History after re-merging a reverted merge.]

Σε αυτό το παράδειγμα, το `M` και το `^M` αλληλοεξουδετερώνονται.
Το `^^M` ουσιαστικά συγχωνεύεται στις αλλαγές από `C3` και `C4`, και`C8` συγχωνεύεται στις αλλαγές από `C7`, έτσι τώρα το `topic` συγχωνεύεται πλήρως.

In this example, `M` and `^M` cancel out.
`^^M` effectively merges in the changes from `C3` and `C4`, and `C8` merges in the changes from `C7`, so now `topic` is fully merged.

==== Άλλα είδη συγχωνεύσεων

Μέχρι στιγμής καλύψαμε την κανονική συγχώνευση δύο κλάδων, τα οποία κανονικά αντιμετωπίζονται με τη λεγόμενη `` αναδρομική '' στρατηγική συγχώνευσης.
Υπάρχουν άλλοι τρόποι συγχώνευσης των κλάδων.
Ας καλύψουμε μερικά από αυτά γρήγορα.

So far we've covered the normal merge of two branches, normally handled with what is called the ``recursive'' strategy of merging.
There are other ways to merge branches together however.
Let's cover a few of them quickly.

===== Our or Theirs Preference

First of all, there is another useful thing we can do with the normal ``recursive'' mode of merging.
We've already seen the `ignore-all-space` and `ignore-space-change` options which are passed with a `-X` but we can also tell Git to favor one side or the other when it sees a conflict.

Πρώτα απ 'όλα, υπάρχει ένα άλλο χρήσιμο πράγμα που μπορούμε να κάνουμε με το κανονικό `` αναδρομικό' 'τρόπο συγχώνευσης.
Έχουμε ήδη δει τις επιλογές `ignore-all-space` και 'ignore-space-change` που έχουν περάσει με` -X`, αλλά μπορούμε επίσης να πούμε στο Git να ευνοεί τη μία ή την άλλη πλευρά όταν βλέπει μια σύγκρουση.

Από προεπιλογή, όταν ο Git βλέπει μια σύγκρουση μεταξύ δύο συγχωνευμένων κλάδων, θα προσθέσει δείκτες σύγκλισης συγχώνευσης στον κώδικα μας και θα επισημάνει το αρχείο ως διένεξη και θα μας επιτρέψει να το επιλύσουμε.
Εάν προτιμάμε το Git να επιλέξει απλά μια συγκεκριμένη πλευρά και να αγνοήσει την άλλη πλευρά αντί να μας επιτρέψει να συγχωνεύσουμε με μη αυτόματο τρόπο τη σύγκρουση, μπορούμε να περάσουμε την εντολή `merge` είτε σε ένα `-Xours` είτε σε ένα `-Xtheirs`.

By default, when Git sees a conflict between two branches being merged, it will add merge conflict markers into your code and mark the file as conflicted and let you resolve it.
If you would prefer for Git to simply choose a specific side and ignore the other side instead of letting you manually merge the conflict, you can pass the `merge` command either a `-Xours` or `-Xtheirs`.

If Git sees this, it will not add conflict markers.
Any differences that are mergeable, it will merge.
Any differences that conflict, it will simply choose the side you specify in whole, including binary files.

Εάν το Git το βλέπει αυτό, δεν θα προσθέσει δείκτες σύγκρουσης.
Τυχόν διαφορές που μπορούν να συγχωνευθούν, θα συγχωνευθούν.
Οποιεσδήποτε διαφορές που συγκρούονται, απλά θα επιλέξει την πλευρά που καθορίζουμε στο σύνολό της, συμπεριλαμβανομένων των δυαδικών αρχείων.

Εάν επιστρέψουμε στο παράδειγμα `hello world 'που χρησιμοποιήσαμε πριν, μπορούμε να δούμε ότι η συγχώνευση στον κλάδο μας προκαλεί συγκρούσεις.

If we go back to the ``hello world'' example we were using before, we can see that merging in our branch causes conflicts.

[source,console]
----
$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.
----

Ωστόσο, αν την τρέξουμε με `-Xours` ή -XTheirs` δεν το κάνει.

[source,console]
----
$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh
----

In that case, instead of getting conflict markers in the file with ``hello mundo'' on one side and ``hola world'' on the other, it will simply pick ``hola world''.
However, all the other non-conflicting changes on that branch are merged successfully in.

Σε αυτή την περίπτωση, αντί να πάρει δείκτες σύγκρουσης στο αρχείο με `hello mundo 'στη μία πλευρά και` `hola world' 'από την άλλη, θα επιλέξει απλά` `hola world' '.
Ωστόσο, όλες οι άλλες μη-αντιφατικές αλλαγές σε αυτόν τον κλάδο συγχωνεύονται με επιτυχία.

Αυτή η επιλογή μπορεί επίσης να μεταβιβαστεί στην εντολή `git merge-file` που είδαμε νωρίτερα τρέχοντας κάτι σαν το` git merge-file --ours 'για μεμονωμένες συγχωνεύσεις αρχείων.

This option can also be passed to the `git merge-file` command we saw earlier by running something like `git merge-file --ours` for individual file merges.

If you want to do something like this but not have Git even try to merge changes from the other side in, there is a more draconian option, which is the ``ours'' merge _strategy_.
This is different from the ``ours'' recursive merge _option_.

Εάν θέλουμε να κάνουμε κάτι τέτοιο αλλά δεν έχουμε προσπαθήσει να συγχωνεύσουμε τις αλλαγές από την άλλη πλευρά, υπάρχει μια πιο δρακόντεια επιλογή, η οποία είναι η `` ours '' merge _strategy_.
Αυτό είναι διαφορετικό από το `` μας '' recursive merge _option_.

Αυτό θα κάνει βασικά μια ψεύτικη συγχώνευση.
Θα καταγράψει μια νέα υποβολή συγχώνευσης με τους δύο κλάδους ως γονείς, αλλά δεν θα εξετάσει καν τον κλάδο στον οποίο συγχωνευόμαστε.
Θα καταγράψει απλώς ως αποτέλεσμα της συγχώνευσης τον ακριβή κώδικα στον τρέχοντα κλάδο μας.

This will basically do a fake merge.
It will record a new merge commit with both branches as parents, but it will not even look at the branch you're merging in.
It will simply record as the result of the merge the exact code in your current branch.

[source,console]
----
$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$
----

Μπορούμε να δούμε ότι δεν υπάρχει διαφορά μεταξύ του κλάδου στον οποίο βρισκόμασταν και του αποτελέσματος της συγχώνευσης.

Αυτό μπορεί συχνά να είναι χρήσιμο να υπονομεύσει το Git να σκεφτεί ότι ένας κλάδος είναι ήδη συγχωνευμένος όταν κάνει συγχώνευση αργότερα.
Για παράδειγμα, ας πούμε ότι διακλάδασα από έναν κλάδο `` release '' και κάναμε κάποια εργασία σε αυτό που θα θελήσουμε να συγχωνεύσουμε ξανά τον κλάδο '' master '' σε κάποιο σημείο.
Εν τω μεταξύ, κάποια bugfix στο `` master '' πρέπει να επιστραφεί στον κλάδο `release '.
Μπορούμε να συγχωνεύσουμε τον κλάδο bugfix στον κλάδο `release 'και επίσης να συγχωνεύσουμε τον ίδιο κλάδο στον κλάδο` master` (ακόμα κι αν η λύση είναι ήδη εκεί) έτσι ώστε όταν συγχωνεύσουμε ξανά τον κλάδο `release' δεν υπάρχουν συγκρούσεις από τη διόρθωση σφαλμάτων.

This can often be useful to basically trick Git into thinking that a branch is already merged when doing a merge later on.
For example, say you branched off a ``release'' branch and have done some work on it that you will want to merge back into your ``master'' branch at some point.
In the meantime some bugfix on ``master'' needs to be backported into your `release` branch.
You can merge the bugfix branch into the `release` branch and also `merge -s ours` the same branch into your `master` branch (even though the fix is already there) so when you later merge the `release` branch again, there are no conflicts from the bugfix.

include::subtree-merges.asc[]
