[[_git_stashing]]
=== Stashing and Cleaning

Often, when you’ve been working on part of your project, things are in a messy state and you want to switch branches for a bit to work on something else.
The problem is, you don’t want to do a commit of half-done work just so you can get back to this point later.
The answer to this issue is the `git stash` command.

Συχνά, όταν εργαζόμαστε σε ένα μέρος του έργου μας, τα πράγματα είναι σε ακατάστατη κατάσταση και θέλουμε να αλλάξουμε τους κλάδους για λίγο για να εργαστούμε σε κάτι άλλο.
Το πρόβλημα είναι ότι δεν θέλουμε να κάνουμε μια εργασία μισής εργασίας, έτσι ώστε να μπορέσουμε να επιστρέψουμε σε αυτό το σημείο αργότερα.
Η απάντηση σε αυτό το ζήτημα είναι η εντολή git stash.

Η αποθήκευση παίρνει τη βρώμικη κατάσταση του καταλόγου εργασίας μας -- δηλαδή τα τροποποιημένα αρχεία παρακολούθησης και τις σταδιακές αλλαγές -- και την αποθηκεύει σε μια στοίβα μη ολοκληρωμένων αλλαγών που μπορούμε να εφαρμόσουμε ξανά ανά πάσα στιγμή.

Stashing takes the dirty state of your working directory – that is, your modified tracked files and staged changes – and saves it on a stack of unfinished changes that you can reapply at any time.

==== Stashing Your Work

Για να αποδείξουμε, θα πάμε στο έργο μας και θα αρχίσουμε να εργαζόμαστε σε μερικά αρχεία και ενδεχομένως να πραγματοποιήσουμε μία από τις αλλαγές.
Εάν εκτελούμε την κατάσταση `git ', μπορούμε να δούμε τη βρώμικη κατάστασή μας:

To demonstrate, you’ll go into your project and start working on a couple of files and possibly stage one of the changes.
If you run `git status`, you can see your dirty state:

[source,console]
----
$ git status
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lib/simplegit.rb
----

Τώρα θέλουμε να αλλάξουμε κλάδους, αλλά δεν θέλουμε να υποβάλουμε για το τι εργαζόμαστε ακόμα. έτσι θα αποθηκεύσουμε τις αλλαγές.
Για να προωθήσουμε μια νέα στοίβα στη στοίβα μας, εκτελέστε `git stash` ή 'git stash save':

Now you want to switch branches, but you don’t want to commit what you’ve been working on yet; so you’ll stash the changes.
To push a new stash onto your stack, run `git stash` or `git stash save`:

[source,console]
----
$ git stash
Saved working directory and index state \
  "WIP on master: 049d078 added the index file"
HEAD is now at 049d078 added the index file
(To restore them type "git stash apply")
----

Ο κατάλογος εργασίας μας είναι καθαρός:

[source,console]
----
$ git status
# On branch master
nothing to commit, working directory clean
----

Σε αυτό το σημείο, μπορούμε εύκολα να αλλάξουμε κλάδους και να εργαστούμε αλλού. οι αλλαγές μας αποθηκεύονται στη στοίβα μας.
Για να δούμε ποιες εντολές έχουμε αποθηκεύσει, μπορούμε να χρησιμοποιήσουμε τη λίστα git stash:

At this point, you can easily switch branches and do work elsewhere; your changes are stored on your stack.
To see which stashes you’ve stored, you can use `git stash list`:

[source,console]
----
$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log
----

Σε αυτή την περίπτωση, έγιναν δύο κλίκες στο παρελθόν, οπότε έχουμε πρόσβαση σε τρία διαφορετικά κλασσικά έργα.
Μπορούμε να εφαρμόσουμε ξανά αυτό που απλά έχουμε κρατήσει χρησιμοποιώντας την εντολή που εμφανίζεται στην έξοδο βοήθειας της αρχικής εντολής stash: 'git stash apply'.
Εάν θέλουμε να εφαρμόσουμε μία από τις παλαιότερες εντολές, μπορούμε να την ορίσουμε με την ονομασία της, όπως παρακάτω: 'git stash apply stash @ {2}'.
Εάν δεν καθορίσουμε μια απόρριψη, το Git αναλαμβάνει την πιο πρόσφατη απόρριψη και προσπαθεί να την εφαρμόσει:

In this case, two stashes were done previously, so you have access to three different stashed works.
You can reapply the one you just stashed by using the command shown in the help output of the original stash command: `git stash apply`.
If you want to apply one of the older stashes, you can specify it by naming it, like this: `git stash apply stash@{2}`.
If you don’t specify a stash, Git assumes the most recent stash and tries to apply it:

[source,console]
----
$ git stash apply
# On branch master
# Changed but not updated:
#   (use "git add <file>..." to update what will be committed)
#
#      modified:   index.html
#      modified:   lib/simplegit.rb
#
----

You can see that Git re-modifies the files you reverted when you saved the stash.
In this case, you had a clean working directory when you tried to apply the stash, and you tried to apply it on the same branch you saved it from; but having a clean working directory and applying it on the same branch aren’t necessary to successfully apply a stash.
You can save a stash on one branch, switch to another branch later, and try to reapply the changes.
You can also have modified and uncommitted files in your working directory when you apply a stash – Git gives you merge conflicts if anything no longer applies cleanly.

Μπορούμε να δούμε ότι το Git τροποποιεί εκ νέου τα αρχεία που επαναφέραμε όταν αποθηκεύσαμε το stash.
Σε αυτήν την περίπτωση, είχαμε έναν καθαρό κατάλογο εργασίας όταν προσπαθήσαμε να εφαρμόσουμε το stash και προσπαθήσαμε να το εφαρμόσουμε στον ίδιο κλάδο από τον οποίο το αποθηκεύσατε. αλλά έχοντας έναν καθαρό κατάλογο εργασίας και την εφαρμογή του στον ίδιο κλάδο δεν είναι απαραίτητο να εφαρμόσουμε επιτυχώς ένα stash.
Μπορούμε να αποθηκεύσουμε ένα απόθεμα σε ένα κλάδο, να μεταβούμε αργότερα σε άλλο κλάδο και να προσπαθήσουμε να εφαρμόσουμε ξανά τις αλλαγές.
Μπορούμε επίσης να έχουμε τροποποιημένα και μη υποβλημένα αρχεία στον κατάλογο εργασίας μας όταν εφαρμόζουμε ένα stash -- το Git μάς δίνει συγκρούσεις συγχώνευσης αν κάτι δεν ισχύει πλέον καθαρά.

Οι αλλαγές στα αρχεία μας εφαρμόστηκαν ξανά, αλλά το αρχείο που πραγματοποιήσαμε προηγουμένως δεν επαναλήφθηκε.
Για να το κάνουμε αυτό, πρέπει να εκτελέσουμε την εντολή `git stash apply 'με μια επιλογή` --index' για να πούμε στην εντολή να προσπαθήσει να εφαρμόσει ξανά τις σταδιακές αλλαγές.
Εάν είχαμε τρέξει αυτό αντ 'αυτού, θα είχαμε επιστρέψει στην αρχική μας θέση:

The changes to your files were reapplied, but the file you staged before wasn’t restaged.
To do that, you must run the `git stash apply` command with a `--index` option to tell the command to try to reapply the staged changes.
If you had run that instead, you’d have gotten back to your original position:

[source,console]
----
$ git stash apply --index
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#      modified:   index.html
#
# Changed but not updated:
#   (use "git add <file>..." to update what will be committed)
#
#      modified:   lib/simplegit.rb
#
----

Η εφαρμογή που εφαρμόζεται μόνο προσπαθεί να εφαρμόσει την αστείρευτη εργασία - συνεχίζουμε να τη έχουμε στη στοίβα μας.
Για να το καταργήσουμε, μπορούμε να εκτελέσουμε το `git stash drop` με το όνομα του stash για να καταργήσετε:

The apply option only tries to apply the stashed work – you continue to have it on your stack.
To remove it, you can run `git stash drop` with the name of the stash to remove:

[source,console]
----
$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log
$ git stash drop stash@{0}
Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)
----

Μπορούμε επίσης να εκτελέσουμε το `git stash pop` για να εφαρμόσουμε το stash και στη συνέχεια να το αφήσουμε αμέσως από τη στοίβα μας.

You can also run `git stash pop` to apply the stash and then immediately drop it from your stack.

==== Creative Stashing

There are a few stash variants that may also be helpful.
The first option that is quite popular is the `--keep-index` option to the `stash save` command.
This tells Git to not stash anything that you've already staged with the `git add` command.

Υπάρχουν μερικές παραλλαγές stash που μπορεί επίσης να είναι χρήσιμες.
Η πρώτη επιλογή που είναι αρκετά δημοφιλής είναι η επιλογή `--keep-index` στην εντολή` stash save`.
Αυτό λέει στον Git να μην καταστήσει τίποτα που έχουμε ήδη οργάνωσε με την εντολή `git add`.

Αυτό μπορεί να είναι πραγματικά χρήσιμο αν έχουμε κάνει αρκετές αλλαγές, αλλά θέλουμε να υποβάλλουμε μόνο μερικές από αυτές και στη συνέχεια να επιστρέψουμε στις υπόλοιπες αλλαγές αργότερα.

This can be really helpful if you've made a number of changes but want to only commit some of them and then come back to the rest of the changes at a later time.

[source,console]
----
$ git status -s
M  index.html
 M lib/simplegit.rb

$ git stash --keep-index
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
M  index.html
----

Ένα άλλο συνηθισμένο πράγμα που μπορεί να θέλουμε να κάνουμε με το stash είναι να αποθηκεύσουμε τα untracked αρχεία καθώς και τα tracked αυτά.
Από προεπιλογή, το `git stash` θα αποθηκεύει μόνο αρχεία που βρίσκονται ήδη στο ευρετήριο.
Εάν καθορίσουμε το `--include-untracked` ή το` -u`, το Git θα αποθηκεύσει επίσης όλα τα μη κρυπτογραφημένα αρχεία που έχουμε δημιουργήσει.

Another common thing you may want to do with stash is to stash the untracked files as well as the tracked ones.
By default, `git stash` will only store files that are already in the index.
If you specify `--include-untracked` or `-u`, Git will also stash any untracked files you have created.

[source,console]
----
$ git status -s
M  index.html
 M lib/simplegit.rb
?? new-file.txt

$ git stash -u
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
$
----

Τέλος, αν ορίσουμε τη σημαία `--patch ', το Git δεν θα αποθηκεύσει όλα όσα τροποποιούνται, αλλά θα μας προειδοποιήσει αλληλεπιδραστικά ποια από τις αλλαγές που θέλουμε να αποθηκεύσουμε και τα οποία θέλουμε να διατηρήσουμε στον κατάλογο εργασίας μας.

Finally, if you specify the `--patch` flag, Git will not stash everything that is modified but will instead prompt you interactively which of the changes you would like to stash and which you would like to keep in your working directory.

[source,console]
----
$ git stash --patch
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 66d332e..8bb5674 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -16,6 +16,10 @@ class SimpleGit
         return `#{git_cmd} 2>&1`.chomp
       end
     end
+
+    def show(treeish = 'master')
+      command("git show #{treeish}")
+    end

 end
 test
Stash this hunk [y,n,q,a,d,/,e,?]? y

Saved working directory and index state WIP on master: 1b65b17 added the index file
----


==== Creating a Branch from a Stash

Εάν αφήσουμε κάποια εργασία, αφήστε την εκεί για λίγο και συνεχίστε στον κλάδο από το οποίο βάλαμε το έργο, μπορεί να έχουμε πρόβλημα να υποβάλουμε ξανά το έργο.
Αν το αίτημα προσπαθήσει να τροποποιήσει ένα αρχείο που έχουμε τροποποιήσει από τότε, θα έχουμε μια σύγκρουση συγχώνευσης και θα πρέπει να προσπαθήσουμε να το επιλύσουμε.
Εάν θέλουμε έναν πιο εύκολο τρόπο για να δοκιμάσουμε ξανά τις αποθηκευμένες αλλαγές, μπορούμε να εκτελέσουμε το `git stash branch`, το οποίο δημιουργεί έναν νέο κλάδο για εσάς, ελέγχει τη δέσμευση στην οποία βρισκόσασταν όταν σκεπάσαμε την εργασία μας, επαναλάβουμε την εργασία μας εκεί και στη συνέχεια ρίχνει το απόθεμα αν εφαρμόζεται με επιτυχία:

If you stash some work, leave it there for a while, and continue on the branch from which you stashed the work, you may have a problem reapplying the work.
If the apply tries to modify a file that you’ve since modified, you’ll get a merge conflict and will have to try to resolve it.
If you want an easier way to test the stashed changes again, you can run `git stash branch`, which creates a new branch for you, checks out the commit you were on when you stashed your work, reapplies your work there, and then drops the stash if it applies successfully:

[source,console]
----
$ git stash branch testchanges
Switched to a new branch "testchanges"
# On branch testchanges
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#      modified:   index.html
#
# Changed but not updated:
#   (use "git add <file>..." to update what will be committed)
#
#      modified:   lib/simplegit.rb
#
Dropped refs/stash@{0} (f0dfc4d5dc332d1cee34a634182e168c4efc3359)
----

Πρόκειται για μια ωραία συντόμευση για να ανακτήσουμε εύκολα την εργασία και να την εργαστούμε σε έναν νέο κλάδο.

This is a nice shortcut to recover stashed work easily and work on it in a new branch.

[[_git_clean]]
==== Cleaning your Working Directory

Τέλος, μπορεί να μην θέλουμε να αποθηκεύσουμε κάποια εργασία ή αρχεία στον κατάλογο εργασίας μας, αλλά απλά να τα απαλλαγούμε από αυτά.
Η εντολή git clean θα το κάνει αυτό για εσάς.

Finally, you may not want to stash some work or files in your working directory, but simply get rid of them.
The `git clean` command will do this for you.

Some common reasons for this might be to remove cruft that has been generated by merges or external tools or to remove build artifacts in order to run a clean build.

Μερικοί συνηθισμένοι λόγοι για αυτό ίσως είναι να αφαιρέσουμε το cruft που έχει δημιουργηθεί από συγχωνεύσεις ή εξωτερικά εργαλεία ή να αφαιρέσουμε αντικείμενα δημιουργίας για να εκτελέσουμε μια καθαρή κατασκευή.

Θα θέλουμε να είστε πολύ προσεκτικοί με αυτήν την εντολή, αφού έχει σχεδιαστεί για να αφαιρέσει αρχεία από τον κατάλογο εργασίας που δεν παρακολουθούνται.
Εάν αλλάξουμε γνώμη, συχνά δεν υπάρχει ανάκτηση του περιεχομένου των αρχείων αυτών.
Μια ασφαλέστερη επιλογή είναι να εκτελέσουμε το `git stash --all` για να καταργήσουμε όλα, αλλά να το αποθηκεύσουμε σε ένα stash.

You'll want to be pretty careful with this command, since it's designed to remove files from your working directory that are not tracked.
If you change your mind, there is often no retrieving the content of those files.
A safer option is to run `git stash --all` to remove everything but save it in a stash.

Assuming you do want to remove cruft files or clean your working directory, you can do so with `git clean`.
To remove all the untracked files in your working directory, you can run `git clean -f -d`, which removes any files and also any subdirectories that become empty as a result.
The `-f` means 'force' or "really do this".

Υποθέτοντας ότι θέλουμε να αφαιρέσουμε τα αρχεία cruft ή να καθαρίσουμε τον κατάλογο εργασίας, μπορούμε να το κάνουμε με το `git clean`.
Για να καταργήσουμε όλα τα μη κρυπτογραφημένα αρχεία στον κατάλογο εργασίας μας, μπορούμε να εκτελέσουμε το `git clean -f -d`, το οποίο αφαιρεί όλα τα αρχεία καθώς και όλους τους υποκαταλόγους που γίνονται κενά ως αποτέλεσμα.
Το «-f» σημαίνει «δύναμη» ή «πραγματικά το κάνετε».

Αν θέλουμε ποτέ να δούμε τι θα έκανε, μπορούμε να εκτελέσουμε την εντολή με την επιλογή `-n`, που σημαίνει` `να κάνουμε μια ξηρή διαδρομή και να μου πούμε τι θα πρέπει να αφαιρέσουμε ''.

If you ever want to see what it would do, you can run the command with the `-n` option, which means ``do a dry run and tell me what you _would_ have removed''.

[source,console]
----
$ git clean -d -n
Would remove test.o
Would remove tmp/
----

Από προεπιλογή, η εντολή `git clean` θα αφαιρέσει μόνο μη κρυπτογραφημένα αρχεία που δεν αγνοούνται.
Δεν αρχειοθετείται κανένα αρχείο που ταιριάζει με ένα μοτίβο στο αρχείο .gitignore ή άλλα αρχεία.
Εάν θέλουμε να καταργήσουμε και αυτά τα αρχεία, όπως για να καταργήσουμε όλα τα αρχεία `.o` που δημιουργούνται από ένα build, ώστε να μπορούμε να κάνουμε μια καθαρή κατασκευή, μπορούμε να προσθέσουμε ένα` -x` στην καθαρή εντολή.

By default, the `git clean` command will only remove untracked files that are not ignored.
Any file that matches a pattern in your `.gitignore` or other ignore files will not be removed.
If you want to remove those files too, such as to remove all `.o` files generated from a build so you can do a fully clean build, you can add a `-x` to the clean command.

[source,console]
----
$ git status -s
 M lib/simplegit.rb
?? build.TMP
?? tmp/

$ git clean -n -d
Would remove build.TMP
Would remove tmp/

$ git clean -n -d -x
Would remove build.TMP
Would remove test.o
Would remove tmp/
----

If you don't know what the `git clean` command is going to do, always run it with a `-n` first to double check before changing the `-n` to a `-f` and doing it for real.
The other way you can be careful about the process is to run it with the `-i` or ``interactive'' flag.

Εάν δεν ξέρουμε τι πρόκειται να κάνει η εντολή `git clean`, εκτελέστε την πάντα με ένα` -n` πρώτα για να κάνουμε διπλό έλεγχο πριν αλλάξουμε το `-n` σε ένα` -f` και το κάνουμε πραγματικό.
Ο άλλος τρόπος με τον οποίο μπορούμε να είστε προσεκτικοί σχετικά με τη διαδικασία είναι να το εκτελέσουμε με τη σημαία `-i` ή` `interactive ''.

Αυτό θα εκτελέσει την καθαρή εντολή σε μια διαδραστική λειτουργία.

This will run the clean command in an interactive mode.

[source,console]
----
$ git clean -x -i
Would remove the following items:
  build.TMP  test.o
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit
    6: help
What now>
----

This way you can step through each file individually or specify patterns for deletion interactively.

This way you can step through each file individually or specify patterns for deletion interactively.
