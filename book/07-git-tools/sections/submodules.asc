[[_git_submodules]]
=== Υπομονάδες

It often happens that while working on one project, you need to use another project from within it.
Perhaps it’s a library that a third party developed or that you’re developing separately and using in multiple parent projects.
A common issue arises in these scenarios: you want to be able to treat the two projects as separate yet still be able to use one from within the other.

Συχνά συμβαίνει ότι ενώ εργαζόμαστε σε ένα έργο, θα πρέπει να χρησιμοποιήσουμε ένα άλλο έργο μέσα από αυτό.
Ίσως πρόκειται για μια βιβλιοθήκη που έχει αναπτυχθεί από ένα τρίτο μέρος ή ότι αναπτύσσεται ξεχωριστά και χρησιμοποιείται σε πολλά γονικά έργα.
Ένα κοινό ζήτημα προκύπτει σε αυτά τα σενάρια: θέλουμε να είμαστε σε θέση να αντιμετωπίζουμε τα δύο έργα ως ξεχωριστά αλλά ακόμα να μπορούμε να τα χρησιμοποιούμε μέσα από το άλλο.

Ακολουθεί ένα παράδειγμα.
Ας υποθέσουμε ότι αναπτύσσουμε έναν ιστότοπο και δημιουργούμε ροές Atom.
Αντί να γράφουμε τον δικό μας κώδικα δημιουργίας ατμόσφαιρας, αποφασίζουμε να χρησιμοποιήσουμε μια βιβλιοθήκη.
Είναι πιθανό να πρέπει να συμπεριλάβουμε αυτόν τον κώδικα από μια κοινόχρηστη βιβλιοθήκη όπως μια εγκατάσταση CPAN ή Ruby gem ή να αντιγράψουμε τον πηγαίο κώδικα στο δικό μας δέντρο έργου.
Το πρόβλημα με τη συμπερίληψη της βιβλιοθήκης είναι ότι είναι δύσκολο να προσαρμόσουμε τη βιβλιοθήκη με οποιονδήποτε τρόπο και συχνά πιο δύσκολο να την αναπτύξουμε, επειδή πρέπει να βεβαιωθούμε ότι κάθε πελάτης διαθέτει αυτή τη βιβλιοθήκη.
Το ζήτημα με την παράδοση του κώδικα στο δικό μας έργο είναι ότι τυχόν προσαρμοσμένες αλλαγές που κάνουμε είναι δύσκολο να συγχωνευθούν όταν είναι διαθέσιμες οι μεταγενέστερες αλλαγές.

Here’s an example.
Suppose you’re developing a web site and creating Atom feeds.
Instead of writing your own Atom-generating code, you decide to use a library.
You’re likely to have to either include this code from a shared library like a CPAN install or Ruby gem, or copy the source code into your own project tree.
The issue with including the library is that it’s difficult to customize the library in any way and often more difficult to deploy it, because you need to make sure every client has that library available.
The issue with vendoring the code into your own project is that any custom changes you make are difficult to merge when upstream changes become available.

Το Git αντιμετωπίζει αυτό το πρόβλημα χρησιμοποιώντας υπομονάδες.
Τα υπομονάδες μας επιτρέπουν να διατηρούμε ένα αποθετήριο Git ως υποκατάλογο άλλης αποθήκης Git.
Αυτό μας επιτρέπει να κλωνοποιήσουμε ένα άλλο αποθετήριο στο έργο μας και να κρατήσουμε ξεχωριστές τις υποβολές μας.

Git addresses this issue using submodules.
Submodules allow you to keep a Git repository as a subdirectory of another Git repository.
This lets you clone another repository into your project and keep your commits separate.

[[_starting_submodules]]
==== Starting with Submodules

We'll walk through developing a simple project that has been split up into a main project and a few sub-projects.

Θα ξεπεράσουμε την ανάπτυξη ενός απλού έργου που έχει χωριστεί σε ένα κύριο έργο και σε μερικά υπο-έργα.

Ας αρχίσουμε προσθέτοντας ένα υπάρχον αποθετήριο Git ως υπομονάδα του repository στο οποίο εργαζόμαστε.
Για να προσθέσουμε ένα νέο υπομονάδα χρησιμοποιούμε την εντολή `git submodule add` με την απόλυτη ή σχετική διεύθυνση URL του έργου που θέλουμε να αρχίσουμε να παρακολουθούμε.
Σε αυτό το παράδειγμα, θα προσθέσουμε μια βιβλιοθήκη που ονομάζεται `` DbConnector ''.

Let's start by adding an existing Git repository as a submodule of the repository that we're working on.
To add a new submodule you use the `git submodule add` command with the absolute or relative URL of the project you would like to start tracking.
In this example, we'll add a library called ``DbConnector''.

[source,console]
----
$ git submodule add https://github.com/chaconinc/DbConnector
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
----

By default, submodules will add the subproject into a directory named the same as the repository, in this case ``DbConnector''.
You can add a different path at the end of the command if you want it to go elsewhere.

Από προεπιλογή, τα υπομονάδες θα προσθέσουν το υποέργο σε έναν κατάλογο που ονομάζεται το ίδιο με τον αποθετήριο, στην περίπτωση αυτή `` DbConnector ''.
Μπορούμε να προσθέσουμε μια διαφορετική διαδρομή στο τέλος της εντολής, εάν θέλουμε να πάει αλλού.

Εάν εκτελέσουμε την `git status` σε αυτό το σημείο, θα παρατηρήσουμε μερικά πράγματα.

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   .gitmodules
	new file:   DbConnector
----

Πρώτα θα πρέπει να παρατηρήσουμε το νέο αρχείο .gitmodules.
Αυτό είναι ένα αρχείο διαμόρφωσης που αποθηκεύει τη χαρτογράφηση μεταξύ της διεύθυνσης URL του έργου και του τοπικού κλάδου που τον έχουμε τραβήξει σε:

First you should notice the new `.gitmodules` file.
This is a configuration file that stores the mapping between the project’s URL and the local subdirectory you’ve pulled it into:

[source,console]
----
$ cat .gitmodules
[submodule "DbConnector"]
	path = DbConnector
	url = https://github.com/chaconinc/DbConnector
----

Εάν έχουμε πολλά υπομονάδες, θα έχουμε πολλαπλές καταχωρήσεις σε αυτό το αρχείο.
Είναι σημαντικό να σημειωθεί ότι αυτό το αρχείο είναι ελεγχόμενο από την έκδοση με τα άλλα αρχεία μας, όπως το αρχείο .gitignore.
Είναι ώθησε και τράβηξε με το υπόλοιπο του έργου μας.
Αυτός είναι ο τρόπος με τον οποίο οι άλλοι άνθρωποι που κλωνοποιούν αυτό το έργο γνωρίζουν από πού να πάρουν τα έργα υπομπόλων από.

If you have multiple submodules, you’ll have multiple entries in this file.
It’s important to note that this file is version-controlled with your other files, like your `.gitignore` file.
It’s pushed and pulled with the rest of your project.
This is how other people who clone this project know where to get the submodule projects from.

[ΣΗΜΕΙΩΣΗ]
=====
Δεδομένου ότι η διεύθυνση URL στο αρχείο .gitmodules είναι αυτό που θα προσπαθήσουν πρώτα να κλωνοποιήσουν / προσελκύσουν άλλοι χρήστες, βεβαιωθούμε ότι χρησιμοποιούμε μια διεύθυνση URL που μπορούν να έχουν πρόσβαση εάν είναι δυνατόν.
Για παράδειγμα, αν χρησιμοποιούμε διαφορετική διεύθυνση URL για να πιέσουμε από ό, τι θα έπρεπε να τραβήξουν οι άλλοι, χρησιμοποιήστε αυτήν που έχουν πρόσβαση άλλοι.
Μπορούμε να αντικαταστήσουμε αυτή την τιμή τοπικά με το `git config submodule.DbConnector.url PRIVATE_URL` για δική μας χρήση.
Όταν ισχύει, μια σχετική διεύθυνση URL μπορεί να είναι χρήσιμη.
=====

Η άλλη λίστα στην έξοδο `git status 'είναι η καταχώρηση του φακέλου του έργου.
Εάν εκτελέσουμε το `git diff`, βλέπουμε κάτι ενδιαφέρον:

The other listing in the `git status` output is the project folder entry.
If you run `git diff` on that, you see something interesting:

[source,console]
----
$ git diff --cached DbConnector
diff --git a/DbConnector b/DbConnector
new file mode 160000
index 0000000..c3f01dc
--- /dev/null
+++ b/DbConnector
@@ -0,0 +1 @@
+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc
----

Although `DbConnector` is a subdirectory in your working directory, Git sees it as a submodule and doesn’t track its contents when you’re not in that directory.
Instead, Git sees it as a particular commit from that repository.

Αν και ο `DbConnector` είναι ένας υποκατάλογος στον κατάλογο εργασίας μας, το Git το βλέπει ως υπομονάδα και δεν παρακολουθεί τα περιεχόμενά του όταν δεν βρισκόμαστε στον κατάλογο.
Αντ 'αυτού, το Git το θεωρεί ως μια ιδιαίτερη υποβολή από αυτόν τον αποθετήριο.

Αν θέλουμε λίγο πιο έξυπνη έξοδο diff, μπορούμε να περάσουμε την επιλογή `- submodule` στο` git diff`.

If you want a little nicer diff output, you can pass the `--submodule` option to `git diff`.

[source,console]
----
$ git diff --cached --submodule
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..71fc376
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "DbConnector"]
+       path = DbConnector
+       url = https://github.com/chaconinc/DbConnector
Submodule DbConnector 0000000...c3f01dc (new submodule)
----

Όταν υποβάλλουμε, βλέπουμε κάτι τέτοιο:

[source,console]
----
$ git commit -am 'added DbConnector module'
[master fb9093c] added DbConnector module
 2 files changed, 4 insertions(+)
 create mode 100644 .gitmodules
 create mode 160000 DbConnector
----

Παρατηρήστε τη λειτουργία `160000` για την καταχώρηση` DbConnector`.
Αυτή είναι μια ειδική λειτουργία στο Git που ουσιαστικά σημαίνει ότι καταγράφουμε μια υποβολή ως καταχώρηση καταλόγου και όχι ως υποκατάλογο ή αρχείο.

Notice the `160000` mode for the `DbConnector` entry.
That is a special mode in Git that basically means you’re recording a commit as a directory entry rather than a subdirectory or a file.

[[_cloning_submodules]]
==== Κλωνοποίηση έργου με υπομονάδες

Εδώ θα κλωνοποιήσουμε ένα έργο με ένα υπομπόριο σε αυτό.
Όταν κλωνοποιούμε ένα τέτοιο έργο, από προεπιλογή εμφανίζονται οι κατάλογοι που περιέχουν υπομονάδες, αλλά κανένα από τα αρχεία μέσα σε αυτά ακόμα:

Here we’ll clone a project with a submodule in it.
When you clone such a project, by default you get the directories that contain submodules, but none of the files within them yet:

[source,console]
----
$ git clone https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
$ cd MainProject
$ ls -la
total 16
drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .
drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..
drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git
-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodules
drwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector
-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefile
drwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includes
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scripts
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src
$ cd DbConnector/
$ ls
$
----

Ο κατάλογος `DbConnector` είναι εκεί, αλλά κενός.
Πρέπει να εκτελέσουμε δύο εντολές: `git submodule init` για την αρχικοποίηση του τοπικού μας αρχείου ρυθμίσεων και` git update submodule` για να συγκεντρώσει όλα τα δεδομένα από το έργο και να ελέγξει την κατάλληλη υποβολή που αναφέρεται στο superproject μας:

The `DbConnector` directory is there, but empty.
You must run two commands: `git submodule init` to initialize your local configuration file, and `git submodule update` to fetch all the data from that project and check out the appropriate commit listed in your superproject:

[source,console]
----
$ git submodule init
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
$ git submodule update
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'
----

Now your `DbConnector` subdirectory is at the exact state it was in when you committed earlier.

Τώρα ο υποκατάλογος `DbConnector` μας βρίσκεται στην ακριβή κατάσταση που ήταν όταν υποβάλλαμε νωρίτερα.

Υπάρχει ένας άλλος τρόπος για να γίνει αυτό, το οποίο όμως είναι λίγο πιο απλό.
Αν περάσουμε `--recursive` στην εντολή` git clone`, αυτόματα θα προετοιμάσει και θα ενημερώσει κάθε υπομόνιο στο αποθετήριο.

There is another way to do this which is a little simpler, however.
If you pass `--recursive` to the `git clone` command, it will automatically initialize and update each submodule in the repository.

[source,console]
----
$ git clone --recursive https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'
----

==== Εργασία σε ένα έργο με υπομονάδες

Τώρα έχουμε ένα αντίγραφο ενός έργου με υπομονάδες σε αυτό και θα συνεργαστούμε με τους συμπαίκτες μας τόσο για το κύριο έργο όσο και για το υποσύνολο έργου.

Now we have a copy of a project with submodules in it and will collaborate with our teammates on both the main project and the submodule project.

===== Pulling in Upstream Changes
===== Τραβήξτε τις μεταγενέστερες αλλαγές

Το απλούστερο μοντέλο χρήσης υπομονάδων σε ένα έργο θα ήταν αν καταναλώνουμε απλά ένα υποέργο και ήθελα να λαμβάνουμε ενημερώσεις από αυτό κατά καιρούς αλλά δεν τροποποιούσαμε τίποτα στην παραγγελία μας.
Ας περάσουμε από ένα απλό παράδειγμα εκεί.

The simplest model of using submodules in a project would be if you were simply consuming a subproject and wanted to get updates from it from time to time but were not actually modifying anything in your checkout.
Let's walk through a simple example there.

Αν θέλουμε να ελέγξουμε για νέα εργασία σε υπομονάδα, μπορούμε να μεταβούμε στον κατάλογο και να εκτελέσουμε `git fetch` και` git merge 'για να ενημερώσουμε τον τοπικό κώδικα.

If you want to check for new work in a submodule, you can go into the directory and run `git fetch` and `git merge` the upstream branch to update the local code.

[source,console]
----
$ git fetch
From https://github.com/chaconinc/DbConnector
   c3f01dc..d0354fc  master     -> origin/master
$ git merge origin/master
Updating c3f01dc..d0354fc
Fast-forward
 scripts/connect.sh | 1 +
 src/db.c           | 1 +
 2 files changed, 2 insertions(+)
----

Τώρα, αν επιστρέψουμε στο κύριο έργο και εκτελέσουμε το `git diff --submodule`, μπορούμε να δούμε ότι το υπομοντέλο ενημερώθηκε και να πάρουμε μια λίστα υποβολών που προστέθηκαν σε αυτό.
Εάν δεν θέλουμε να πληκτρολογούμε `--submodule` κάθε φορά που τρέχουμε το` git diff`, μπορούμε να το ορίσουμε ως προεπιλεγμένη μορφή ρυθμίζοντας την τιμή config του `diff.submodule` στο` `log ''.

Now if you go back into the main project and run `git diff --submodule` you can see that the submodule was updated and get a list of commits that were added to it.
If you don't want to type `--submodule` every time you run `git diff`, you can set it as the default format by setting the `diff.submodule` config value to ``log''.

[source,console]
----
$ git config --global diff.submodule log
$ git diff
Submodule DbConnector c3f01dc..d0354fc:
  > more efficient db routine
  > better connection routine
----

If you commit at this point then you will lock the submodule into having the new code when other people update.

Εάν υποβάλλούμε σε αυτό το σημείο τότε θα κλειδώσουμε το υπομοντέλο να έχει τον νέο κώδικα όταν ενημερώνονται άλλοι άνθρωποι.

Υπάρχει ένας ευκολότερος τρόπος για να γίνει αυτό επίσης, αν προτιμάμε να μην φέρουμε και να συγχωνεύσουμε με μη αυτόματο τρόπο τον υποκατάλογο.
Εάν εκτελέσουμε την `git update submodule --remote ', το Git θα μεταβεί στα submodules μας και θα φέρω και θα ενημερώσει για εσάς.

There is an easier way to do this as well, if you prefer to not manually fetch and merge in the subdirectory.
If you run `git submodule update --remote`, Git will go into your submodules and fetch and update for you.

[source,console]
----
$ git submodule update --remote DbConnector
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   3f19983..d0354fc  master     -> origin/master
Submodule path 'DbConnector': checked out 'd0354fc054692d3906c85c3af05ddce39a1c0644'
----

Αυτή η εντολή θα υποθέσει από προεπιλογή ότι θέλουμε να ενημερώσουμε το checkout στον κλάδο `master` του αποθετηρίου υπομπόλων.
Ωστόσο, μπορούμε να ορίσουμε κάτι διαφορετικό αν θέλουμε.
Για παράδειγμα, εάν θέλουμε να παρακολουθήσουμε τον υπομονάδα DbConnector στον κλάδο `` stable '' του αποθετηρίου, μπορούμε να τον ορίσουμε είτε στο αρχείο .gitmodules, είτε στο τοπικό `.git / config`.
Ας το ορίσουμε στο αρχείο `.gitmodules`:

This command will by default assume that you want to update the checkout to the `master` branch of the submodule repository.
You can, however, set this to something different if you want.
For example, if you want to have the DbConnector submodule track that repository's ``stable'' branch, you can set it in either your `.gitmodules` file (so everyone else also tracks it), or just in your local `.git/config` file.
Let's set it in the `.gitmodules` file:

[source,console]
----
$ git config -f .gitmodules submodule.DbConnector.branch stable

$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   27cf5d3..c87d55d  stable -> origin/stable
Submodule path 'DbConnector': checked out 'c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687'
----

If you leave off the `-f .gitmodules` it will only make the change for you, but it probably makes more sense to track that information with the repository so everyone else does as well.

Αν αφήσουμε τα `-f .gmodmodules ', θα κάνει μόνο την αλλαγή για μας, αλλά πιθανότατα είναι πιο λογικό να παρακολουθούμε αυτές τις πληροφορίες με το χώρο αποθήκευσης έτσι ώστε όλοι οι άλλοι να το κάνουν.

Όταν τρέχουμε `git status` σε αυτό το σημείο, το Git θα μας δείξει ότι έχουμε ``νέες υποβολές'' στο submodule.

When we run `git status` at this point, Git will show us that we have ``new commits'' on the submodule.

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

  modified:   .gitmodules
  modified:   DbConnector (new commits)

no changes added to commit (use "git add" and/or "git commit -a")
----

Εάν ορίσουμε τη ρύθμιση διαμόρφωσης "status.submodulesummary", το Git θα μας δείξει επίσης μια σύντομη περίληψη των αλλαγών στα υπομονάδα μας:

If you set the configuration setting `status.submodulesummary`, Git will also show you a short summary of changes to your submodules:

[source,console]
----
$ git config status.submodulesummary 1

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   .gitmodules
	modified:   DbConnector (new commits)

Submodules changed but not updated:

* DbConnector c3f01dc...c87d55d (4):
  > catch non-null terminated lines
----

Σε αυτό το σημείο, αν εκτελέσουμε το `git diff`, μπορούμε να δούμε και ότι έχουμε τροποποιήσει το αρχείο` .gitmodules` και επίσης ότι υπάρχουν αρκετοί δεσμοί που έχουμε τραβήξει προς τα κάτω και είμαστε έτοιμοι να υποβάλλούμε για το υποσύνολο του έργου μας.

At this point if you run `git diff` we can see both that we have modified our `.gitmodules` file and also that there are a number of commits that we've pulled down and are ready to commit to our submodule project.

[source,console]
----
$ git diff
diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
 Submodule DbConnector c3f01dc..c87d55d:
  > catch non-null terminated lines
  > more robust error handling
  > more efficient db routine
  > better connection routine
----

Αυτό είναι πολύ δροσερό, καθώς μπορούμε πραγματικά να δούμε το ημερολόγιο υποβολών που πρόκειται να υποβάλλούμε στο submodule μας.
Αφού υποβληθεί, μπορούμε να δούμε αυτές τις πληροφορίες και μετά το γεγονός όταν τρέχουμε το `git log -p`.

This is pretty cool as we can actually see the log of commits that we're about to commit to in our submodule.
Once committed, you can see this information after the fact as well when you run `git log -p`.

[source,console]
----
$ git log -p --submodule
commit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7ae
Author: Scott Chacon <schacon@gmail.com>
Date:   Wed Sep 17 16:37:02 2014 +0200

    updating DbConnector for bug fixes

diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
Submodule DbConnector c3f01dc..c87d55d:
  > catch non-null terminated lines
  > more robust error handling
  > more efficient db routine
  > better connection routine
----

Το Git θα προσπαθήσει από προεπιλογή να ενημερώσει ** όλα τα ** υπομονάδα μας όταν τρέχουμε την `git update submodule --remote ', οπότε αν έχουμε πολλά από αυτά, ίσως θέλουμε να περάσουμε το όνομα μόνο του υποσυστήματος που θέλουμε να δοκιμάσουμε για ενημέρωση.

Git will by default try to update **all** of your submodules when you run `git submodule update --remote` so if you have a lot of them, you may want to pass the name of just the submodule you want to try to update.

===== Εργασία σε υπομονάδα

Είναι πολύ πιθανό ότι αν χρησιμοποιούμε υπομονάδες, το κάνουμε επειδή θέλουμε πραγματικά να εργαστούμε στον κώδικα στο υποσύνολο ταυτόχρονα με την εργασία μας στον κώδικα στο κύριο έργο (ή σε πολλά υπομονάδες) .
Διαφορετικά, πιθανότατα θα χρησιμοποιούσαμε ένα απλούστερο σύστημα διαχείρισης εξάρτησης (όπως Maven ή Rubygems).

It's quite likely that if you're using submodules, you're doing so because you really want to work on the code in the submodule at the same time as you're working on the code in the main project (or across several submodules).
Otherwise you would probably instead be using a simpler dependency management system (such as Maven or Rubygems).

So now let's go through an example of making changes to the submodule at the same time as the main project and committing and publishing those changes at the same time.

Τώρα, λοιπόν, να δούμε ένα παράδειγμα να κάνουμε αλλαγές στο υποσύνολο ταυτόχρονα με το κύριο έργο και να υποβάλλουμε και να δημοσιεύουμε αυτές τις αλλαγές ταυτόχρονα.

Μέχρι στιγμής, όταν έχουμε εκτελέσει την εντολή `update submodule git 'για να μεταφέρει τις αλλαγές από τα αποθετήρια υπομονάδων, ο Git θα πάρει τις αλλαγές και θα ενημερώσει τα αρχεία στον υποκατάλογο, αλλά θα αφήσει το sub-repository σε αυτό που ονομάζεται` `detached HEAD '' κατάσταση.
Αυτό σημαίνει ότι δεν υπάρχει τοπικός κλάδος εργασίας (όπως το `` master '', για παράδειγμα) παρακολούθηση αλλαγών.
Επομένως, οι αλλαγές που κάνουμε δεν παρακολουθούνται καλά.

So far, when we've run the `git submodule update` command to fetch changes from the submodule repositories, Git would get the changes and update the files in the subdirectory but will leave the sub-repository in what's called a ``detached HEAD'' state.
This means that there is no local working branch (like ``master'', for example) tracking changes.
So any changes you make aren't being tracked well.

In order to set up your submodule to be easier to go in and hack on, you need do two things.
You need to go into each submodule and check out a branch to work on.
Then you need to tell Git what to do if you have made changes and then `git submodule update --remote` pulls in new work from upstream.
The options are that you can merge them into your local work, or you can try to rebase your local work on top of the new changes.

Προκειμένου να ρυθμίσουμε το υπομονάδα μας ώστε να είναι ευκολότερο να εισέλθουμε και να ακουμπάτε, πρέπει να κάνουμε δύο πράγματα.
Πρέπει να πάμε σε κάθε υπομοντέλο και να δούμε έναν κλάδο για να εργαστούμε.
Στη συνέχεια, πρέπει να πούμε στο Git τι πρέπει να κάνουμε αν έχουμε κάνει αλλαγές και στη συνέχεια `git update submodule --remote 'τραβάει νέα εργασία από την ανάντη.
Οι επιλογές είναι ότι μπορούμε να τις συγχωνεύσουμε στην τοπική δουλειά μας ή μπορούμε να δοκιμάσουμε να αναδιοργανώσουμε την τοπική εργασία μας πάνω από τις νέες αλλαγές.

Κατ' αρχάς, ας πάμε στον κατάλογο υποσυστήματός μας και να δούμε έναν κλάδο.

First of all, let's go into our submodule directory and check out a branch.

[source,console]
----
$ git checkout stable
Switched to branch 'stable'
----

Ας το δοκιμάσουμε με την επιλογή `` συγχώνευση ''.
Για να το καθορίσουμε με το χέρι, μπορούμε απλά να προσθέσουμε την επιλογή `-merge` στην κλήση` update '.
Εδώ θα δούμε ότι υπήρξε μια αλλαγή στον εξυπηρετητή για αυτό το υποσύνολο και γίνεται συγχώνευση.

Let's try it with the ``merge'' option.
To specify it manually, we can just add the `--merge` option to our `update` call.
Here we'll see that there was a change on the server for this submodule and it gets merged in.

[source,console]
----
$ git submodule update --remote --merge
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   c87d55d..92c7337  stable     -> origin/stable
Updating c87d55d..92c7337
Fast-forward
 src/main.c | 1 +
 1 file changed, 1 insertion(+)
Submodule path 'DbConnector': merged in '92c7337b30ef9e0893e758dac2459d07362ab5ea'
----

Εάν εισέλθουμε στον κατάλογο DbConnector, έχουμε τις νέες αλλαγές που έχουν ήδη συγχωνευθεί στον τοπικό κλάδο `stable`.
Τώρα ας δούμε τι συμβαίνει όταν κάνουμε τη δική μας τοπική αλλαγή στη βιβλιοθήκη και κάποιος άλλος προωθεί μια άλλη αλλαγή ανάντη την ίδια στιγμή.

If we go into the DbConnector directory, we have the new changes already merged into our local `stable` branch.
Now let's see what happens when we make our own local change to the library and someone else pushes another change upstream at the same time.

[source,console]
----
$ cd DbConnector/
$ vim src/db.c
$ git commit -am 'unicode support'
[stable f906e16] unicode support
 1 file changed, 1 insertion(+)
----

Τώρα, αν ενημερώσουμε το υποσύνολο μας, μπορούμε να δούμε τι συμβαίνει όταν έχουμε κάνει μια τοπική αλλαγή και ανάντη έχει επίσης μια αλλαγή που πρέπει να ενσωματώσουμε.

Now if we update our submodule we can see what happens when we have made a local change and upstream also has a change we need to incorporate.

[source,console]
----
$ git submodule update --remote --rebase
First, rewinding head to replay your work on top of it...
Applying: unicode support
Submodule path 'DbConnector': rebased into '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'
----

Εάν ξεχάσουμε το `--rebase` ή το `--merge`, το Git θα ενημερώσει μόνο το υπομοντέλο σε ό, τι βρίσκεται στο διακομιστή και θα επαναφέρει το έργο μας σε αποσπασμένη κατάσταση HEAD.

If you forget the `--rebase` or `--merge`, Git will just update the submodule to whatever is on the server and reset your project to a detached HEAD state.

[source,console]
----
$ git submodule update --remote
Submodule path 'DbConnector': checked out '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'
----

If this happens, don't worry, you can simply go back into the directory and check out your branch again (which will still contain your work) and merge or rebase `origin/stable` (or whatever remote branch you want) manually.

Αν συμβεί κάτι τέτοιο, μην ανησυχούμε, μπορούμε απλά να επιστρέψουμε στον κατάλογο και να ελέγξουμε ξανά τον κλάδο μας (το οποίο θα εξακολουθεί να περιέχει την εργασία μας) και να συγχωνεύσουμε ή να επαναφέρουμε την "προέλευση / σταθερή" (ή ό,τι απομακρυσμένο κλάδο θέλετε) χειροκίνητα.

Αν δεν έχουμε αναλάβει τις αλλαγές στο υπομοντέλο μας και εκτελέσουμε μια ενημέρωση υποσυστήματος που θα μπορούσε να προκαλέσει προβλήματα, το Git θα ανακτήσει τις αλλαγές αλλά δεν θα αντικαταστήσει τη μη αποθηκευμένη εργασία στον κατάλογο υπομονάδων μας.

If you haven't committed your changes in your submodule and you run a submodule update that would cause issues, Git will fetch the changes but not overwrite unsaved work in your submodule directory.

[source,console]
----
$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 4 (delta 0), reused 4 (delta 0)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   5d60ef9..c75e92a  stable     -> origin/stable
error: Your local changes to the following files would be overwritten by checkout:
	scripts/setup.sh
Please, commit your changes or stash them before you can switch branches.
Aborting
Unable to checkout 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'
----

Εάν κάναμε αλλαγές που έρχονται σε αντίθεση με κάτι που άλλαξε upstream, το Git θα μας ενημερώσει όταν εκτελούμε την ενημέρωση.

If you made changes that conflict with something changed upstream, Git will let you know when you run the update.

[source,console]
----
$ git submodule update --remote --merge
Auto-merging scripts/setup.sh
CONFLICT (content): Merge conflict in scripts/setup.sh
Recorded preimage for 'scripts/setup.sh'
Automatic merge failed; fix conflicts and then commit the result.
Unable to merge 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'
----

Μπορούμε να μεταβούμε στον κατάλογο υπομονάδων και να διορθώσουμε τη σύγκρουση όπως θα κάναμε κανονικά.

You can go into the submodule directory and fix the conflict just as you normally would.

[[_publishing_submodules]]
===== Δημοσίευση αλλαγών σε υπομονάδες

Τώρα έχουμε κάποιες αλλαγές στον κατάλογο υπομπόδων μας.
Ορισμένα από αυτά εισήχθησαν από τις προηγούμενες ενημερώσεις μας και άλλα έγιναν σε τοπικό επίπεδο και δεν είναι διαθέσιμα σε κανέναν ακόμα επειδή δεν τα έχουμε πιέσει ακόμα.

Now we have some changes in our submodule directory.
Some of these were brought in from upstream by our updates and others were made locally and aren't available to anyone else yet as we haven't pushed them yet.

[source,console]
----
$ git diff
Submodule DbConnector c87d55d..82d2ad3:
  > Merge from origin/stable
  > updated setup script
  > unicode support
  > remove unnecessary method
  > add new option for conn pooling
----

If we commit in the main project and push it up without pushing the submodule changes up as well, other people who try to check out our changes are going to be in trouble since they will have no way to get the submodule changes that are depended on.
Those changes will only exist on our local copy.

Εάν υποβάλλουμε στο κύριο έργο και το ωθήσουμε χωρίς να πιέσουμε τα υποσυστήματα να αλλάζουν, άλλοι άνθρωποι που προσπαθούν να ελέγξουν τις αλλαγές μας θα αντιμετωπίσουν πρόβλημα, αφού δεν θα έχουν τρόπο να πάρουν τις αλλαγές των υποσυστημάτων που εξαρτώνται από .
Αυτές οι αλλαγές θα υπάρχουν μόνο στο τοπικό αντίγραφό μας.

Για να βεβαιωθούμε ότι αυτό δεν συμβαίνει, μπορούμε να ζητήσουμε από τον Git να ελέγξει ότι όλα τα υποσυστήματά μας έχουν ωθηθεί σωστά πριν προωθήσουμε το κύριο έργο.
Η εντολή `git push` παίρνει το επιχείρημα `--recurse-submodules` το οποίο μπορεί να ρυθμιστεί είτε σε `check` είτε σε `on-demand`.
Η επιλογή `` check '' θα κάνει `push 'απλά να αποτύχει εάν κάποια από τις μεταβιβαζόμενες αλλαγές του υποσυστήματος δεν έχει ωθηθεί.

In order to make sure this doesn't happen, you can ask Git to check that all your submodules have been pushed properly before pushing the main project.
The `git push` command takes the `--recurse-submodules` argument which can be set to either ``check'' or ``on-demand''.
The ``check'' option will make `push` simply fail if any of the committed submodule changes haven't been pushed.

[source,console]
----
$ git push --recurse-submodules=check
The following submodule paths contain changes that can
not be found on any remote:
  DbConnector

Please try

	git push --recurse-submodules=on-demand

or cd to the path and use

	git push

to push them to a remote.
----

As you can see, it also gives us some helpful advice on what we might want to do next.
The simple option is to go into each submodule and manually push to the remotes to make sure they're externally available and then try this push again.

Όπως μπορούμε να δούμε, μας δίνει επίσης κάποιες χρήσιμες συμβουλές για το τι θα θέλαμε να κάνουμε στη συνέχεια.
Η απλή επιλογή είναι να εισέλθουμε σε κάθε υπομοντέλο και να πιέζουμε χειροκίνητα τα τηλεχειριστήρια για να βεβαιωθούμε ότι είναι εξωτερικά διαθέσιμα και, στη συνέχεια, δοκιμάστε ξανά αυτό το πάτημα.

Η άλλη επιλογή είναι να χρησιμοποιήσουμε την τιμή `` on-demand '', η οποία θα προσπαθήσει να το κάνει αυτό για εσάς.

The other option is to use the ``on-demand'' value, which will try to do this for you.

[source,console]
----
$ git push --recurse-submodules=on-demand
Pushing submodule 'DbConnector'
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (8/8), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 3), reused 0 (delta 0)
To https://github.com/chaconinc/DbConnector
   c75e92a..82d2ad3  stable -> stable
Counting objects: 2, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, done.
Total 2 (delta 1), reused 0 (delta 0)
To https://github.com/chaconinc/MainProject
   3d6d338..9a377d1  master -> master
----

Όπως βλέπουμε εκεί, ο Git μπήκε στη μονάδα DbConnector και τον έσπρωξε πριν προωθήσει το κύριο έργο.
Εάν η ώθηση του υποσυστήματος αποτύχει για κάποιο λόγο, η κύρια ώθηση του έργου θα αποτύχει επίσης.

As you can see there, Git went into the DbConnector module and pushed it before pushing the main project.
If that submodule push fails for some reason, the main project push will also fail.

===== Συγχώνευση αλλαγών υπομονάδων

Εάν αλλάξουμε μια παραπομπή υποσυστήματος ταυτόχρονα με κάποιον άλλο, ενδέχεται να αντιμετωπίσουμε κάποια προβλήματα.
Δηλαδή, εάν τα ιστορικά υποσυστήματα έχουν αποκλίνει και έχουν υποβληθεί σε διαφορετικά κλάδους σε ένα υπερ-σχέδιο, μπορεί να χρειαστεί κάποια δουλειά για να τα διορθώσουμε.

If you change a submodule reference at the same time as someone else, you may run into some problems.
That is, if the submodule histories have diverged and are committed to diverging branches in a superproject, it may take a bit of work for you to fix.

If one of the commits is a direct ancestor of the other (a fast-forward merge), then Git will simply choose the latter for the merge, so that works fine.

Εάν μία από τις υποβολές είναι ένας άμεσος πρόγονος του άλλου (μια γρήγορη συγχώνευση), τότε ο Git θα επιλέξει απλά τον τελευταίο για τη συγχώνευση, έτσι ώστε να λειτουργεί καλά.

Ωστόσο, το Git δεν θα επιχειρήσει ακόμη και μια τετριμμένη συγχώνευση για εσάς.
Εάν το υπομοντέλο υποβάλλει να αποκλίνει και πρέπει να συγχωνευθεί, θα πάρουμε κάτι που μοιάζει με αυτό:

Git will not attempt even a trivial merge for you, however.
If the submodule commits diverge and need to be merged, you will get something that looks like this:

[source,console]
----
$ git pull
remote: Counting objects: 2, done.
remote: Compressing objects: 100% (1/1), done.
remote: Total 2 (delta 1), reused 2 (delta 1)
Unpacking objects: 100% (2/2), done.
From https://github.com/chaconinc/MainProject
   9a377d1..eb974f8  master     -> origin/master
Fetching submodule DbConnector
warning: Failed to merge submodule DbConnector (merge following commits not found)
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.
----

So basically what has happened here is that Git has figured out that the two branches record points in the submodule's history that are divergent and need to be merged.
It explains it as ``merge following commits not found'', which is confusing but we'll explain why that is in a bit.

Έτσι, βασικά, αυτό που συνέβη εδώ είναι ότι ο Git έχει καταλάβει ότι οι δύο κλάδοι καταγράφουν σημεία στην ιστορία του υποσυστήματος που είναι διαφορετικά και πρέπει να συγχωνευθούν.
Το εξηγεί ως `` συγχώνευση μετά τις υποβολές που δεν βρέθηκαν '', το οποίο είναι συγκεχυμένο, αλλά θα εξηγήσουμε γιατί αυτό είναι σε λίγο.

Για να λύσουμε το πρόβλημα, θα πρέπει να υπολογίσουμε σε ποια κατάσταση θα πρέπει να βρίσκεται το υπομοντέλο.
Παραδόξως, το Git δεν μας δίνει πραγματικά πολλές πληροφορίες για να βοηθήσουμε εδώ, ούτε καν τα SHA-1s των υποβολών και των δύο πλευρών της ιστορίας.
Ευτυχώς, είναι απλό να καταλάβεις.
Αν εκτελέσουμε το `git diff`, μπορούμε να λάβουμε τα SHA-1 των υποβολών που καταγράφηκαν και στα δύο κλάδους που προσπαθούσαμε να συγχωνεύσουμε.

To solve the problem, you need to figure out what state the submodule should be in.
Strangely, Git doesn't really give you much information to help out here, not even the SHA-1s of the commits of both sides of the history.
Fortunately, it's simple to figure out.
If you run `git diff` you can get the SHA-1s of the commits recorded in both branches you were trying to merge.

[source,console]
----
$ git diff
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector
----

So, in this case, `eb41d76` is the commit in our submodule that *we* had and `c771610` is the commit that upstream had.
If we go into our submodule directory, it should already be on `eb41d76` as the merge would not have touched it.
If for whatever reason it's not, you can simply create and checkout a branch pointing to it.

Έτσι, στην περίπτωση αυτή, `eb41d76` είναι η υποβολή στο υπομονάδα μας ότι * είχαμε και το` c771610` είναι η υποβολή που είχε προηγουμένως.
Αν πάμε στον κατάλογο υπομονάδων μας, θα έπρεπε να είναι ήδη στο `eb41d76` καθώς η συγχώνευση δεν θα τον άγγιζε.
Εάν για οποιονδήποτε λόγο δεν είναι, μπορούμε απλά να δημιουργήσουμε και να ελέγξουμε έναν κλάδο που δείχνει σε αυτό.

Αυτό που είναι σημαντικό είναι το SHA-1 της υποβολής από την άλλη πλευρά.
Αυτό θα πρέπει να συγχωνεύσουμε και να επιλύσουμε.
Μπορούμε είτε να δοκιμάσουμε απευθείας τη συγχώνευση με το SHA-1 απευθείας είτε μπορούμε να δημιουργήσουμε έναν κλάδο για αυτό και στη συνέχεια να προσπαθήσουμε να το συγχωνεύσουμε.
Θα το προτείνουμε το τελευταίο, έστω και μόνο για να κάνει ένα καλύτερο μήνυμα συγχώνευσης.

What is important is the SHA-1 of the commit from the other side.
This is what you'll have to merge in and resolve.
You can either just try the merge with the SHA-1 directly, or you can create a branch for it and then try to merge that in.
We would suggest the latter, even if only to make a nicer merge commit message.

Έτσι, θα πάμε στον κατάλογο υπομονάδων μας, θα δημιουργήσουμε έναν κλάδο βασισμένο σε αυτό το δεύτερο SHA-1 από το `git diff` και θα συγχωνεύσουμε με το χέρι.

So, we will go into our submodule directory, create a branch based on that second SHA-1 from `git diff` and manually merge.

[source,console]
----
$ cd DbConnector

$ git rev-parse HEAD
eb41d764bccf88be77aced643c13a7fa86714135

$ git branch try-merge c771610
(DbConnector) $ git merge try-merge
Auto-merging src/main.c
CONFLICT (content): Merge conflict in src/main.c
Recorded preimage for 'src/main.c'
Automatic merge failed; fix conflicts and then commit the result.
----

Έχουμε μια πραγματική σύγκρουση συγχώνευσης εδώ, οπότε αν το επιλύσουμε και θα την υποβάλλουμε, τότε μπορούμε απλά να ενημερώσουμε το κύριο έργο με το αποτέλεσμα.

We got an actual merge conflict here, so if we resolve that and commit it, then we can simply update the main project with the result.

[source,console]
----
$ vim src/main.c <1>
$ git add src/main.c
$ git commit -am 'merged our changes'
Recorded resolution for 'src/main.c'.
[master 9fd905e] merged our changes

$ cd .. <2>
$ git diff <3>
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector
@@@ -1,1 -1,1 +1,1 @@@
- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135
 -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d
++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a
$ git add DbConnector <4>

$ git commit -m "Merge Tom's Changes" <5>
[master 10d2c60] Merge Tom's Changes
----

<1> First we resolve the conflict
<2> Then we go back to the main project directory
<3> We can check the SHA-1s again
<4> Resolve the conflicted submodule entry
<5> Commit our merge

<1> Αρχικά επιλύουμε τη σύγκρουση
<2> Μετά επιστρέφουμε στον κύριο κατάλογο έργων
<3> Μπορούμε ξανά να ελέγξουμε τα SHA-1
<4> Επιλύστε την καταχώρηση αλληλεξάρτησης που βρίσκεται σε διένεξη
<5> Αναθέστε τη συγχώνευσή μας

Μπορεί να είναι λίγο συγκεχυμένη, αλλά δεν είναι πραγματικά πολύ δύσκολο.

It can be a bit confusing, but it's really not very hard.

Interestingly, there is another case that Git handles.
If a merge commit exists in the submodule directory that contains **both** commits in its history, Git will suggest it to you as a possible solution.
It sees that at some point in the submodule project, someone merged branches containing these two commits, so maybe you'll want that one.

Είναι ενδιαφέρον ότι υπάρχει μια άλλη περίπτωση που το Git χειρίζεται.
Εάν υπάρχει υποβολή συγχώνευσης στον κατάλογο υπομονάδων που περιέχει ** και τα δύο υποβάλλει ** στο ιστορικό του, το Git θα μας το προτείνει ως μια πιθανή λύση.
Βλέπει ότι σε κάποιο σημείο του έργου υποσυστήματος κάποιος συνένωσε κλάδους που περιέχουν αυτές τις δύο υποβολές, οπότε ίσως θα το θελήσουμε.

Αυτός είναι ο λόγος για τον οποίο το μήνυμα λάθους από πριν ήταν `` συγχώνευση ακολουθώντας τις υποβολές που δεν βρέθηκαν '', επειδή δεν μπορούσε να κάνει * αυτό *.
Είναι συγκεχυμένη γιατί ποιος θα περίμενε ** να προσπαθήσει ** να το κάνει αυτό;

This is why the error message from before was ``merge following commits not found'', because it could not do *this*.
It's confusing because who would expect it to **try** to do this?

Εάν διαπιστώσει ότι υπάρχει μία αποδεκτή υποβολή συγχώνευσης, θα δούμε κάτι σαν αυτό:

[source,console]
----
$ git merge origin/master
warning: Failed to merge submodule DbConnector (not fast-forward)
Found a possible merge resolution for the submodule:
 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: > merged our changes
If this is correct simply add it to the index for example
by using:

  git update-index --cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a "DbConnector"

which will accept this suggestion.
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.
----

Αυτό που υποδηλώνει ότι κάνουμε είναι να ενημερώσουμε τον ευρετήριο όπως είχαμε εκτελέσει το `git add`, το οποίο καθαρίζει τη σύγκρουση και κατόπιν υποβάλλει. Πιθανότατα δεν πρέπει να το κάνουμε αυτό όμως. Μπορούμε επίσης εύκολα να μεταβούμε στον κατάλογο των υπομοντέλων, να δούμε ποια είναι η διαφορά, να προχωρήσουμε γρήγορα σε αυτή τη υποβολή, να το δοκιμάσουμε σωστά και στη συνέχεια να την υποβάλλουμε.

What it's suggesting that you do is to update the index like you had run `git add`, which clears the conflict, then commit. You probably shouldn't do this though. You can just as easily go into the submodule directory, see what the difference is, fast-forward to this commit, test it properly, and then commit it.

[source,console]
----
$ cd DbConnector/
$ git merge 9fd905e
Updating eb41d76..9fd905e
Fast-forward

$ cd ..
$ git add DbConnector
$ git commit -am 'Fast forwarded to a common submodule child'
----

Αυτό ολοκληρώνει το ίδιο πράγμα, αλλά τουλάχιστον με αυτόν τον τρόπο μπορούμε να επαληθεύσουμε ότι λειτουργεί και έχουμε τον κώδικα στον κατάλογο υπομονάδων μας όταν τελειώσουμε.

This accomplishes the same thing, but at least this way you can verify that it works and you have the code in your submodule directory when you're done.


==== Συμβουλές για υποσυστήματα

Υπάρχουν μερικά πράγματα που μπορούμε να κάνουμε για να κάνουμε την εργασία με τους υπομοντέλους λίγο πιο εύκολη.Submodule Tips

There are a few things you can do to make working with submodules a little easier.

===== Υπομονάδα Foreach

Υπάρχει μια εντολή submodule `foreach` για να εκτελέσουμε κάποια αυθαίρετη εντολή σε κάθε υπομονάδα.
Αυτό μπορεί να είναι πραγματικά χρήσιμο εάν έχουμε έναν αριθμό υπομονάδων στο ίδιο έργο.

There is a `foreach` submodule command to run some arbitrary command in each submodule.
This can be really helpful if you have a number of submodules in the same project.

Για παράδειγμα, ας υποθέσουμε ότι θέλουμε να ξεκινήσουμε μια νέα λειτουργία ή να κάνουμε μια διόρθωση σφαλμάτων και έχουμε εργασία που συμβαίνει σε διάφορα υπομονάδες.
Μπορούμε εύκολα να αποθηκεύσουμε όλη τη δουλειά σε όλες τις υπομονάδες μας.

For example, let's say we want to start a new feature or do a bugfix and we have work going on in several submodules.
We can easily stash all the work in all our submodules.

[source,console]
----
$ git submodule foreach 'git stash'
Entering 'CryptoLibrary'
No local changes to save
Entering 'DbConnector'
Saved working directory and index state WIP on stable: 82d2ad3 Merge from origin/stable
HEAD is now at 82d2ad3 Merge from origin/stable
----

Στη συνέχεια, μπορούμε να δημιουργήσουμε έναν νέο κλάδο και να μεταβούμε σε αυτόν σε όλες τις υπομονάδες μας.

[source,console]
----
$ git submodule foreach 'git checkout -b featureA'
Entering 'CryptoLibrary'
Switched to a new branch 'featureA'
Entering 'DbConnector'
Switched to a new branch 'featureA'
----

Αυτή είναι η βασική ιδέα.
Ένα πραγματικά χρήσιμο πράγμα που μπορούμε να κάνουμε είναι να παράγουμε μια ωραία ενοποιημένη διαφορά από αυτό που αλλάζει στο κύριο έργο μας και όλα τα υποπρογράμματά μας επίσης.

You get the idea.
One really useful thing you can do is produce a nice unified diff of what is changed in your main project and all your subprojects as well.

[source,console]
----
$ git diff; git submodule foreach 'git diff'
Submodule DbConnector contains modified content
diff --git a/src/main.c b/src/main.c
index 210f1ae..1f0acdc 100644
--- a/src/main.c
+++ b/src/main.c
@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char ***argv)

      commit_pager_choice();

+     url = url_decode(url_orig);
+
      /* build alias_argv */
      alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1));
      alias_argv[0] = alias_string + 1;
Entering 'DbConnector'
diff --git a/src/db.c b/src/db.c
index 1aaefb6..5297645 100644
--- a/src/db.c
+++ b/src/db.c
@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len)
        return url_decode_internal(&url, len, NULL, &out, 0);
 }

+char *url_decode(const char *url)
+{
+       return url_decode_mem(url, strlen(url));
+}
+
 char *url_decode_parameter_name(const char **query)
 {
        struct strbuf out = STRBUF_INIT;
----

Εδώ μπορούμε να δούμε ότι ορίζουμε μια λειτουργία σε ένα υπομοντέλο και το καλούμε στο κύριο έργο.
Αυτό είναι προφανώς ένα απλοποιημένο παράδειγμα, αλλά ελπίζουμε ότι μας δίνει μια ιδέα για το πώς αυτό μπορεί να είναι χρήσιμο.

Here we can see that we're defining a function in a submodule and calling it in the main project.
This is obviously a simplified example, but hopefully it gives you an idea of how this may be useful.

===== Useful Aliases
===== Χρήσιμα ψευδώνυμα

Μπορεί να θέλουμε να ορίσουμε ορισμένα ψευδώνυμα για ορισμένες από αυτές τις εντολές, καθώς μπορεί να είναι αρκετά μεγάλη και δεν μπορούμε να ορίσουμε επιλογές διαμόρφωσης για τους περισσότερους από αυτούς για να τις κάνουμε προεπιλογές.
Καλύψαμε τη δημιουργία των ψευδωνύμων Git στο <<_git_aliases>>, αλλά εδώ είναι ένα παράδειγμα του τι μπορεί να θέλουμε να ρυθμίσουμε εάν σχεδιάζουμε να δουλεύουμε με υπομονάδες στο Git πολύ.

You may want to set up some aliases for some of these commands as they can be quite long and you can't set configuration options for most of them to make them defaults.
We covered setting up Git aliases in <<_git_aliases>>, but here is an example of what you may want to set up if you plan on working with submodules in Git a lot.

[source,console]
----
$ git config alias.sdiff '!'"git diff && git submodule foreach 'git diff'"
$ git config alias.spush 'push --recurse-submodules=on-demand'
$ git config alias.supdate 'submodule update --remote --merge'
----

Με αυτό τον τρόπο μπορούμε απλά να εκτελέσουμε το `git supdate` όταν θέλουμε να ενημερώσουμε τα υποσυστήματα μας, ή το` git spush` για να πιέσουμε με τον έλεγχο εξάρτησης υποσυστήματος.

This way you can simply run `git supdate` when you want to update your submodules, or `git spush` to push with submodule dependency checking.

==== Issues with Submodules
==== Ζητήματα με υπομονάδες

Η χρήση υπομονάδων δεν είναι χωρίς λόξιμο, ωστόσο.

Using submodules isn’t without hiccups, however.

Για παράδειγμα, η εναλλαγή κλαδιών με υπομονάδες σε αυτά μπορεί επίσης να είναι δύσκολη.
Εάν δημιουργήσουμε ένα νέο κλάδο, προσθέστε ένα υπομοντέλο εκεί και, στη συνέχεια, μεταβούμε σε ένα κλάδο χωρίς αυτό το υποσύνολο, εξακολουθούμε να έχουμε τον κατάλογο υποστοιχείων ως έναν μη κρυπτογραφημένο κατάλογο:

For instance switching branches with submodules in them can also be tricky.
If you create a new branch, add a submodule there, and then switch back to a branch without that submodule, you still have the submodule directory as an untracked directory:

[source,console]
----
$ git checkout -b add-crypto
Switched to a new branch 'add-crypto'

$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
...

$ git commit -am 'adding crypto library'
[add-crypto 4445836] adding crypto library
 2 files changed, 4 insertions(+)
 create mode 160000 CryptoLibrary

$ git checkout master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	CryptoLibrary/

nothing added to commit but untracked files present (use "git add" to track)
----

Η κατάργηση του καταλόγου δεν είναι δύσκολη, αλλά μπορεί να είναι λίγο συγκεχυμένη η ύπαρξη εκεί.
Αν το αφαιρέσουμε και μετά επιστρέψουμε στον κλάδο που έχει αυτό το υπομονάδα, θα χρειαστεί να εκτελέσουμε την `update submodule - init 'για να την επαναδημιουργήσουμε ξανά.

Removing the directory isn't difficult, but it can be a bit confusing to have that in there.
If you do remove it and then switch back to the branch that has that submodule, you will need to run `submodule update --init` to repopulate it.

[source,console]
----
$ git clean -fdx
Removing CryptoLibrary/

$ git checkout add-crypto
Switched to branch 'add-crypto'

$ ls CryptoLibrary/

$ git submodule update --init
Submodule path 'CryptoLibrary': checked out 'b8dda6aa182ea4464f3f3264b11e0268545172af'

$ ls CryptoLibrary/
Makefile	includes	scripts		src
----

Again, not really very difficult, but it can be a little confusing.

Και πάλι, δεν είναι πραγματικά πολύ δύσκολο, αλλά μπορεί να είναι λίγο συγκεχυμένη.

Η άλλη κύρια προειδοποίηση την οποία αντιμετωπίζουν πολλοί άνθρωποι περιλαμβάνει τη μετάβαση από τους υποκαταλόγους σε υπομονάδες.
Αν παρακολουθούμε αρχεία στο έργο μας και θέλουμε να τα μετακινήσουμε σε υπομονάδα, πρέπει να είμαστε προσεκτικοί ή ο Git θα μας θυμώνει.
Ας υποθέσουμε ότι έχουμε αρχεία σε έναν υποκατάλογο του έργου μας και θέλουμε να το αλλάξουμε σε υπομονάδα.
Αν διαγράψουμε τον υποκατάλογο και στη συνέχεια εκτελέσουμε το `submodule add`, ο Git μάς φωνάζει:

The other main caveat that many people run into involves switching from subdirectories to submodules.
If you’ve been tracking files in your project and you want to move them out into a submodule, you must be careful or Git will get angry at you.
Assume that you have files in a subdirectory of your project, and you want to switch it to a submodule.
If you delete the subdirectory and then run `submodule add`, Git yells at you:

[source,console]
----
$ rm -Rf CryptoLibrary/
$ git submodule add https://github.com/chaconinc/CryptoLibrary
'CryptoLibrary' already exists in the index
----

Πρέπει πρώτα να αποσυμπιέσουμε τον κατάλογο `CryptoLibrary`.
Στη συνέχεια, μπορούμε να προσθέσουμε το υπομοντέλο:

You have to unstage the `CryptoLibrary` directory first.
Then you can add the submodule:

[source,console]
----
$ git rm -r CryptoLibrary
$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
----

Τώρα υποθέστε ότι το κάναμε σε έναν κλάδο.
Αν προσπαθήσουμε να επιστρέψουμε σε κλάδο όπου αυτά τα αρχεία βρίσκονται ακόμα στο πραγματικό δέντρο και όχι σε ένα υπομονάδα - λαμβάνουμε αυτό το σφάλμα:

Now suppose you did that in a branch.
If you try to switch back to a branch where those files are still in the actual tree rather than a submodule – you get this error:

[source,console]
----
$ git checkout master
error: The following untracked working tree files would be overwritten by checkout:
  CryptoLibrary/Makefile
  CryptoLibrary/includes/crypto.h
  ...
Please move or remove them before you can switch branches.
Aborting
----

Μπορούμε να τον αναγκάσουμε να μεταβούμε με το `checkout -f`, αλλά να είμαστε προσεκτικοί ώστε να μην έχουμε μη αποθηκευμένες αλλαγές εκεί καθώς θα μπορούσαν να αντικατασταθούν με αυτή την εντολή.

You can force it to switch with `checkout -f`, but be careful that you don't have unsaved changes in there as they could be overwritten with that command.

[source,console]
----
$ git checkout -f master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'
----

Then, when you switch back, you get an empty `CryptoLibrary` directory for some reason and `git submodule update` may not fix it either.
You may need to go into your submodule directory and run a `git checkout .` to get all your files back.
You could run this in a `submodule foreach` script to run it for multiple submodules.

Στη συνέχεια, όταν γυρίζουμε πίσω, παίρνουμε έναν κενό κατάλογο `CryptoLibrary` για κάποιο λόγο και η` git update submodule` δεν μπορεί να το διορθώσει.
Ενδέχεται να χρειαστεί να μεταβούμε στον κατάλογο υπομονάδων μας και να εκτελέσουμε ένα 'git checkout' για να επιστρέψουμε όλα τα αρχεία μας.
Θα μπορούσαμε να το εκτελέσουμε σε ένα σενάριο `submodule foreach` για να το εκτελέσουμε για πολλαπλές υπομονάδες.

Είναι σημαντικό να σημειώσουμε ότι οι υπομονάδες αυτές τις μέρες διατηρούν όλα τα δεδομένα Git στον κατάλογο `.git` του κορυφαίου έργου, έτσι αντίθετα από πολύ παλιότερες εκδόσεις του Git, καταστρέφοντας έναν κατάλογο υπομονάδων, δεν θα χάσουμε τίποτα υποβολές ή κλάδους που είχατε.

It's important to note that submodules these days keep all their Git data in the top project's `.git` directory, so unlike much older versions of Git, destroying a submodule directory won't lose any commits or branches that you had.

Με αυτά τα εργαλεία, οι υπομονάδες μπορούν να είναι μια αρκετά απλή και αποτελεσματική μέθοδος για την ανάπτυξη σε πολλά σχετικά αλλά ξεχωριστά έργα ταυτόχρονα.

With these tools, submodules can be a fairly simple and effective method for developing on several related but still separate projects simultaneously.
