[[_rerere]]
=== Rerere

Η λειτουργικότητα `git rerere` είναι ένα κομμάτι κρυμμένο χαρακτηριστικό.
Το όνομα σημαίνει "επαναχρησιμοποιούμενη καταγεγραμμένη ανάλυση" και όπως υποδηλώνει το όνομα, μας επιτρέπει να ζητήσουμε από το Git να θυμάται πώς έχουμε επιλύσει μια σύγκρουση hunk έτσι ώστε την επόμενη φορά που βλέπει την ίδια διαμάχη, το Git μπορεί αυτόματα να το λύσει για εσείς.

The `git rerere` functionality is a bit of a hidden feature.
The name stands for ``reuse recorded resolution'' and as the name implies, it allows you to ask Git to remember how you've resolved a hunk conflict so that the next time it sees the same conflict, Git can automatically resolve it for you.

There are a number of scenarios in which this functionality might be really handy.
One of the examples that is mentioned in the documentation is if you want to make sure a long lived topic branch will merge cleanly but don't want to have a bunch of intermediate merge commits.
With `rerere` turned on you can merge occasionally, resolve the conflicts, then back out the merge.
If you do this continuously, then the final merge should be easy because `rerere` can just do everything for you automatically.

Υπάρχουν ορισμένα σενάρια στα οποία η λειτουργία αυτή μπορεί να είναι πολύ βολική.
Ένα από τα παραδείγματα που αναφέρονται στην τεκμηρίωση είναι αν θέλουμε να βεβαιωθούμε ότι έναν μακρόβιο κλάδο θεμάτων θα συγχωνευθεί καθαρά αλλά δεν θέλουμε να έχουμε μια δέσμη ενδιάμεσων υποβολών συγχώνευσης.
Με το `rerere` ενεργοποιημένο μπορούμε να συγχωνεύσουμε περιστασιακά, να επιλύσουμε τις συγκρούσεις και στη συνέχεια να επαναφέρουμε τη συγχώνευση.
Αν το κάνουμε αυτό συνεχώς, τότε η τελική συγχώνευση θα είναι εύκολη επειδή το `rerere` μπορεί να κάνει τα πάντα για εσάς αυτόματα.

Αυτή η ίδια τακτική μπορεί να χρησιμοποιηθεί αν θέλουμε να διατηρήσουμε ένα υποκατάστατο κλάδου έτσι ώστε να μην χρειάζεται να ασχοληθούμε με τις ίδιες αντιπαραθέσεις σύγκρουσης κάθε φορά που το κάνουμε.
Ή αν θέλουμε να πάρουμε έναν κλάδο στον οποίο συγχωνεύσαμε και να διορθώσουμε μια συρροή συγκρούσεων και στη συνέχεια να αποφασίσουμε να το επαναπροσδιορίσουμε - πιθανότατα δεν θα χρειαστεί να κάνουμε όλες τις ίδιες συγκρούσεις ξανά.

This same tactic can be used if you want to keep a branch rebased so you don't have to deal with the same rebasing conflicts each time you do it.
Or if you want to take a branch that you merged and fixed a bunch of conflicts and then decide to rebase it instead - you likely won't have to do all the same conflicts again.

Another situation is where you merge a bunch of evolving topic branches together into a testable head occasionally, as the Git project itself often does.
If the tests fail, you can rewind the merges and re-do them without the topic branch that made the tests fail without having to re-resolve the conflicts again.

Μια άλλη κατάσταση είναι όπου συγχωνεύουμε μια δέσμη εξελισσόμενων κλάδων του θέματος μαζί σε ένα δοκιμαστικό κεφάλι περιστασιακά, όπως το ίδιο το έργο Git συχνά.
Εάν οι δοκιμές αποτύχουν, μπορούμε να επανατυλίξουμε τις συγχωνεύσεις και να τις επαναλάβουμε χωρίς το κλάδο θέματος που έκανε τις δοκιμές να αποτύχουν χωρίς να χρειάζεται να επαναπροσδιορίσουμε ξανά τις συγκρούσεις.

Για να ενεργοποιήσουμε τη λειτουργία `rerere`, απλά πρέπει να εκτελέσουμε αυτήν τη ρύθμιση παραμέτρων:

To enable the `rerere` functionality, you simply have to run this config setting:

[source,console]
----
$ git config --global rerere.enabled true
----

You can also turn it on by creating the `.git/rr-cache` directory in a specific repository, but the config setting is clearer and it can be done globally.

Μπορούμε επίσης να το ενεργοποιήσουμε δημιουργώντας τον κατάλογο `.git / rr-cache` σε ένα συγκεκριμένο χώρο αποθήκευσης, αλλά η ρύθμιση config είναι σαφέστερη και μπορεί να γίνει σε παγκόσμιο επίπεδο.

Τώρα ας δούμε ένα απλό παράδειγμα, παρόμοιο με το προηγούμενο.
Ας υποθέσουμε ότι έχουμε ένα αρχείο που μοιάζει με αυτό:

[source,console]
----
#! /usr/bin/env ruby

def hello
  puts 'hello world'
end
----

Σε έναν κλάδο αλλάζουμε τη λέξη `` hello '' στο `` hola '', στη συνέχεια σε έναν άλλο κλάδο αλλάζουμε το `'κόσμο' 'στο` `mundo' ', ακριβώς όπως πριν.

In one branch we change the word ``hello'' to ``hola'', then in another branch we change the ``world'' to ``mundo'', just like before.

image::images/rerere1.png[]

Όταν συγχωνεύσουμε τους δύο κλάδους, θα πάρουμε σύγκρουση συγχώνευσης:

[source,console]
----
$ git merge i18n-world
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Recorded preimage for 'hello.rb'
Automatic merge failed; fix conflicts and then commit the result.
----

Θα πρέπει να παρατηρήσουμε τη νέα γραμμή `Recorded preimage for FILE` εκεί μέσα.
Διαφορετικά, θα πρέπει να φαίνεται ακριβώς όπως μια κανονική σύγκρουση συγχώνευσης.
Σε αυτό το σημείο, `rerere` μπορεί να μας πει λίγα πράγματα.
Κανονικά, μπορούμε να εκτελέσουμε την κατάσταση `git 'σε αυτό το σημείο για να δούμε τι είναι όλες οι συγκρουόμενες:

You should notice the new line `Recorded preimage for FILE` in there.
Otherwise it should look exactly like a normal merge conflict.
At this point, `rerere` can tell us a few things.
Normally, you might run `git status` at this point to see what all conflicted:

[source,console]
----
$ git status
# On branch master
# Unmerged paths:
#   (use "git reset HEAD <file>..." to unstage)
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      hello.rb
#
----

Ωστόσο, το `git rerere` θα μας πει επίσης τι έχει καταγράψει την κατάσταση προ συγχώνευσης με την κατάσταση` git rerere`:

However, `git rerere` will also tell you what it has recorded the pre-merge state for with `git rerere status`:

[source,console]
----
$ git rerere status
hello.rb
----

Και το `git rerere diff` θα δείξει την τρέχουσα κατάσταση του ψηφίσματος - τι ξεκινήσαμε να επιλύσουμε και τι έχουμε επιλύσει.

And `git rerere diff` will show the current state of the resolution - what you started with to resolve and what you've resolved it to.

[source,console]
----
$ git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,11 @@
 #! /usr/bin/env ruby

 def hello
-<<<<<<<
-  puts 'hello mundo'
-=======
+<<<<<<< HEAD
   puts 'hola world'
->>>>>>>
+=======
+  puts 'hello mundo'
+>>>>>>> i18n-world
 end
----

Επίσης (και αυτό δεν σχετίζεται πραγματικά με το `rerere`), μπορούμε να χρησιμοποιήσουμε τα` ls-files -u` για να δούμε τα αλληλοσυγκρουόμενα αρχεία και τις εκδόσεις πριν, αριστερά και δεξιά:

Also (and this isn't really related to `rerere`), you can use `ls-files -u` to see the conflicted files and the before, left and right versions:

[source,console]
----
$ git ls-files -u
100644 39804c942a9c1f2c03dc7c5ebcd7f3e3a6b97519 1	hello.rb
100644 a440db6e8d1fd76ad438a49025a9ad9ce746f581 2	hello.rb
100644 54336ba847c3758ab604876419607e9443848474 3	hello.rb
----

Τώρα μπορούμε να το λύσουμε για να `` βάλει '' hola mundo'` και μπορούμε να εκτελέσουμε ξανά την εντολή `rerere diff` για να δούμε τι θα θυμάται το rerere:

Now you can resolve it to just be `puts 'hola mundo'` and you can run the `rerere diff` command again to see what rerere will remember:

[source,console]
----
$ git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-<<<<<<<
-  puts 'hello mundo'
-=======
-  puts 'hola world'
->>>>>>>
+  puts 'hola mundo'
 end
----

So that basically says, when Git sees a hunk conflict in a `hello.rb` file that has ``hello mundo'' on one side and ``hola world'' on the other, it will resolve it to ``hola mundo''.

Έτσι, όπως λέει, όταν ο Git βλέπει μια σύγκρουση hunk σε ένα αρχείο `hello.rb` που έχει` hello mundo 'στη μία πλευρά και `` hola world' 'από την άλλη, θα το λύσει στο `` hola mundo ''.

Τώρα μπορούμε να το επισημάνουμε ως επιλυμένο και να το υποβάλουμε:

Now we can mark it as resolved and commit it:

[source,console]
----
$ git add hello.rb
$ git commit
Recorded resolution for 'hello.rb'.
[master 68e16e5] Merge branch 'i18n'
----

Βλέπουμε ότι αναφέρει "Recorded resolution for FILE".

You can see that it "Recorded resolution for FILE".

image::images/rerere2.png[]

Τώρα, ας ανατρέψουμε αυτήν τη συγχώνευση και στη συνέχεια να την αναδιοργανώσουμε στην κορυφή του κυρίου κλάδου αντί.
Μπορούμε να μετακινήσουμε τον κλάδο μας πίσω χρησιμοποιώντας το 'reset' όπως είδαμε στο << _git_reset >>.

Now, let's undo that merge and then rebase it on top of our master branch instead.
We can move our branch back by using `reset` as we saw in <<_git_reset>>.

[source,console]
----
$ git reset --hard HEAD^
HEAD is now at ad63f15 i18n the hello
----

Η συγχώνευσή μας ακυρώνεται.
Τώρα ας αναδιαμορφώσουμε το κλάδο του θέματος.

Our merge is undone.
Now let's rebase the topic branch.

[source,console]
----
$ git checkout i18n-world
Switched to branch 'i18n-world'

$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: i18n one word
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Failed to merge in the changes.
Patch failed at 0001 i18n one word
----

Τώρα, πήραμε την ίδια διένεξη συγχώνευσης όπως περίμενε, αλλά ρίξτε μια ματιά στη γραμμή `Resolved FILE using previous resolution '.
Αν εξετάσουμε το αρχείο, θα δούμε ότι έχει ήδη επιλυθεί, δεν υπάρχουν δείκτες σύγκλισης συγχώνευσης.

Now, we got the same merge conflict like we expected, but take a look at the `Resolved FILE using previous resolution` line.
If we look at the file, we'll see that it's already been resolved, there are no merge conflict markers in it.

[source,console]
----
$ cat hello.rb
#! /usr/bin/env ruby

def hello
  puts 'hola mundo'
end
----

Επίσης, η `git diff` θα μας δείξει πώς ξανα-επιλύθηκε αυτόματα:

[source,console]
----
$ git diff
diff --cc hello.rb
index a440db6,54336ba..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end
----

image::images/rerere3.png[]

Μπορούμε επίσης να αναδημιουργήσουμε την κατάσταση σύγκρουσης του αρχείου με την εντολή `checkout`:

[source,console]
----
$ git checkout --conflict=merge hello.rb
$ cat hello.rb
#! /usr/bin/env ruby

def hello
<<<<<<< ours
  puts 'hola world'
=======
  puts 'hello mundo'
>>>>>>> theirs
end
----

Είδαμε ένα παράδειγμα αυτού στο << _ advanced_merging >>.
Προς το παρόν, όμως, ας το επαναλάβουμε με την εκ νέου λειτουργία `rerere` ξανά:

We saw an example of this in <<_advanced_merging>>.
For now though, let's re-resolve it by just running `rerere` again:

[source,console]
----
$ git rerere
Resolved 'hello.rb' using previous resolution.
$ cat hello.rb
#! /usr/bin/env ruby

def hello
  puts 'hola mundo'
end
----

Έχουμε ξαναξεκινήσει αυτόματα το αρχείο χρησιμοποιώντας την ανεκμετάλλευτη ανάλυση `rerere`.
Τώρα μπορούμε να προσθέσουμε και να συνεχίσουμε την αναδημοσίευση για να την ολοκληρώσουμε.

We have re-resolved the file automatically using the `rerere` cached resolution.
You can now add and continue the rebase to complete it.

[source,console]
----
$ git add hello.rb
$ git rebase --continue
Applying: i18n one word
----

Έτσι, εάν κάνουμε πολλές συγχωνεύσεις ή θέλουμε να διατηρήσουμε έναν θεματικό κλάδο ενημερωμένο με τον κύριο κλάδο μας χωρίς έναν τόνο συγχώνευσης ή μπορούμε να κάνουμε rebase συχνά, μπορούμε να ενεργοποιήσουμε το `rerere` για να βοηθήσουμε τη ζωή μας έξω κομμάτι.

So, if you do a lot of re-merges, or want to keep a topic branch up to date with your master branch without a ton of merges, or you rebase often, you can turn on `rerere` to help your life out a bit.
