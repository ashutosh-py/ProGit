[[_revision_selection]]
=== Επιλογή αναθεώρησης

Το Git μάς επιτρέπει να ορίσουμε συγκεκριμένες υποβολές ή ένα φάσμα υποβολών με διάφορους τρόπους.
Δεν είναι απαραίτητα προφανείς, αλλά είναι χρήσιμο να γνωρίζουμε.

==== Απλές αναθεωρήσεις

Μπορούμε προφανώς να αναφερθούμε σε μια υποβολή από το hash SHA-1 που δίνεται αλλά υπάρχουν πιο φιλικοί-προς-τον-άνθρωπο τρόποι για να αναφερθεί κανείς σε υποβολές.
Αυτή η ενότητα περιγράφει τους διάφορους τρόπους με τους οποίους μπορούμε να αναφερθούμε σε μία μόνο υποβολή.

==== Σύντομο SHA-1

Το Git είναι αρκετά έξυπνο για να καταλάβει ποια υποβολή θέλαμε να  πληκτρολογήσουμε αν δώσουμε τους πρώτους χαρακτήρες, αρκεί ο μερικός SHA-1 μας να έχει μήκος τουλάχιστον τέσσερις χαρακτήρες και να είναι ασαφής -- δηλαδή, μόνο ένα αντικείμενο στο τρέχον αποθετήριο αρχίζει με αυτό το μερικό SHA-1.

Για παράδειγμα, για να δούμε μια συγκεκριμένη δέσμευση, ας υποθέσουμε ότι τρέχεουμε μια εντολή `git log` και εντοπίζουμε την υποβολή στην οποία προσθέσαμε ορισμένες λειτουργίες:

[source,console]
----
$ git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff
----

Σε αυτή την περίπτωση, επιλέξτε το στοιχείο `1c002dd .... 'Αν έχετε` git show` που υποβάλλονται, οι ακόλουθες εντολές είναι ισοδύναμες (υποθέτοντας ότι οι μικρότερες εκδόσεις είναι ξεκάθαρες):

In this case, choose `1c002dd....` If you `git show` that commit, the following commands are equivalent (assuming the shorter versions are unambiguous):

[source,console]
----
$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
$ git show 1c002dd4b536e7479f
$ git show 1c002d
----

Το Git μπορεί να υπολογίσει μια σύντομη, μοναδική συντομογραφία για τις τιμές SHA-1.
Εάν περάσουμε το `--abbrev-commit 'στην εντολή` git log`, η έξοδος θα χρησιμοποιήσει μικρότερες τιμές αλλά θα τους κρατήσει μοναδικές. έχει προεπιλεγεί να χρησιμοποιεί επτά χαρακτήρες, αλλά τους καθιστά περισσότερο αν είναι απαραίτητο για να διατηρηθεί το SHA-1 ξεκάθαρο:

Git can figure out a short, unique abbreviation for your SHA-1 values.
If you pass `--abbrev-commit` to the `git log` command, the output will use shorter values but keep them unique; it defaults to using seven characters but makes them longer if necessary to keep the SHA-1 unambiguous:

[source,console]
----
$ git log --abbrev-commit --pretty=oneline
ca82a6d changed the version number
085bb3b removed unnecessary test code
a11bef0 first commit
----

Generally, eight to ten characters are more than enough to be unique within a project.

Γενικά, οκτώ έως δέκα χαρακτήρες είναι περισσότερο από αρκετό για να είναι μοναδικό σε ένα έργο.

Για παράδειγμα, ο πυρήνας Linux, ο οποίος είναι ένα αρκετά μεγάλο έργο με πάνω από 450k υποβάλλει και 3,6 εκατομμύρια αντικείμενα, δεν έχει δύο αντικείμενα των οποίων τα SHA-1s επικαλύπτονται περισσότερο από τους 11 πρώτους χαρακτήρες.

As an example, the Linux kernel, which is a pretty large project with over 450k commits and 3.6 million objects, has no two objects whose SHA-1s overlap more than the first 11 characters.

[ΣΗΜΕΙΩΣΗ]
.Σχετικά με τον SHA-1
====

A lot of people become concerned at some point that they will, by random happenstance, have two objects in their repository that hash to the same SHA-1 value.
What then?

Πολλοί άνθρωποι ανησυχούν σε κάποιο σημείο ότι, κατά τυχαίο τυχαίο συμβάν, έχουν δύο αντικείμενα στο αποθετήριο τους, τα οποία έχουν κατατεθεί στην ίδια τιμή SHA-1.
Τι τότε?

Εάν συμβεί να διαπράξουμε ένα αντικείμενο που έχει την ίδια τιμή SHA-1 με ένα προηγούμενο αντικείμενο στο χώρο αποθήκευσής μας, το Git θα δει το προηγούμενο αντικείμενο ήδη στη βάση δεδομένων μας Git και υποθέστε ότι έχει ήδη γραφτεί.
Εάν προσπαθήσουμε να ελέγξουμε ξανά αυτό το αντικείμενο σε κάποια στιγμή, θα έχουμε πάντα τα δεδομένα του πρώτου αντικειμένου.

If you do happen to commit an object that hashes to the same SHA-1 value as a previous object in your repository, Git will see the previous object already in your Git database and assume it was already written.
If you try to check out that object again at some point, you’ll always get the data of the first object.

However, you should be aware of how ridiculously unlikely this scenario is.
The SHA-1 digest is 20 bytes or 160 bits.
The number of randomly hashed objects needed to ensure a 50% probability of a single collision is about 2^80^
(the formula for determining collision probability is `p = (n(n-1)/2) * (1/2^160))`. 2^80^
is 1.2 x 10^24^
or 1 million billion billion.
That’s 1,200 times the number of grains of sand on the earth.

Ωστόσο, θα πρέπει να γνωρίζουμε πόσο γελοία απίθανο είναι αυτό το σενάριο.
Η πέψη SHA-1 είναι 20 bytes ή 160 bit.
Ο αριθμός των τυχαία χαστούμενων αντικειμένων που απαιτούνται για να εξασφαλιστεί μια πιθανότητα 50% μιας σύγκρουσης είναι περίπου 2 ^ 80 ^
(ο τύπος για τον προσδιορισμό της πιθανότητας σύγκρουσης είναι `p = (n (n-1) / 2) * (1/2 ^ 160))». 2 ^ 80 ^
είναι 1,2 χ 10 ^ 24 ^
ή 1 εκατομμύριο δισ. δισεκατομμύρια.
Αυτό είναι 1200 φορές ο αριθμός των κόκκων άμμου στη γη.

Ακολουθεί ένα παράδειγμα για να μας δώσουμε μια ιδέα για το τι θα χρειαστεί για μια σύγκρουση SHA-1.
Εάν όλα τα 6,5 δισεκατομμύρια άνθρωποι στη Γη προγραμματίζονταν και κάθε δευτερόλεπτο, κάθε ένας παράγει κώδικα που ισοδυναμούσε με ολόκληρη την ιστορία του πυρήνα του Linux (3,6 εκατομμύρια αντικείμενα Git) και τον ώθησε σε ένα τεράστιο αποθετήριο Git, θα χρειαζόταν περίπου 2 χρόνια μέχρις ότου αυτός ο χώρος αποθήκευσης περιείχε αρκετά αντικείμενα ώστε να έχει πιθανότητα 50% μιας σύγκρουσης αντικειμένων SHA-1.
Υπάρχει μεγαλύτερη πιθανότητα ότι κάθε μέλος της ομάδας προγραμματισμού μας θα επιτεθεί και θα σκοτωθεί από λύκους σε μη συγγενή περιστατικά την ίδια νύχτα.

Here’s an example to give you an idea of what it would take to get a SHA-1 collision.
If all 6.5 billion humans on Earth were programming, and every second, each one was producing code that was the equivalent of the entire Linux kernel history (3.6 million Git objects) and pushing it into one enormous Git repository, it would take roughly 2 years until that repository contained enough objects to have a 50% probability of a single SHA-1 object collision.
A higher probability exists that every member of your programming team will be attacked and killed by wolves in unrelated incidents on the same night.
====

[[_branch_references]]
==== Αναφορές κλάδων

Ο πιο απλός τρόπος για να καθορίσουμε μια δέσμευση απαιτεί να έχει μια αναφορά κλάδου που τον δείχνει.
Στη συνέχεια, μπορούμε να χρησιμοποιήσουμε ένα όνομα κλάδου σε οποιαδήποτε εντολή Git που αναμένει ένα αντικείμενο δέσμευσης ή μια τιμή SHA-1.
Για παράδειγμα, εάν θέλουμε να εμφανίσουμε το τελευταίο αντικείμενο commit σε ένα κλάδο, οι ακόλουθες εντολές είναι ισοδύναμες, υποθέτοντας ότι ο κλάδος `topic1` δείχνει` ca82a6d`:

The most straightforward way to specify a commit requires that it has a branch reference pointed at it.
Then, you can use a branch name in any Git command that expects a commit object or SHA-1 value.
For instance, if you want to show the last commit object on a branch, the following commands are equivalent, assuming that the `topic1` branch points to `ca82a6d`:

[source,console]
----
$ git show ca82a6dff817ec66f44342007202690a93763949
$ git show topic1
----

Αν θέλουμε να δούμε ποιο συγκεκριμένο SHA-1 δείχνει έναν κλάδο ή αν θέλουμε να δούμε ποια από αυτά τα παραδείγματα αποδυναμώνεται από άποψη SHA-1s, μπορούμε να χρησιμοποιήσουμε ένα εργαλείο υδραυλικής εγκατάστασης Git με την ονομασία `rev-parse`.
Μπορούμε να δούμε << _ git_internals >> για περισσότερες πληροφορίες σχετικά με τα εργαλεία υδραυλικών εγκαταστάσεων. Βασικά, το `rev-parse` υπάρχει για λειτουργίες χαμηλότερου επιπέδου και δεν έχει σχεδιαστεί για να χρησιμοποιείται στις καθημερινές λειτουργίες.
Ωστόσο, μπορεί να μας βοηθήσει μερικές φορές όταν χρειάζεται να δούμε τι συμβαίνει πραγματικά.
Εδώ μπορούμε να εκτελέσουμε `rev-parse` στον κλάδο μας.

If you want to see which specific SHA-1 a branch points to, or if you want to see what any of these examples boils down to in terms of SHA-1s, you can use a Git plumbing tool called `rev-parse`.
You can see <<_git_internals>> for more information about plumbing tools; basically, `rev-parse` exists for lower-level operations and isn’t designed to be used in day-to-day operations.
However, it can be helpful sometimes when you need to see what’s really going on.
Here you can run `rev-parse` on your branch.

[source,console]
----
$ git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949
----

[[_git_reflog]]
==== RefLog Shortnames

One of the things Git does in the background while you’re working away is keep a ``reflog'' – a log of where your HEAD and branch references have been for the last few months.

Ένα από τα πράγματα που κάνει το Git στο παρασκήνιο ενώ εργαζόμαστε είναι να κρατάμε ένα `` reflog '' - ένα αρχείο καταγραφής των επικεφαλίδων μας και των κλάδων μας για τους τελευταίους μήνες.

Μπορούμε να δούμε το reflog μας χρησιμοποιώντας το `git reflog`:

You can see your reflog by using `git reflog`:

[source,console]
----
$ git reflog
734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated
d921970 HEAD@{1}: merge phedders/rdocs: Merge made by recursive.
1c002dd HEAD@{2}: commit: added some blame and merge stuff
1c36188 HEAD@{3}: rebase -i (squash): updating HEAD
95df984 HEAD@{4}: commit: # This is a combination of two commits.
1c36188 HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD
----

Κάθε φορά που η συμβουλή του κλάδου μας ενημερώνεται για οποιονδήποτε λόγο, το Git αποθηκεύει αυτές τις πληροφορίες για εσάς σε αυτό το προσωρινό ιστορικό.
Και μπορούμε επίσης να ορίσουμε παλαιότερες υποβολές με αυτά τα δεδομένα.
Εάν θέλουμε να δούμε την πέμπτη προγενέστερη τιμή του HEAD του αποθετηρίου μας, μπορούμε να χρησιμοποιήσουμε την αναφορά `@ {n}` που βλέπουμε στην έξοδο reflog:

Every time your branch tip is updated for any reason, Git stores that information for you in this temporary history.
And you can specify older commits with this data, as well.
If you want to see the fifth prior value of the HEAD of your repository, you can use the `@{n}` reference that you see in the reflog output:

[source,console]
----
$ git show HEAD@{5}
----

Μπορούμε επίσης να χρησιμοποιήσουμε αυτήν τη σύνταξη για να δούμε πού ήταν ένα συγκεκριμένο χρονικό διάστημα.
Για παράδειγμα, για να δούμε πού ήταν χθες ο κλάδος `master`, μπορούμε να πληκτρολογήσετε

You can also use this syntax to see where a branch was some specific amount of time ago.
For instance, to see where your `master` branch was yesterday, you can type

[source,console]
----
$ git show master@{yesterday}
----

That shows you where the branch tip was yesterday.
This technique only works for data that’s still in your reflog, so you can’t use it to look for commits older than a few months.

Αυτό μας δείχνει πού ήταν η άκρη του κλάδου χθες.
Αυτή η τεχνική λειτουργεί μόνο για δεδομένα που εξακολουθούν να βρίσκονται στο reflog μας, έτσι δεν μπορούμε να τα χρησιμοποιήσουμε για να αναζητήσουμε υποβολές παλαιότερες από μερικούς μήνες.

Για να δούμε πληροφορίες reflog μορφοποιημένες όπως η έξοδος `git log`, μπορούμε να εκτελέσετε` git log -g`:

To see reflog information formatted like the `git log` output, you can run `git log -g`:

[source,console]
----
$ git log -g master
commit 734713bc047d87bf7eac9674765ae793478c50d3
Reflog: master@{0} (Scott Chacon <schacon@gmail.com>)
Reflog message: commit: fixed refs handling, added gc auto, updated
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Reflog: master@{1} (Scott Chacon <schacon@gmail.com>)
Reflog message: merge phedders/rdocs: Merge made by recursive.
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'
----

Είναι σημαντικό να σημειώσουμε ότι οι πληροφορίες reflog είναι αυστηρά τοπικές - είναι ένα αρχείο καταγραφής του τι έχουμε κάνει στο χώρο αποθήκευσής μας.
Οι αναφορές δεν θα είναι οι ίδιες σε άλλο αντίγραφο του αποθετηρίου. και αμέσως μετά την αρχική κλωνοποίηση ενός αποθετηρίου, θα έχουμε ένα κενό reflog, καθώς δεν έχει πραγματοποιηθεί καμία δραστηριότητα στο αποθετήριο μας.
Το τρέξιμο `git show HEAD @ {2.months.ago}` θα λειτουργήσει μόνο αν έχουμε κλωνοποιήσει το πρόγραμμα τουλάχιστον πριν από δύο μήνες - αν τον έχουμε κλωνοποιήσει πριν από πέντε λεπτά, δεν θα έχουμε αποτελέσματα.

It’s important to note that the reflog information is strictly local – it’s a log of what you’ve done in your repository.
The references won’t be the same on someone else’s copy of the repository; and right after you initially clone a repository, you'll have an empty reflog, as no activity has occurred yet in your repository.
Running `git show HEAD@{2.months.ago}` will work only if you cloned the project at least two months ago – if you cloned it five minutes ago, you’ll get no results.

==== Ancestry References

Ο άλλος κύριος τρόπος για να καθορίσουμε μια δέσμευση είναι μέσω της καταγωγής του.
Αν τοποθετήσουμε ένα `^` στο τέλος μιας αναφοράς, το Git το επιλύει ώστε να σημαίνει το γονέα αυτής της δέσμευσης.
Ας υποθέσουμε ότι βλέπουμε την ιστορία του έργου μας:

The other main way to specify a commit is via its ancestry.
If you place a `^` at the end of a reference, Git resolves it to mean the parent of that commit.
Suppose you look at the history of your project:

[source,console]
----
$ git log --pretty=format:'%h %s' --graph
* 734713b fixed refs handling, added gc auto, updated tests
*   d921970 Merge commit 'phedders/rdocs'
|\
| * 35cfb2b Some rdoc changes
* | 1c002dd added some blame and merge stuff
|/
* 1c36188 ignore *.gem
* 9b29157 add open3_detach to gemspec file list
----

Στη συνέχεια, μπορούμε να δούμε την προηγούμενη διεκπεραίωση καθορίζοντας `HEAD ^`, που σημαίνει `` το γονικό της HEAD '':

Then, you can see the previous commit by specifying `HEAD^`, which means ``the parent of HEAD'':

[source,console]
----
$ git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'
----

Μπορούμε επίσης να ορίσουμε έναν αριθμό μετά το `^` - για παράδειγμα, `d921970 ^ 2` σημαίνει` `το δεύτερο γονέα του d921970. ''
Αυτή η σύνταξη είναι χρήσιμη μόνο για υποβολές συγχώνευσης, οι οποίες έχουν περισσότερους από έναν γονείς.
Ο πρώτος γονέας είναι ο κλάδος στο οποίο ήμασταν όταν συγχωνεύσαμε και το δεύτερο είναι η δέσμευση για τον κλάδο στον οποίο συγχωνεύσατε:

You can also specify a number after the `^` – for example, `d921970^2` means ``the second parent of d921970.''
This syntax is only useful for merge commits, which have more than one parent.
The first parent is the branch you were on when you merged, and the second is the commit on the branch that you merged in:

[source,console]
----
$ git show d921970^
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff

$ git show d921970^2
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
Author: Paul Hedderly <paul+git@mjr.org>
Date:   Wed Dec 10 22:22:03 2008 +0000

    Some rdoc changes
----

Η άλλη κύρια προδιαγραφή των προγόνων είναι η `~`.
Αυτό αναφέρεται επίσης στον πρώτο γονέα, έτσι ώστε τα HEAD ~ `και` HEAD ^ `να είναι ισοδύναμα.
Η διαφορά γίνεται εμφανής όταν καθορίζουμε έναν αριθμό.
`HEAD ~ 2` σημαίνει` `ο πρώτος γονέας του πρώτου γονέα '' ή` `ο παππούς και γιαγιάς '' - διασχίζει τους πρώτους γονείς τον αριθμό των φορών που καθορίζουμε.
Για παράδειγμα, στην ιστορία που αναφέρθηκε νωρίτερα, θα ήταν `HEAD ~ 3`

The other main ancestry specification is the `~`.
This also refers to the first parent, so `HEAD~` and `HEAD^` are equivalent.
The difference becomes apparent when you specify a number.
`HEAD~2` means ``the first parent of the first parent,'' or ``the grandparent'' – it traverses the first parents the number of times you specify.
For example, in the history listed earlier, `HEAD~3` would be

[source,console]
----
$ git show HEAD~3
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner <tom@mojombo.com>
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
----

Αυτό μπορεί επίσης να γραφεί `HEAD ^^^`, το οποίο και πάλι είναι το πρώτο γονέα του πρώτου γονέα του πρώτου γονέα:

This can also be written `HEAD^^^`, which again is the first parent of the first parent of the first parent:

[source,console]
----
$ git show HEAD^^^
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner <tom@mojombo.com>
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
----

Μπορούμε επίσης να συνδυάσουμε αυτές τις σύνταξης - μπορούμε να πάρουμε το δεύτερο γονέα της προηγούμενης αναφοράς (υποθέτοντας ότι ήταν μια δέσμευση συγχώνευσης) χρησιμοποιώντας το "HEAD ~ 3 ^ 2" και ούτω καθεξής.

You can also combine these syntaxes – you can get the second parent of the previous reference (assuming it was a merge commit) by using `HEAD~3^2`, and so on.

[[_commit_ranges]]
==== Commit Ranges

Τώρα που μπορούμε να καθορίσουμε μεμονωμένες υποβολές, ας δούμε πώς να καθορίσουμε σειρές υποβολών.
Αυτό είναι ιδιαίτερα χρήσιμο για τη διαχείριση των καταστημάτων μας - αν έχουμε πολλούς κλάδους, μπορούμε να χρησιμοποιήσουμε τις προδιαγραφές της σειράς για να απαντήσουμε σε ερωτήσεις όπως `` Ποια δουλειά σε αυτόν τον κλάδο δεν έχω ακόμα συγχωνεύσει στον κύριο κλάδο μου; ''

Now that you can specify individual commits, let’s see how to specify ranges of commits.
This is particularly useful for managing your branches – if you have a lot of branches, you can use range specifications to answer questions such as, ``What work is on this branch that I haven’t yet merged into my main branch?''

===== Double Dot

Η πιο κοινή προδιαγραφή εύρους είναι η σύνταξη διπλής κουκίδας.
Αυτό βασικά ζητά από το Git να επιλύσει μια σειρά υποβολών που είναι προσβάσιμες από μία δέσμευση αλλά δεν είναι προσβάσιμες από άλλη.
Για παράδειγμα, λέτε ότι έχουμε ένα ιστορικό διαπραγμάτευσης που μοιάζει με << double_dot >>.

The most common range specification is the double-dot syntax.
This basically asks Git to resolve a range of commits that are reachable from one commit but aren’t reachable from another.
For example, say you have a commit history that looks like <<double_dot>>.

[[double_dot]]
.Example history for range selection.
image::images/double-dot.png[Example history for range selection.]

Θέλουμε να δούμε τι υπάρχει στο τμήμα πειράματός μας που δεν έχει ακόμη συγχωνευθεί στο κύριο κατάστημα.
Μπορούμε να ζητήσουμε από το Git να μας παρουσιάσει ένα αρχείο καταγραφής μόνο αυτών των υποβολών με `master..experiment` - δηλαδή« όλες τις υποβολές που μπορούν να επιτευχθούν με πειράματα που δεν είναι προσβάσιμα από το master ».
Για λόγους ευκρίνειας και σαφήνειας σε αυτά τα παραδείγματα, θα χρησιμοποιήσω τα γράμματα των αντικειμένων δέσμευσης από το διάγραμμα στη θέση της πραγματικής εξόδου καταγραφής με τη σειρά που θα εμφανίζουν:

You want to see what is in your experiment branch that hasn’t yet been merged into your master branch.
You can ask Git to show you a log of just those commits with `master..experiment` – that means ``all commits reachable by experiment that aren’t reachable by master.''
For the sake of brevity and clarity in these examples, I’ll use the letters of the commit objects from the diagram in place of the actual log output in the order that they would display:

[source,console]
----
$ git log master..experiment
D
C
----

Εάν, από την άλλη πλευρά, θέλουμε να δούμε το αντίθετο - όλες οι υποβολές στο `master` που δεν βρίσκονται σε` experiment} - μπορούμε να αντιστρέψουμε τα ονόματα κλάδων.
`experiment..master` μας δείχνει όλα τα` master` που δεν είναι εφικτά από το 'experiment':

If, on the other hand, you want to see the opposite – all commits in `master` that aren’t in `experiment` – you can reverse the branch names.
`experiment..master` shows you everything in `master` not reachable from `experiment`:

[source,console]
----
$ git log experiment..master
F
E
----

Αυτό είναι χρήσιμο αν θέλουμε να διατηρήσουμε ενημερωμένο τον κλάδο `experiment` και να δούμε την προεπισκόπηση του τι πρόκειται να συγχωνεύσουμε.
Μια άλλη πολύ συχνή χρήση αυτής της σύνταξης είναι να δούμε τι πρόκειται να προωθήσουμε σε ένα τηλεχειριστήριο:

This is useful if you want to keep the `experiment` branch up to date and preview what you’re about to merge in.
Another very frequent use of this syntax is to see what you’re about to push to a remote:

[source,console]
----
$ git log origin/master..HEAD
----

Αυτή η εντολή μάς δείχνει όλες τις υποβολές του τρέχοντος κλάδου μας που δεν ανήκουν στον κλάδο `master` στο απομακρυσμένο` origin`.
Εάν εκτελέσουμε ένα `git push` και τον τρέχοντα κλάδο μας παρακολουθεί την `origin/master`, οι υποβολές που αναφέρονται από το `git log orig / master..HEAD` είναι οι υποβολές που θα μεταφερθούν στο διακομιστή.
Μπορούμε επίσης να αφήσουμε εκτός μιας πλευράς της σύνταξης ώστε να έχει το Git να αναλάβει HEAD.
Για παράδειγμα, μπορούμε να πάρουμε τα ίδια αποτελέσματα με το προηγούμενο παράδειγμα πληκτρολογώντας το "git log orig / master". - Το Git αντικαθιστά το HEAD αν λείπει μία πλευρά.

This command shows you any commits in your current branch that aren’t in the `master` branch on your `origin` remote.
If you run a `git push` and your current branch is tracking `origin/master`, the commits listed by `git log origin/master..HEAD` are the commits that will be transferred to the server.
You can also leave off one side of the syntax to have Git assume HEAD.
For example, you can get the same results as in the previous example by typing `git log origin/master..` – Git substitutes HEAD if one side is missing.

===== Multiple Points

Η σύνταξη διπλής κουκίδας είναι χρήσιμη ως συντομογραφία. αλλά ίσως θέλουμε να καθορίσουμε περισσότερους από δύο κλάδους για να υποδείξουμε την αναθεώρησή μας, όπως για παράδειγμα να δούμε τι υποβολές υπάρχουν σε οποιοδήποτε από τους διάφορους κλάδους που δεν ανήκουν στον κλάδο στον οποίο βρισκόμαστε.
Το Git μάς επιτρέπει να το κάνουμε αυτό χρησιμοποιώντας είτε τον χαρακτήρα `^` είτε το `--not` πριν από οποιαδήποτε αναφορά από την οποία δεν θέλουμε να δούμε προσπελάσιμες υποβολές.
Έτσι, αυτές οι τρεις εντολές είναι ισοδύναμες:

The double-dot syntax is useful as a shorthand; but perhaps you want to specify more than two branches to indicate your revision, such as seeing what commits are in any of several branches that aren’t in the branch you’re currently on.
Git allows you to do this by using either the `^` character or `--not` before any reference from which you don’t want to see reachable commits.
Thus these three commands are equivalent:

[source,console]
----
$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA
----

Αυτό είναι ωραίο επειδή με αυτή τη σύνταξη μπορούμε να ορίσουμε περισσότερες από δύο αναφορές στο ερώτημά μας, τις οποίες δεν μπορούμε να κάνουμε με τη σύνταξη διπλής κουκίδας.
Για παράδειγμα, εάν θέλουμε να δούμε όλες τις υποβολές που είναι προσβάσιμες από το `refA` ή το` refB` αλλά όχι από το `refC`, μπορούμε να πληκτρολογήσουμε ένα από αυτά:

This is nice because with this syntax you can specify more than two references in your query, which you cannot do with the double-dot syntax.
For instance, if you want to see all commits that are reachable from `refA` or `refB` but not from `refC`, you can type one of these:

[source,console]
----
$ git log refA refB ^refC
$ git log refA refB --not refC
----

Αυτό κάνει για ένα πολύ ισχυρό σύστημα ερωτημάτων αναθεώρησης που θα μας βοηθήσει να καταλάβουμε τι είναι στους κλάδους μας.

This makes for a very powerful revision query system that should help you figure out what is in your branches.

[[_triple_dot]]
===== Triple Dot

Η τελευταία σύντομη επιλογή σύνθεσης είναι η σύνταξη με τριπλή κουκίδα, η οποία καθορίζει όλες τις υποβολές που είναι προσβάσιμες από μία από τις δύο αναφορές, αλλά όχι και από τις δύο.
Κοιτάξτε πίσω στο παράδειγμα του ιστορικού δέσμευσης στο << double_dot >>.
Αν θέλουμε να δούμε τι υπάρχει στο «master» ή «experiment» αλλά όχι σε συνήθεις αναφορές, μπορούμε να τρέξετε

The last major range-selection syntax is the triple-dot syntax, which specifies all the commits that are reachable by either of two references but not by both of them.
Look back at the example commit history in <<double_dot>>.
If you want to see what is in `master` or `experiment` but not any common references, you can run

[source,console]
----
$ git log master...experiment
F
E
D
C
----

Again, this gives you normal `log` output but shows you only the commit information for those four commits, appearing in the traditional commit date ordering.

Επαναλαμβάνουμε ότι αυτό μας δίνει την κανονική έξοδο `log`, αλλά μας δείχνει μόνο τις πληροφορίες commit για αυτές τις τέσσερις υποβολές, που εμφανίζονται στην παραγγελία παραδοσιακής ημερομηνίας δέσμευσης.

Ένας κοινός διακόπτης που θα χρησιμοποιηθεί με την εντολή `log` σε αυτή την περίπτωση είναι` -left-right`, που μας δείχνει ποια πλευρά της εμβέλειας κάθε commit είναι.
Αυτό βοηθά τα δεδομένα να γίνουν πιο χρήσιμα:

A common switch to use with the `log` command in this case is `--left-right`, which shows you which side of the range each commit is in.
This helps make the data more useful:

[source,console]
----
$ git log --left-right master...experiment
< F
< E
> D
> C
----

Με αυτά τα εργαλεία, μπορούμε πολύ πιο εύκολα να αφήσουμε το Git να γνωρίζει τι πράττει ή αναλαμβάνει να επιθεωρήσει.

With these tools, you can much more easily let Git know what commit or commits you want to inspect.
