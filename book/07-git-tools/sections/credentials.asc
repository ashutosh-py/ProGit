[[_credential_caching]]
=== Credential Storage

(((διαπιστευτήρια)))
(((εντολές git, διαπιστευτήρια)))
Εάν χρησιμοποιούμε τη μεταφορά SSH για τη σύνδεση με τηλεχειριστήρια, είναι πιθανό να έχουμε ένα κλειδί χωρίς μια φράση πρόσβασης, η οποία μας επιτρέπει να μεταφέρουμε δεδομένα με ασφάλεια χωρίς να πληκτρολογήσουμε το όνομα χρήστη και τον κωδικό πρόσβασής μας.
Ωστόσο, αυτό δεν είναι δυνατό με τα πρωτόκολλα HTTP --κάθε σύνδεση χρειάζεται ένα όνομα χρήστη και έναν κωδικό πρόσβασης.
Αυτό γίνεται ακόμα πιο δύσκολο για συστήματα με έλεγχο ταυτότητας δύο παραγόντων, όπου το διακριτικό που χρησιμοποιούμε για έναν κωδικό πρόσβασης παράγεται τυχαία και δεν μπορεί να προωθηθεί.

(((credentials)))
(((git commands, credential)))
If you use the SSH transport for connecting to remotes, it's possible for you to have a key without a passphrase, which allows you to securely transfer data without typing in your username and password.
However, this isn't possible with the HTTP protocols – every connection needs a username and password.
This gets even harder for systems with two-factor authentication, where the token you use for a password is randomly generated and unpronounceable.

Ευτυχώς, το Git διαθέτει ένα σύστημα διαπιστευτηρίων που μπορεί να βοηθήσει σε αυτό.
Το Git διαθέτει μερικές επιλογές στο κουτί:

Fortunately, Git has a credentials system that can help with this.
Git has a few options provided in the box:

* The default is not to cache at all.
  Every connection will prompt you for your username and password.
* The ``cache'' mode keeps credentials in memory for a certain period of time.
  None of the passwords are ever stored on disk, and they are purged from the cache after 15 minutes.
* The ``store'' mode saves the credentials to a plain-text file on disk, and they never expire.
  This means that until you change your password for the Git host, you won't ever have to type in your credentials again.
  The downside of this approach is that your passwords are stored in cleartext in a plain file in your home directory.
* If you're using a Mac, Git comes with an ``osxkeychain'' mode, which caches credentials in the secure keychain that's attached to your system account.
  This method stores the credentials on disk, and they never expire, but they're encrypted with the same system that stores HTTPS certificates and Safari auto-fills.
* If you're using Windows, you can install a helper called ``winstore.''
  This is similar to the ``osxkeychain'' helper described above, but uses the Windows Credential Store to control sensitive information.
  It can be found at https://gitcredentialstore.codeplex.com[].

* Η προεπιλογή δεν είναι καθόλου κρυμμένη.
  Κάθε σύνδεση θα μας ζητήσει το όνομα χρήστη και τον κωδικό πρόσβασής μας.
* Η λειτουργία `` cache '' διατηρεί τα διαπιστευτήρια στη μνήμη για ορισμένο χρονικό διάστημα.
  Κανένας από τους κωδικούς πρόσβασης δεν αποθηκεύεται ποτέ στο δίσκο και καθαρίζονται από την προσωρινή μνήμη μετά από 15 λεπτά.
* Η λειτουργία `` store '' αποθηκεύει τα διαπιστευτήρια σε ένα αρχείο απλού κειμένου στο δίσκο και δεν λήγει ποτέ.
  Αυτό σημαίνει ότι μέχρι να αλλάξουμε τον κωδικό πρόσβασης για τον κεντρικό υπολογιστή Git, δεν θα χρειαστεί ποτέ να πληκτρολογήσουμε ξανά τα διαπιστευτήριά μας.
  Το μειονέκτημα αυτής της προσέγγισης είναι ότι οι κωδικοί πρόσβασης αποθηκεύονται σε καθαρό κείμενο σε ένα απλό αρχείο στον προσωπικό μας κατάλογο.
* Εάν χρησιμοποιούμε Mac, το Git έρχεται με μια λειτουργία `` osxkeychain '', η οποία αποθηκεύει τα διαπιστευτήρια στο ασφαλές μπρελόκ που είναι συνδεδεμένο με το λογαριασμό μας στο σύστημα.
  Αυτή η μέθοδος αποθηκεύει τα διαπιστευτήρια στο δίσκο και δεν λήγει ποτέ, αλλά είναι κρυπτογραφημένα με το ίδιο σύστημα που αποθηκεύει τα πιστοποιητικά HTTPS και το αυτόματο συμπλήρωμα του Safari.
* Εάν χρησιμοποιούμε Windows, μπορούμε να εγκαταστήσουμε έναν βοηθό που ονομάζεται `` winstore. ''
  Αυτό είναι παρόμοιο με τον βοηθό `` osxkeychain '' που περιγράφεται παραπάνω, αλλά χρησιμοποιεί το Windows Credential Store για τον έλεγχο ευαίσθητων πληροφοριών.
  Μπορεί να βρεθεί στο https://gitcredentialstore.codeplex.com [].

Μπορούμε να επιλέξουμε μία από αυτές τις μεθόδους ρυθμίζοντας μια τιμή διαμόρφωσης Git:

You can choose one of these methods by setting a Git configuration value:

[source,console]
----
$ git config --global credential.helper cache
----

Some of these helpers have options.
The ``store'' helper can take a `--file <path>` argument, which customizes where the plaintext file is saved (the default is `~/.git-credentials`).
The ``cache'' helper accepts the `--timeout <seconds>` option, which changes the amount of time its daemon is kept running (the default is ``900'', or 15 minutes).
Here's an example of how you'd configure the ``store'' helper with a custom file name:

Μερικοί από αυτούς τους βοηθούς έχουν επιλογές.
Ο βοηθός `` store '' μπορεί να πάρει ένα `--file <path>` argument, το οποίο προσαρμόζεται όπου αποθηκεύεται το αρχείο plaintext (το προεπιλεγμένο είναι τα "~ / .git-credentials").
Ο βοηθός `` cache '' δέχεται την επιλογή `--timeout <δευτερόλεπτα ', η οποία αλλάζει την ώρα που ο δαίμονας συνεχίζει να τρέχει (η προεπιλογή είναι` `900' 'ή 15 λεπτά).
Ακολουθεί ένα παράδειγμα του πώς θα ρυθμίσουμε τον βοηθό `` store '' με ένα όνομα προσαρμοσμένου αρχείου:

[source,console]
----
$ git config --global credential.helper store --file ~/.my-credentials
----

Το Git ακόμη μας επιτρέπει να ρυθμίσουμε διάφορες βοήθειες.
Όταν αναζητάμε διαπιστευτήρια για έναν συγκεκριμένο κεντρικό υπολογιστή, το Git θα τα ερωτά με σειρά και θα σταματήσει μετά την πρώτη απάντηση.
Κατά την αποθήκευση διαπιστευτηρίων, το Git θα στείλει το όνομα χρήστη και τον κωδικό πρόσβασης σε * όλους * τους βοηθούς της λίστας και μπορούν να επιλέξουν τι πρέπει να κάνουν μαζί τους.
Ακολουθεί το παράδειγμα ενός `.gitconfig` αν είχαμε ένα αρχείο διαπιστευτηρίων σε μια μονάδα αντίχειρα, αλλά ήθελε να χρησιμοποιήσει την προσωρινή μνήμη της μνήμης για να εξοικονομήσει κάποια πληκτρολόγηση εάν η μονάδα δεν είναι συνδεδεμένη:

Git even allows you to configure several helpers.
When looking for credentials for a particular host, Git will query them in order, and stop after the first answer is provided.
When saving credentials, Git will send the username and password to *all* of the helpers in the list, and they can choose what to do with them.
Here's what a `.gitconfig` would look like if you had a credentials file on a thumb drive, but wanted to use the in-memory cache to save some typing if the drive isn't plugged in:

[source,ini]
----
[credential]
    helper = store --file /mnt/thumbdrive/.git-credentials
    helper = cache --timeout 30000
----

==== Under the Hood

How does this all work?
Git's root command for the credential-helper system is `git credential`, which takes a command as an argument, and then more input through stdin.

Πώς λειτουργεί αυτό;
Η εντολή ρίζας του Git για το σύστημα βοηθητικών διαπιστευτηρίων είναι η `git credential`, η οποία παίρνει μια εντολή ως επιχείρημα, και στη συνέχεια περισσότερες εισροές μέσω του stdin.

Αυτό μπορεί να είναι ευκολότερο να κατανοηθεί με ένα παράδειγμα.
Ας υποθέσουμε ότι έχει ρυθμιστεί ένας βοηθός διαπιστευτηρίων και ο βοηθός έχει αποθηκεύσει τα διαπιστευτήρια για το "mygithost".
Ακολουθεί μια περίοδος λειτουργίας που χρησιμοποιεί την εντολή `` fill '', η οποία ενεργοποιείται όταν ο Git προσπαθεί να βρει διαπιστευτήρια για έναν κεντρικό υπολογιστή:

This might be easier to understand with an example.
Let's say that a credential helper has been configured, and the helper has stored credentials for `mygithost`.
Here's a session that uses the ``fill'' command, which is invoked when Git is trying to find credentials for a host:

[source,console]
----
$ git credential fill <1>
protocol=https <2>
host=mygithost
<3>
protocol=https <4>
host=mygithost
username=bob
password=s3cre7
$ git credential fill <5>
protocol=https
host=unknownhost

Username for 'https://unknownhost': bob
Password for 'https://bob@unknownhost':
protocol=https
host=unknownhost
username=bob
password=s3cre7
----

<1> This is the command line that initiates the interaction.
<2> Git-credential is then waiting for input on stdin.
    We provide it with the things we know: the protocol and hostname.
<3> A blank line indicates that the input is complete, and the credential system should answer with what it knows.
<4> Git-credential then takes over, and writes to stdout with the bits of information it found.
<5> If credentials are not found, Git asks the user for the username and password, and provides them back to the invoking stdout (here they're attached to the same console).

<1> Αυτή είναι η γραμμή εντολών που ενεργοποιεί την αλληλεπίδραση.
<2> Το Git-credential στη συνέχεια περιμένει την είσοδο στο stdin.
    Το παρέχουμε με τα πράγματα που γνωρίζουμε: το πρωτόκολλο και το όνομα του κεντρικού υπολογιστή.
<3> Μια κενή γραμμή υποδεικνύει ότι η είσοδος είναι πλήρης και το σύστημα διαπιστευτηρίων πρέπει να απαντά με αυτό που γνωρίζει.
<4> Το Git-credential στη συνέχεια αναλαμβάνει και γράφει στο stdout με τα κομμάτια των πληροφοριών που βρήκε.
<5> Εάν δεν εντοπιστούν τα διαπιστευτήρια, ο Git ζητάει από το χρήστη το όνομα χρήστη και τον κωδικό πρόσβασης και τα επαναφέρει στην κλήση του stdout (εδώ είναι συνδεδεμένα στην ίδια κονσόλα).

Το σύστημα διαπιστευτηρίων επικαλείται ένα πρόγραμμα που είναι ξεχωριστό από το ίδιο το Git. ποιος και πώς εξαρτάται από την τιμή διαμόρφωσης `credential.helper`.
Υπάρχουν διάφορες μορφές που μπορεί να πάρει:

The credential system is actually invoking a program that's separate from Git itself; which one and how depends on the `credential.helper` configuration value.
There are several forms it can take:

[options="header"]
|======
| Configuration Value | Behavior
| `foo` | Runs `git-credential-foo`
| `foo -a --opt=bcd` | Runs `git-credential-foo -a --opt=bcd`
| `/absolute/path/foo -xyz` | Runs `/absolute/path/foo -xyz`
| `!f() { echo "password=s3cre7"; }; f` | Code after `!` evaluated in shell
|======

So the helpers described above are actually named `git-credential-cache`, `git-credential-store`, and so on, and we can configure them to take command-line arguments.
The general form for this is ``git-credential-foo [args] <action>.''
The stdin/stdout protocol is the same as git-credential, but they use a slightly different set of actions:

Έτσι οι βοηθοί που περιγράφηκαν παραπάνω ονομάζονται πραγματικά git-credential-cache, git-credential-store και ούτω καθεξής και μπορούμε να τις ρυθμίσουμε ώστε να λάβουν επιχειρήματα γραμμής εντολών.
Η γενική μορφή για αυτό είναι `` git-credential-foo [args] <action>. ''
Το πρωτόκολλο stdin / stdout είναι το ίδιο με το git-credential, αλλά χρησιμοποιούν ένα ελαφρώς διαφορετικό σύνολο ενεργειών:

* `` get 'είναι ένα αίτημα για ένα ζεύγος ονόματος χρήστη / κωδικού πρόσβασης.
* Το 'store' είναι ένα αίτημα για να αποθηκεύσουμε ένα σύνολο διαπιστευτηρίων στη μνήμη αυτού του βοηθού.
* `delete 'καθαρίστε τα διαπιστευτήρια για τα δεδομένα properties από τη μνήμη αυτού του βοηθού.

* `get` is a request for a username/password pair.
* `store` is a request to save a set of credentials in this helper's memory.
* `erase` purge the credentials for the given properties from this helper's memory.

For the `store` and `erase` actions, no response is required (Git ignores it anyway).
For the `get` action, however, Git is very interested in what the helper has to say.
If the helper doesn't know anything useful, it can simply exit with no output, but if it does know, it should augment the provided information with the information it has stored.
The output is treated like a series of assignment statements; anything provided will replace what Git already knows.

Για τις ενέργειες `store 'και` delete', δεν απαιτείται απάντηση (το Git το αγνοεί ούτως ή άλλως).
Για τη δράση `get`, ωστόσο, ο Git ενδιαφέρεται πολύ για το τι έχει να πει ο βοηθός.
Αν ο βοηθός δεν γνωρίζει τίποτα χρήσιμο, μπορεί απλά να βγεί χωρίς έξοδο, αλλά αν το γνωρίζει, θα πρέπει να αυξήσει τις παρεχόμενες πληροφορίες με τις πληροφορίες που έχει αποθηκεύσει.
Η έξοδος αντιμετωπίζεται σαν μια σειρά δηλώσεων εκχώρησης. οτιδήποτε παρέχεται θα αντικαταστήσει αυτό που ήδη γνωρίζει ο Git.

Ακολουθεί το ίδιο παράδειγμα από πάνω, αλλά παρακάμπτοντας το git-credential και πηγαίνοντας κατ 'ευθείαν στο git-credential-store:

Here's the same example from above, but skipping git-credential and going straight for git-credential-store:

[source,console]
----
$ git credential-store --file ~/git.store store <1>
protocol=https
host=mygithost
username=bob
password=s3cre7
$ git credential-store --file ~/git.store get <2>
protocol=https
host=mygithost

username=bob <3>
password=s3cre7
----

<1> Here we tell `git-credential-store` to save some credentials: the username ``bob'' and the password ``s3cre7'' are to be used when `https://mygithost` is accessed.
<2> Now we'll retrieve those credentials.
    We provide the parts of the connection we already know (`https://mygithost`), and an empty line.
<3> `git-credential-store` replies with the username and password we stored above.

<1> Εδώ λέμε στο «git-credential-store» για να αποθηκεύσουμε κάποια διαπιστευτήρια: το username `` bob '' και ο κωδικός `` s3cre7 '' πρέπει να χρησιμοποιηθούν όταν προσπελαστεί `https: // mygithost`.
<2> Τώρα θα ανακτήσουμε αυτά τα διαπιστευτήρια.
    Παρέχουμε τα μέρη της σύνδεσης που ήδη γνωρίζουμε (`https: // mygithost`) και μια κενή γραμμή.
<3> Το 'git-credential-store' απαντά με το όνομα χρήστη και τον κωδικό πρόσβασης που αποθηκεύσαμε παραπάνω.

Ακολουθεί το παράδειγμα του αρχείου `~ / git.store`:

Here's what the `~/git.store` file looks like:

[source]
----
https://bob:s3cre7@mygithost
----

Πρόκειται μόνο για μια σειρά γραμμών, κάθε μία από τις οποίες περιέχει μια διεύθυνση URL διακοσμημένη με πιστοποιήσεις.
Οι βοηθοί `osxkeychain` και` winstore` χρησιμοποιούν την εγγενή μορφή των καταστημάτων υποστήριξης, ενώ η `cache` χρησιμοποιεί τη δική της μορφή μνήμης (η οποία δεν διαβάζει καμία άλλη διαδικασία).

It's just a series of lines, each of which contains a credential-decorated URL.
The `osxkeychain` and `winstore` helpers use the native format of their backing stores, while `cache` uses its own in-memory format (which no other process can read).

==== A Custom Credential Cache

Given that `git-credential-store` and friends are separate programs from Git, it's not much of a leap to realize that _any_ program can be a Git credential helper.
The helpers provided by Git cover many common use cases, but not all.
For example, let's say your team has some credentials that are shared with the entire team, perhaps for deployment.
These are stored in a shared directory, but you don't want to copy them to your own credential store, because they change often.
None of the existing helpers cover this case; let's see what it would take to write our own.
There are several key features this program needs to have:

Δεδομένου ότι το git-credential-store και οι φίλοι είναι ξεχωριστά προγράμματα από το Git, δεν είναι πολύ άλμα για να συνειδητοποιήσουμε ότι κάποιο πρόγραμμα μπορεί να είναι βοηθός πιστοποίησης Git.
Οι βοηθοί που παρέχονται από το Git καλύπτουν πολλές κοινές περιπτώσεις χρήσης, αλλά όχι όλες.
Για παράδειγμα, ας υποθέσουμε ότι η ομάδα μας έχει ορισμένα διαπιστευτήρια που μοιράζονται με ολόκληρη την ομάδα, ίσως για ανάπτυξη.
Αυτά αποθηκεύονται σε κοινόχρηστο κατάλογο, αλλά δεν θέλουμε να τα αντιγράψουμε στο δικό μας κατάστημα διαπιστευτηρίων, επειδή αλλάζουν συχνά.
Κανένας από τους υπάρχοντες βοηθούς δεν καλύπτει αυτήν την περίπτωση. ας δούμε τι θα χρειαζόταν για να γράψουμε το δικό μας.
Υπάρχουν πολλά βασικά χαρακτηριστικά που πρέπει να έχει αυτό το πρόγραμμα:

. Η μόνη ενέργεια που πρέπει να δώσουμε προσοχή είναι `πάρτε '? `αποθήκευση` και` διαγραφή 'είναι εγγραφές, επομένως θα βγούμε καθαρά όταν λάβουμε.
. Η μορφή αρχείου του αρχείου κοινόχρηστων διαπιστευτηρίων είναι ίδια με αυτή που χρησιμοποιείται από το `git-credential-store '.
. Η τοποθεσία αυτού του αρχείου είναι αρκετά τυπική, αλλά θα πρέπει να επιτρέψουμε στον χρήστη να περάσει μια προσαρμοσμένη διαδρομή μόνο σε περίπτωση.

. The only action we need to pay attention to is `get`; `store` and `erase` are write operations, so we'll just exit cleanly when they're received.
. The file format of the shared-credential file is the same as that used by `git-credential-store`.
. The location of that file is fairly standard, but we should allow the user to pass a custom path just in case.

Επαναλαμβάνουμε ότι θα γράψουμε αυτή την επέκταση σε Ruby, αλλά οποιαδήποτε γλώσσα θα λειτουργήσει όσο Git μπορεί να εκτελέσει το τελικό προϊόν.
Εδώ είναι ο πλήρης πηγαίος κώδικας του νέου μας βοηθού πιστοποίησης:

Once again, we'll write this extension in Ruby, but any language will work so long as Git can execute the finished product.
Here's the full source code of our new credential helper:

[source,ruby]
--------
include::../git-credential-read-only[]
--------

<1> Here we parse the command-line options, allowing the user to specify the input file. The default is `~/.git-credentials`.
<2> This program only responds if the action is `get` and the backing-store file exists.
<3> This loop reads from stdin until the first blank line is reached.
    The inputs are stored in the `known` hash for later reference.
<4> This loop reads the contents of the storage file, looking for matches.
    If the protocol and host from `known` match this line, the program prints the results to stdout and exits.

<1> Εδώ αναλύουμε τις επιλογές της γραμμής εντολών, επιτρέποντας στον χρήστη να καθορίσει το αρχείο εισόδου. Η προεπιλογή είναι "~ / .git-διαπιστευτήρια".
<2> Αυτό το πρόγραμμα ανταποκρίνεται μόνο εάν η ενέργεια είναι `get` και το αρχείο backing-store υπάρχει.
<3> Αυτός ο βρόχος διαβάζει από τον stdin μέχρι να φτάσει η πρώτη κενή γραμμή.
    Οι είσοδοι αποθηκεύονται στο γνωστό κατακερματισμό για μεταγενέστερη αναφορά.
<4> Αυτός ο βρόχος διαβάζει τα περιεχόμενα του αρχείου αποθήκευσης αναζητώντας αντιστοιχίες.
    Εάν το πρωτόκολλο και ο κεντρικός υπολογιστής από το `γνωστό 'ταιριάζουν με αυτή τη γραμμή, το πρόγραμμα εκτυπώνει τα αποτελέσματα σε stdout και έξοδο.

Θα σώσουμε τον βοηθό μας ως "git-credential-read-only", το βάζουμε κάπου στο `PATH 'και το επισημόνουμε εκτελέσιμο.
Ακολουθεί μια εμφάνιση μιας διαδραστικής περιόδου σύνδεσης:

We'll save our helper as `git-credential-read-only`, put it somewhere in our `PATH` and mark it executable.
Here's what an interactive session looks like:

[source,console]
----
$ git credential-read-only --file=/mnt/shared/creds get
protocol=https
host=mygithost

protocol=https
host=mygithost
username=bob
password=s3cre7
----

Επειδή το όνομά του ξεκινάει με ``git-'', μπορούμε να χρησιμοποιήσουμε την απλή σύνταξη για την τιμή διαμόρφωσης:

Since its name starts with ``git-'', we can use the simple syntax for the configuration value:

[source,console]
----
$ git config --global credential.helper read-only --file /mnt/shared/creds
----

Όπως μπορούμε να δούμε, η επέκταση αυτού του συστήματος είναι αρκετά απλή και μπορεί να λύσει μερικά κοινά προβλήματα για εμάς και την ομάδα μας.

As you can see, extending this system is pretty straightforward, and can solve some common problems for you and your team.
