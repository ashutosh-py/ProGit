[[_rewriting_history]]
=== Η ιστορία ξαναγράφεται History

Many times, when working with Git, you may want to revise your commit history for some reason.
One of the great things about Git is that it allows you to make decisions at the last possible moment.
You can decide what files go into which commits right before you commit with the staging area, you can decide that you didn’t mean to be working on something yet with the stash command, and you can rewrite commits that already happened so they look like they happened in a different way.
This can involve changing the order of the commits, changing messages or modifying files in a commit, squashing together or splitting apart commits, or removing commits entirely – all before you share your work with others.

Πολλές φορές, όταν εργαζόμαστε με το Git, μπορεί να θέλουμε να αναθεωρήσουμε το ιστορικό της δέσμευσής μας για κάποιο λόγο.
Ένα από τα σπουδαία πράγματα για το Git είναι ότι μας επιτρέπει να λαμβάνουμε αποφάσεις την τελευταία δυνατή στιγμή.
Μπορούμε να αποφασίσουμε ποια αρχεία πηγαίνουν στην οποία υποβάλλεται αμέσως προτού υποβάλλουμε με την περιοχή σταδιοποίησης, μπορούμε να αποφασίσουμε ότι δεν εννοούσαμε να εργαζόμαστε σε κάτι ακόμα με την εντολή stash και μπορούμε να ξαναγράψουμε υποβολές που έχουν ήδη συμβεί έτσι ώστε να μοιάζουν συνέβησαν με διαφορετικό τρόπο.
Αυτό μπορεί να συνεπάγεται την αλλαγή της σειράς των υποβολών, την αλλαγή μηνυμάτων ή την τροποποίηση των αρχείων σε μια δέσμευση, τη συμπλοκή ή τη διάσπαση των υποβολών ή την πλήρη κατάργηση των υποβολών - προτού μοιραστούμε τη δουλειά μας με άλλους.

Σε αυτήν την ενότητα, θα καλύψουμε τον τρόπο επίτευξης αυτών των πολύ χρήσιμων εργασιών, ώστε να μπορούμε να κάνουμε την ιστορία των υποβολών μας να μοιάζει με τον τρόπο που θέλουμε πριν να την μοιραστούμε με άλλους.

In this section, you’ll cover how to accomplish these very useful tasks so that you can make your commit history look the way you want before you share it with others.

[[_git_amend]]
==== Αλλαγή της τελευταίας υποβολής

Changing your last commit is probably the most common rewriting of history that you’ll do.
You’ll often want to do two basic things to your last commit: change the commit message, or change the snapshot you just recorded by adding, changing and removing files.

Η αλλαγή της τελευταίας μας δέσμευσης είναι πιθανώς η πιο συνηθισμένη επανεγγραφή ιστορικού που θα κάνουμε.
Θα θέλουμε συχνά να κάνουμε δύο βασικά πράγματα στην τελευταία μας δέσμευση: να αλλάξουμε το μήνυμα δέσμευσης ή να αλλάξουμε το στιγμιότυπο που μόλις καταγράψαμε προσθέτοντας, αλλάζοντας και αφαιρώντας αρχεία.

Αν θέλουμε να τροποποιήσουμε μόνο το τελευταίο μας μήνυμα, τα πράγματα είναι πολύ απλά:

[source,console]
----
$ git commit --amend
----

That drops you into your text editor, which has your last commit message in it, ready for you to modify the message.
When you save and close the editor, the editor writes a new commit containing that message and makes it your new last commit.

Αυτό μας μεταφέρει στον επεξεργαστή κειμένων μας, ο οποίος έχει το τελευταίο μας μήνυμα εμπλοκής σε αυτό, έτοιμο να τροποποιήσουμε το μήνυμα.
Όταν αποθηκεύουμε και κλείνουμε τον επεξεργαστή, ο συντάκτης γράφει μια νέα δέσμευση που περιέχει αυτό το μήνυμα και κάνει τη νέα μας τελευταία δέσμευση.

Αν έχουμε υποβληθεί και στη συνέχεια θέλουμε να αλλάξουμε το στιγμιότυπο που διαπράξαμε προσθέτοντας ή αλλάζοντας αρχεία, πιθανώς επειδή ξεχάσαμε να προσθέσουμε ένα νεοδημιουργημένο αρχείο όταν αρχικά υποβάλατε, η διαδικασία λειτουργεί βασικά με τον ίδιο τρόπο.
Μπορούμε να επεξεργαστούμε τις αλλαγές που θέλουμε, επεξεργάζοντας ένα αρχείο και τρέχοντας το `git add` σε αυτό ή` git rm` σε ένα κομμάτι που παρακολουθείται και το επόμενο `git commit --amend` παίρνει την τρέχουσα περιοχή σταδιοδρομίας μας και το κάνει το στιγμιότυπο για νέα δέσμευση.

If you’ve committed and then you want to change the snapshot you committed by adding or changing files, possibly because you forgot to add a newly created file when you originally committed, the process works basically the same way.
You stage the changes you want by editing a file and running `git add` on it or `git rm` to a tracked file, and the subsequent `git commit --amend` takes your current staging area and makes it the snapshot for the new commit.

Πρέπει να είμαστε προσεκτικοί με αυτήν την τεχνική επειδή η τροποποίηση τροποποιεί το SHA-1 της δέσμευσης.
Είναι σαν ένα πολύ μικρό rebase --μην τροποποιήσουμε την τελευταία μας δέσμευση εάν το έχουμε ήδη ωθήσει.

You need to be careful with this technique because amending changes the SHA-1 of the commit.
It’s like a very small rebase – don’t amend your last commit if you’ve already pushed it.

[[_changing_multiple]]
==== Αλλαγή πολλών μηνυμάτων υποβολών

To modify a commit that is farther back in your history, you must move to more complex tools.
Git doesn’t have a modify-history tool, but you can use the rebase tool to rebase a series of commits onto the HEAD they were originally based on instead of moving them to another one.
With the interactive rebase tool, you can then stop after each commit you want to modify and change the message, add files, or do whatever you wish.
You can run rebase interactively by adding the `-i` option to `git rebase`.
You must indicate how far back you want to rewrite commits by telling the command which commit to rebase onto.

Για να τροποποιήσουμε μια δέσμευση που είναι πιο πίσω στο ιστορικό μας, πρέπει να μεταβούμε σε πιο πολύπλοκα εργαλεία.
Το Git δεν διαθέτει ένα εργαλείο τροποποίησης-ιστορικού, αλλά μπορούμε να χρησιμοποιήσουμε το εργαλείο επανακαθορισμού για να επαναπροσδιορίσουμε μια σειρά υποβολών στο HEAD στο οποίο είχαν αρχικά βασιστεί αντί να τις μετακινήσουμε σε άλλο.
Με το εργαλείο interactive rebase, μπορούμε στη συνέχεια να σταματήσουμε μετά από κάθε δέσμευση που θέλουμε να τροποποιήσουμε και να αλλάξουμε το μήνυμα, να προσθέσουμε αρχεία ή να κάνουμε ό, τι επιθυμούμε.
Μπορούμε να εκτελέσουμε το rebase διαδραστικά προσθέτοντας την επιλογή `-i` στο` git rebase`.
Πρέπει να υποδείξουμε πόσο μακριά θέλουμε να ξαναγράψουμε τις υποβολές λέγοντας την εντολή που υποβάλλεται να επαναπροσδιορίσει.

Για παράδειγμα, εάν θέλουμε να αλλάξουμε τα τελευταία τρία μηνύματα δέσμευσης ή κάποιο από τα μηνύματα δέσμευσης σε αυτήν την ομάδα, παρέχουμε ως όρισμα το `git rebase -i` τον γονέα της τελευταίας δέσμευσης που θέλουμε να επεξεργαστούμε, το οποίο είναι` HEAD~2^` ή `HEAD~3`.
Μπορεί να είναι πιο εύκολο να θυμηθούμε το `~3` επειδή προσπαθούμε να επεξεργαστούμε τις τελευταίες τρεις υποβολές. αλλά να θυμάστε ότι ο ίδιος ορίζει τέσσερις δεσμούς πριν, ο γονέας της τελευταίας δέσμευσης που θέλουμε να επεξεργαστούμε:

For example, if you want to change the last three commit messages, or any of the commit messages in that group, you supply as an argument to `git rebase -i` the parent of the last commit you want to edit, which is `HEAD~2^` or `HEAD~3`.
It may be easier to remember the `~3` because you’re trying to edit the last three commits; but keep in mind that you’re actually designating four commits ago, the parent of the last commit you want to edit:

[source,console]
----
$ git rebase -i HEAD~3
----

Remember again that this is a rebasing command – every commit included in the range `HEAD~3..HEAD` will be rewritten, whether you change the message or not.
Don’t include any commit you’ve already pushed to a central server – doing so will confuse other developers by providing an alternate version of the same change.

Θυμηθούμε ξανά ότι αυτή είναι μια εντολή επανεκκίνησης --κάθε δέσμευση που περιλαμβάνεται στη σειρά `HEAD ~ 3..HEAD` θα ξαναγραφεί, είτε αλλάζουμε το μήνυμα είτε όχι.
Μην συμπεριλάβουμε οποιαδήποτε δέσμευση έχουμε ήδη σπρώξει σε κεντρικό εξυπηρετητή-- αυτό θα προκαλέσει σύγχυση σε άλλους προγραμματιστές παρέχοντας μια εναλλακτική έκδοση της ίδιας αλλαγής.

Η εκτέλεση αυτής της εντολής μάς δίνει μια λίστα υποβολών στον επεξεργαστή κειμένου μας που μοιάζει με κάτι σαν αυτό:

[source,console]
----
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

It’s important to note that these commits are listed in the opposite order than you normally see them using the `log` command.
If you run a `log`, you see something like this:

Είναι σημαντικό να σημειώσουμε ότι αυτές οι υποβολές παρατίθενται με την αντίθετη σειρά από αυτές που συνήθως βλέπουμε χρησιμοποιώντας την εντολή `log`.
Αν εκτελέσουμε ένα `log ', θα δούμε κάτι σαν αυτό:

[source,console]
----
$ git log --pretty=format:"%h %s" HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit
----

Notice the reverse order.
The interactive rebase gives you a script that it’s going to run.
It will start at the commit you specify on the command line (`HEAD~3`) and replay the changes introduced in each of these commits from top to bottom.
It lists the oldest at the top, rather than the newest, because that’s the first one it will replay.

Παρατηρήστε την αντίστροφη σειρά.
Το interactive rebase μάς δίνει ένα σενάριο που θα τρέξει.
Θα ξεκινήσει από τη δέσμευση που καθορίσαμε στη γραμμή εντολών (`HEAD ~ 3`) και θα επαναλάβει τις αλλαγές που εισήχθησαν σε κάθε μία από αυτές τις υποβολές από πάνω προς τα κάτω.
Εμφανίζει το παλαιότερο στην κορυφή, αντί για το νεότερο, επειδή είναι το πρώτο που θα επαναλάβει.

Πρέπει να επεξεργαστούμε το σενάριο έτσι ώστε να σταματήσει στη διαδικασία που θέλουμε να επεξεργαστούμε.
Για να το κάνουμε αυτό, αλλάξτε τη λέξη `pick 'στη λέξη' edit 'για κάθε μία από τις υποβολές που θέλουμε να σταματήσει η δέσμη ενεργειών.
Για παράδειγμα, για να τροποποιήσουμε μόνο το τρίτο μήνυμα δέσμευσης, αλλάζουμε το αρχείο έτσι ώστε να φαίνεται ως εξής:

You need to edit the script so that it stops at the commit you want to edit.
To do so, change the word `pick' to the word `edit' for each of the commits you want the script to stop after.
For example, to modify only the third commit message, you change the file to look like this:

[source,console]
----
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

Όταν αποθηκεύουμε και κλείνουμε τον επεξεργαστή, το Git μάς επιστρέφει πίσω στην τελευταία δέσμευση της λίστας και μας ρίχνει στη γραμμή εντολών με το ακόλουθο μήνυμα:

When you save and exit the editor, Git rewinds you back to the last commit in that list and drops you on the command line with the following message:

[source,console]
----
$ git rebase -i HEAD~3
Stopped at f7f3f6d... changed my name a bit
You can amend the commit now, with

       git commit --amend

Once you’re satisfied with your changes, run

       git rebase --continue
----

Αυτές οι οδηγίες μάς λένε ακριβώς τι να κάνουμε.
Πληκτρολογούμε:

[source,console]
----
$ git commit --amend
----

Αλλάζουμε το μήνυμα υποβολής και βγαίνουμε από τον επεξεργαστή.
Τότε τρέχουμε:

[source,console]
----
$ git rebase --continue
----

Αυτή η εντολή θα εφαρμόσει αυτόματα τις άλλες δύο υποβολές και στη συνέχεια τελειώσατε.
Εάν αλλάξουμε την επιλογή για επεξεργασία σε περισσότερες γραμμές, μπορούμε να επαναλάβουμε αυτά τα βήματα για κάθε δέσμευση που αλλάζουμε για επεξεργασία.
Κάθε φορά, ο Git θα σταματήσει, θα μας επιτρέψει να τροποποιήσουμε τη δέσμευση και να συνεχίσουμε όταν τελειώσουμε.

This command will apply the other two commits automatically, and then you’re done.
If you change pick to edit on more lines, you can repeat these steps for each commit you change to edit.
Each time, Git will stop, let you amend the commit, and continue when you’re finished.

==== Αναδιάταξη υποβολών

Μπορούμε επίσης να χρησιμοποιήσουμε διαδραστικές αναβαθμίσεις για να αναδιατάξουμε ή να αφαιρέσουμε πλήρως τις υποβολές.
Εάν θέλουμε να αφαιρέσουμε το `` add cat-file '' και να αλλάξουμε τη σειρά με την οποία εισάγονται οι άλλες δύο υποβολές, μπορούμε να αλλάξουμε το σενάριο rebase από αυτό:

You can also use interactive rebases to reorder or remove commits entirely.
If you want to remove the ``added cat-file'' commit and change the order in which the other two commits are introduced, you can change the rebase script from this

[source,console]
----
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

σε αυτό:

[source,console]
----
pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
----

Όταν αποθηκεύουμε και εξερχόμαστε από τον επεξεργαστή, το Git επιστρέφει τον κλάδο μας στο γονικό των υποβολών αυτών, εφαρμόζει `310154e` και στη συνέχεια` f7f3f6d` και στη συνέχεια σταματά.
Μπορούμε να αλλάξουμε αποτελεσματικά τη σειρά αυτών των υποβολών και να αφαιρέσουμε πλήρως το `` add cat-file ''.

When you save and exit the editor, Git rewinds your branch to the parent of these commits, applies `310154e` and then `f7f3f6d`, and then stops.
You effectively change the order of those commits and remove the ``added cat-file'' commit completely.

[[_squashing]]
==== Squashing Commits

Είναι επίσης δυνατό να πάρουμε μιας σειρά υποβολών και να τις η κατάρριψή τους σε μια ενιαία υποβολή με το εργαλείο διαδραστικής αναπροσαρμογής.
Το script παρέχει χρήσιμες οδηγίες στο μήνυμα επανατοποθέτησης:

It’s also possible to take a series of commits and squash them down into a single commit with the interactive rebasing tool.
The script puts helpful instructions in the rebase message:

[source,console]
----
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

Εάν, αντί για `` pick '' ή `` edit '', καθορίσουμε `` squash '', το Git εφαρμόζει τόσο την αλλαγή όσο και την αλλαγή απευθείας ενώπιον του και μας κάνει να συγχωνεύσουμε τα μηνύματα commit.
Επομένως, εάν θέλουμε να πραγματοποιήσουμε μια μόνο υποβολή από αυτές τις τρεις υποβολές, θα κάνουμε το σενάριο να μοιάζει με αυτό:

If, instead of ``pick'' or ``edit'', you specify ``squash'', Git applies both that change and the change directly before it and makes you merge the commit messages together.
So, if you want to make a single commit from these three commits, you make the script look like this:

[source,console]
----
pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file
----

Όταν αποθηκεύουμε και βγαίνουμε από τον επεξεργαστή, το Git εφαρμόζει και τις τρεις αλλαγές και στη συνέχεια μας επαναφέρει στον επεξεργαστή για να συγχωνεύσουμε τα τρία μηνύματα υποβολής:

[source,console]
----
# This is a combination of 3 commits.
# The first commit's message is:
changed my name a bit

# This is the 2nd commit message:

updated README formatting and added blame

# This is the 3rd commit message:

added cat-file
----

Όταν το αποθηκεύσουμε αυτό, έχουμε μία μόνο υποβολή που εισάγει τις αλλαγές και των τριών προηγούμενων υποβολών.

When you save that, you have a single commit that introduces the changes of all three previous commits.

==== Splitting a Commit

Ο διαχωρισμός μιας υποβολής αναστέλλει μια υποβολή και στη συνέχεια μερικά στάδια και υποβάλλει όσες φορές υποβάλλει με την οποία θέλουμε να καταλήξουμε.
Για παράδειγμα, ας υποθέσουμε ότι θέλουμε να χωρίσουμε τη μεσαία υποβολή των τριών υποβολών μας.
Αντί της `` ενημερωμένης μορφοποίησης README και προστιθέμενης φταίει '', θέλουμε να την χωρίσουμε σε δύο υποβολές: `` ενημερωμένη μορφοποίηση README '' για την πρώτη και `` add blame '' για τη δεύτερη.
Μπορούμε να το κάνουμε αυτό στο σενάριο `rebase -i` αλλάζοντας την εντολή για τη υποβολή που θέλουμε να χωρίσουμε στο` `edit '':

Splitting a commit undoes a commit and then partially stages and commits as many times as commits you want to end up with.
For example, suppose you want to split the middle commit of your three commits.
Instead of ``updated README formatting and added blame'', you want to split it into two commits: ``updated README formatting'' for the first, and ``added blame'' for the second.
You can do that in the `rebase -i` script by changing the instruction on the commit you want to split to ``edit'':

[source,console]
----
pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

Στη συνέχεια, όταν το σενάριο σάς βγάζει στη γραμμή εντολών, επαναφέρουμε αυτήν τη υποβολή, λάβουμε τις αλλαγές που έχουν επαναφερθεί και δημιουργήσουμε πολλαπλές υποβολές από αυτές.
Όταν αποθηκεύουμε και εξερχόμαστε από  τον επεξεργαστή, το Git επιστρέφει στον γονέα της πρώτης υποβολής στη λίστα μας, εφαρμόζει την πρώτη υποβολή (`f7f3f6d`), εφαρμόζει το δεύτερο (` 310154e`) και μας φέρνει στην κονσόλα.
Εκεί, μπορούμε να εκτελέσουμε μια μεικτή επαναφορά αυτής της υποβολής με το `git reset HEAD ^`, το οποίο ακυρώνει αποτελεσματικά αυτό το commit και αφήνει τα τροποποιημένα αρχεία unstaged.
Τώρα μπορούμε να οργανώσουμε και να υποβάλλουμε αρχεία μέχρι να έχουμε αρκετές υποβολές και τρέξτε το `git rebase --continue` όταν τελειώσετε:

Then, when the script drops you to the command line, you reset that commit, take the changes that have been reset, and create multiple commits out of them.
When you save and exit the editor, Git rewinds to the parent of the first commit in your list, applies the first commit (`f7f3f6d`), applies the second (`310154e`), and drops you to the console.
There, you can do a mixed reset of that commit with `git reset HEAD^`, which effectively undoes that commit and leaves the modified files unstaged.
Now you can stage and commit files until you have several commits, and run `git rebase --continue` when you’re done:

[source,console]
----
$ git reset HEAD^
$ git add README
$ git commit -m 'updated README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'added blame'
$ git rebase --continue
----

Το Git εφαρμόζει την τελευταία υποβολή (`a5f4a0d`) στο script και το ιστορικό μας μοιάζει με αυτό:

[source,console]
----
$ git log -4 --pretty=format:"%h %s"
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
----

Για άλλη μια φορά, αυτό αλλάζει τα SHA-1s όλων των υποβολών στη λίστα μας, οπότε βεβαιωθούμε ότι δεν εμφανίζεται καμία υποβολή σε αυτήν τη λίστα που έχουμε ήδη σπρώξει σε ένα κοινόχρηστο αποθετήριο.

Once again, this changes the SHA-1s of all the commits in your list, so make sure no commit shows up in that list that you’ve already pushed to a shared repository.

==== The Nuclear Option: filter-branch

Υπάρχει μια άλλη επιλογή επανεγγραφής ιστορικού που μπορούμε να χρησιμοποιήσουμε αν χρειάζεται να ξαναγράψουμε έναν μεγαλύτερο αριθμό υποβολών με κάποιο τρόπο με δυνατότητα γραφής --για παράδειγμα, αλλάζοντας τη διεύθυνση ηλεκτρονικού ταχυδρομείου μας σε παγκόσμιο επίπεδο ή αφαιρώντας ένα αρχείο από κάθε υποβολή.
Η εντολή είναι `filter-branch` και μπορεί να ξαναγράψει τεράστιες λεπτομέρειες της ιστορίας μας, επομένως πιθανώς να μην το χρησιμοποιήσουμε, εκτός εάν το σχέδιό μας δεν είναι ακόμη δημόσια και άλλοι άνθρωποι δεν έχουν βασίσει τις εργασίες από τις υποβολές για τις οποίες είμαστε να ξαναγράψει.
Ωστόσο, μπορεί να είναι πολύ χρήσιμο.
Θα μάθουμε μερικές από τις κοινές χρήσεις, ώστε να μπορούμε να πάρουμε μια ιδέα για κάποια από τα πράγματα που είναι σε θέση.

There is another history-rewriting option that you can use if you need to rewrite a larger number of commits in some scriptable way – for instance, changing your e-mail address globally or removing a file from every commit.
The command is `filter-branch`, and it can rewrite huge swaths of your history, so you probably shouldn’t use it unless your project isn’t yet public and other people haven’t based work off the commits you’re about to rewrite.
However, it can be very useful.
You’ll learn a few of the common uses so you can get an idea of some of the things it’s capable of.

[[_removing_file_every_commit]]
===== Αφαίρεση ενός αρχείου από κάθε υποβολή

Αυτό συμβαίνει αρκετά συχνά.
Κάποιος υποβάλλει ένα τεράστιο δυαδικό αρχείο με ένα άσκοπο `git add ', και θέλουμε να το αφαιρέσουμε παντού.
Ίσως κάναμε λάθος ένα αρχείο που περιείχε κωδικό πρόσβασης και θέλουμε να κάνουμε το έργο μας ανοιχτό.
`filter-branch` είναι το εργαλείο που θέλουμε να χρησιμοποιήσουμε για να καθαρίσουμε ολόκληρο το ιστορικό μας.
Για να καταργήσουμε ένα αρχείο που ονομάζεται passwords.txt από ολόκληρο το ιστορικό μας, μπορούμε να χρησιμοποιήσουμε την επιλογή `--tree-filter 'σε` filter-branch`:

This occurs fairly commonly.
Someone accidentally commits a huge binary file with a thoughtless `git add .`, and you want to remove it everywhere.
Perhaps you accidentally committed a file that contained a password, and you want to make your project open source.
`filter-branch` is the tool you probably want to use to scrub your entire history.
To remove a file named passwords.txt from your entire history, you can use the `--tree-filter` option to `filter-branch`:

[source,console]
----
$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref 'refs/heads/master' was rewritten
----

The `--tree-filter` option runs the specified command after each checkout of the project and then recommits the results.
In this case, you remove a file called passwords.txt from every snapshot, whether it exists or not.
If you want to remove all accidentally committed editor backup files, you can run something like `git filter-branch --tree-filter 'rm -f *~' HEAD`.

Η επιλογή `--tree-filter 'εκτελεί την εντολή που έχει οριστεί μετά από κάθε ολοκλήρωση του έργου και κατόπιν επαναφέρει τα αποτελέσματα.
Σε αυτήν την περίπτωση, καταργούμε ένα αρχείο που ονομάζεται passwords.txt από κάθε στιγμιότυπο, είτε υπάρχει είτε όχι.
Αν θέλουμε να καταργήσουμε όλα τα αρχεία backup του προγράμματος επεξεργασίας, έχουμε τη δυνατότητα να εκτελέσουμε κάτι σαν το `git filter-branch -tree-filter 'rm -f * ~' HEAD`.

Θα είμαστε σε θέση να παρακολουθήσουμε Git ξαναγράφοντας δέντρα και υποβολές και στη συνέχεια να μετακινήσουμε τον δείκτη του κλάδου στο τέλος.
Είναι γενικά μια καλή ιδέα να το κάνουμε αυτό σε έναν κλάδο δοκιμών και στη συνέχεια να επαναφέρουμε σκληρά τον κύριο κλάδο αφού έχουμε καθορίσει το αποτέλεσμα είναι αυτό που πραγματικά θέλουμε.
Για να εκτελέσουμε το `filter-branch` σε όλους τους κλάδους μας, μπορούμε να περάσετε` --all` στην εντολή.

You’ll be able to watch Git rewriting trees and commits and then move the branch pointer at the end.
It’s generally a good idea to do this in a testing branch and then hard-reset your master branch after you’ve determined the outcome is what you really want.
To run `filter-branch` on all your branches, you can pass `--all` to the command.

===== Making a Subdirectory the New Root
===== Κάνοντας έναν υποκατάλογο τη νέα ρίζα

Ας υποθέσουμε ότι έχουμε πραγματοποιήσει εισαγωγή από άλλο σύστημα ελέγχου πηγής και έχουμε υποκαταλόγους που δεν έχουν νόημα (κορμός, ετικέτες κ.ο.κ.).
Αν θέλουμε ο υποκατάλογος `trunk` να είναι ο νέος ρίζας του έργου για κάθε υποβολή, το` filter-branch` μπορεί επίσης να μας βοηθήσει:

Suppose you’ve done an import from another source control system and have subdirectories that make no sense (trunk, tags, and so on).
If you want to make the `trunk` subdirectory be the new project root for every commit, `filter-branch` can help you do that, too:

[source,console]
----
$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten
----

Τώρα, η νέα ρίζα του έργου είναι αυτή που ήταν στον υποκατάλογο `trunk` κάθε φορά.
Το Git θα καταργήσει επίσης αυτόματα υποβολές που δεν επηρέασαν τον υποκατάλογο.

Now your new project root is what was in the `trunk` subdirectory each time.
Git will also automatically remove commits that did not affect the subdirectory.

===== Changing E-Mail Addresses Globally
Αλλαγή διευθύνσεων ηλεκτρονικού ταχυδρομείου παγκοσμίως

Μια άλλη συνηθισμένη περίπτωση είναι ότι ξεχάσαμε να εκτελέσουμε το `git config` για να ορίσουμε το όνομα και τη διεύθυνση ηλεκτρονικού ταχυδρομείου πριν αρχίσουμε να εργαζόμαστε ή ίσως θέλουμε να ανοίξουμε ένα έργο στο χώρο εργασίας και να αλλάξουμε όλες τις διευθύνσεις ηλεκτρονικού ταχυδρομείου εργασίας μας προσωπική διεύθυνση.
Σε κάθε περίπτωση, μπορούμε να αλλάξουμε τις διευθύνσεις ηλεκτρονικού ταχυδρομείου σε πολλαπλές υποβολές σε μια παρτίδα με `filter-branch` επίσης.
Πρέπει να είμαστε προσεκτικοί για να αλλάξουμε μόνο τις διευθύνσεις ηλεκτρονικού ταχυδρομείου που είναι δικές μας, γι 'αυτό χρησιμοποιήστε το `--commit-filter':

Another common case is that you forgot to run `git config` to set your name and e-mail address before you started working, or perhaps you want to open-source a project at work and change all your work e-mail addresses to your personal address.
In any case, you can change e-mail addresses in multiple commits in a batch with `filter-branch` as well.
You need to be careful to change only the e-mail addresses that are yours, so you use `--commit-filter`:

[source,console]
----
$ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD
----

Αυτό περνάει και ξαναγράφει κάθε υποβολή για τη νέα μας διεύθυνση.
Επειδή οι υποβολές περιέχουν τις τιμές SHA-1 των γονέων τους, αυτή η εντολή αλλάζει κάθε commit SHA-1 στο ιστορικό μας, όχι μόνο εκείνες που έχουν την αντίστοιχη διεύθυνση ηλεκτρονικού ταχυδρομείου.

This goes through and rewrites every commit to have your new address.
Because commits contain the SHA-1 values of their parents, this command changes every commit SHA-1 in your history, not just those that have the matching e-mail address.
