[[_replace]]
=== Replace

Git's objects are unchangeable, but it does provide an interesting way to pretend to replace objects in its database with other objects.

Τα αντικείμενα του Git είναι αμετάβλητα, αλλά παρέχουν έναν ενδιαφέροντα τρόπο για να προσποιούνται ότι αντικαθιστούν αντικείμενα στη βάση δεδομένων του με άλλα αντικείμενα.

Η εντολή `replace 'σάς επιτρέπει να ορίσουμε ένα αντικείμενο στο Git και να λέτε« κάθε φορά που βλέπουμε αυτό, υποκριθούμε ότι είναι αυτό το άλλο πράγμα ».
Αυτό είναι συνήθως χρήσιμο για την αντικατάσταση μιας υποβολής στο ιστορικό μας με ένα άλλο.

The `replace` command lets you specify an object in Git and say "every time you see this, pretend it's this other thing".
This is most commonly useful for replacing one commit in your history with another one.

For example, let's say you have a huge code history and want to split your repository into one short history for new developers and one much longer and larger history for people interested in data mining.
You can graft one history onto the other by `replace`ing the earliest commit in the new line with the latest commit on the older one.
This is nice because it means that you don't actually have to rewrite every commit in the new history, as you would normally have to do to join them together (because the parentage affects the SHA-1s).

Για παράδειγμα, ας υποθέσουμε ότι έχουμε ένα τεράστιο ιστορικό κώδικα και θέλουμε να χωρίσουμε το αποθετήριό μας σε μια σύντομη ιστορία για νέους προγραμματιστές και μια πολύ μεγαλύτερη και μεγαλύτερη ιστορία για ανθρώπους που ενδιαφέρονται για την εξόρυξη δεδομένων.
Μπορούμε να μεταμοσχεύσουμε ένα ιστορικό στο άλλο με «αντικατάσταση» της πρώτης υποβολής στη νέα γραμμή με την πιο πρόσφατη αποστολή στην παλαιότερη.
Αυτό είναι ωραίο γιατί σημαίνει ότι δεν χρειάζεται να ξαναγράψουμε κάθε υποβολή στη νέα ιστορία, όπως θα έπρεπε κανονικά να κάνουμε για να τα ενώσουμε μαζί (επειδή η συγγένεια επηρεάζει τα SHA-1).

Ας το δοκιμάσουμε.
Ας πάρουμε ένα υπάρχον αποθετήριο, χωρίσαμε το σε δύο αποθετήρια, ένα πρόσφατο και ένα ιστορικό, και στη συνέχεια θα δούμε πώς μπορούμε να τα ανασυνδυάσουμε χωρίς να αλλάξουμε τις πρόσφατες τιμές αποθεμάτων SHA-1 μέσω `αντικαταστήστε '.

Let's try this out.
Let's take an existing repository, split it into two repositories, one recent and one historical, and then we'll see how we can recombine them without modifying the recent repositories SHA-1 values via `replace`.

Θα χρησιμοποιήσουμε ένα απλό αποθετήριο με πέντε απλές υποβολές:

[source,console]
----
$ git log --oneline
ef989d8 fifth commit
c6e1e95 fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit
----

Θέλουμε να το χωρίσουμε σε δύο γραμμές της ιστορίας.
Μια γραμμή πηγαίνει από τη υποβολή ενός για την υποβολή τεσσάρων --αυτό θα είναι το ιστορικό.
Η δεύτερη γραμμή θα υποβάλλει τέσσερα και πέντε-- αυτό θα είναι το πρόσφατο ιστορικό.

We want to break this up into two lines of history.
One line goes from commit one to commit four - that will be the historical one.
The second line will just be commits four and five - that will be the recent history.

image::images/replace1.png[]

Λοιπόν, η δημιουργία της ιστορικής ιστορίας είναι εύκολη, μπορούμε απλά να βάλουμε έναν κλάδο στην ιστορία και στη συνέχεια να προωθήσουμε αυτόν τον κλάδο στον κύριο κλάδο ενός νέου απομακρυσμένου αποθετηρίου.

Well, creating the historical history is easy, we can just put a branch in the history and then push that branch to the master branch of a new remote repository.

[source,console]
----
$ git branch history c6e1e95
$ git log --oneline --decorate
ef989d8 (HEAD, master) fifth commit
c6e1e95 (history) fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit
----

image::images/replace2.png[]

Τώρα μπορούμε να ωθήσουμε τον νέο κλάδο `history` στον κλάδο `master` του νέου αποθετηρίου μας:

Now we can push the new `history` branch to the `master` branch of our new repository:

[source,console]
----
$ git remote add project-history https://github.com/schacon/project-history
$ git push project-history history:master
Counting objects: 12, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (12/12), 907 bytes, done.
Total 12 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (12/12), done.
To git@github.com:schacon/project-history.git
 * [new branch]      history -> master
----

Εντάξει, έτσι το ιστορικό μας δημοσιεύεται.
Τώρα το σκληρότερο κομμάτι περικόπτει το πρόσφατο ιστορικό μας και έτσι είναι μικρότερο.
Χρειαζόμαστε μια επικάλυψη, ώστε να μπορέσουμε να αντικαταστήσουμε μια υποβολή σε μία με μια ισοδύναμη υποβολή στην άλλη, οπότε πρόκειται να το κόψουμε για να διαπράξουμε τέσσερις και πέντε (έτσι υποβάλλουμε τέσσερις αλληλεπικαλύψεις).

OK, so our history is published.
Now the harder part is truncating our recent history down so it's smaller.
We need an overlap so we can replace a commit in one with an equivalent commit in the other, so we're going to truncate this to just commits four and five (so commit four overlaps).

[source,console]
----
$ git log --oneline --decorate
ef989d8 (HEAD, master) fifth commit
c6e1e95 (history) fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit
----

It's useful in this case to create a base commit that has instructions on how to expand the history, so other developers know what to do if they hit the first commit in the truncated history and need more.
So, what we're going to do is create an initial commit object as our base point with instructions, then rebase the remaining commits (four and five) on top of it.

Είναι χρήσιμο σε αυτή την περίπτωση να δημιουργήσουμε μια υποβολή βάσης που έχει οδηγίες σχετικά με τον τρόπο επέκτασης του ιστορικού, έτσι ώστε άλλοι προγραμματιστές να γνωρίζουν τι πρέπει να κάνουν αν πετύχουν την πρώτη υποβολή στο αποκομμένο ιστορικό και χρειάζονται περισσότερα.
Λοιπόν, αυτό που πρόκειται να κάνουμε είναι να δημιουργήσουμε ένα αρχικό αντικείμενό της ως βασικό σημείο με οδηγίες και στη συνέχεια να αναδιοργανώσουμε τις υπόλοιπες υποβολές (τέσσερα και πέντε) πάνω από αυτό.

Για να γίνει αυτό, πρέπει να επιλέξουμε ένα σημείο για να χωρίσουμε, το οποίο για εμάς είναι η τρίτη υποβολή, η οποία είναι `9c68fdc` στο SHA-speak.
Έτσι, η βάση της δέσμευσής μας θα βασίζεται σε αυτό το δέντρο.
Μπορούμε να δημιουργήσουμε τη δέσμευσή μας χρησιμοποιώντας την εντολή commit-tree, η οποία παίρνει ακριβώς ένα δέντρο και θα μας δώσει ένα ολοκαίνουργιο αντικείμενό της, που δεν αντέχει στο SHA-1, πίσω.

To do that, we need to choose a point to split at, which for us is the third commit, which is `9c68fdc` in SHA-speak.
So, our base commit will be based off of that tree.
We can create our base commit using the `commit-tree` command, which just takes a tree and will give us a brand new, parentless commit object SHA-1 back.

[source,console]
----
$ echo 'get history from blah blah blah' | git commit-tree 9c68fdc^{tree}
622e88e9cbfbacfb75b5279245b9fb38dfea10cf
----

[ΣΗΜΕΙΩΣΗ]
=====
Η εντολή "commit-tree" είναι ένα από ένα σύνολο εντολών που συνήθως αναφέρονται ως εντολές ``διοχέτευσης''.
Αυτές είναι εντολές που δεν προορίζονται γενικά για άμεση χρήση, αλλά χρησιμοποιούνται από ** άλλες ** εντολές Git για να κάνουν μικρότερες εργασίες.
Σε ορισμένες περιπτώσεις, όταν κάνουμε πιο περίπλοκα πράγματα όπως αυτό, μας επιτρέπουν να κάνουμε πραγματικά πράγματα χαμηλού επιπέδου, αλλά δεν προορίζονται για καθημερινή χρήση.
Μπορούμε να διαβάσουμε περισσότερα σχετικά με τις εντολές υδραυλικών στο <<_plumbing_porcelain>>

The `commit-tree` command is one of a set of commands that are commonly referred to as 'plumbing' commands.
These are commands that are not generally meant to be used directly, but instead are used by **other** Git commands to do smaller jobs.
On occasions when we're doing weirder things like this, they allow us to do really low-level things but are not meant for daily use.
You can read more about plumbing commands in <<_plumbing_porcelain>>
=====

image::images/replace3.png[]

Εντάξει, τώρα που έχουμε μια βάση διαπραγμάτευσης, μπορούμε να αναδιοργανώσουμε το υπόλοιπο της ιστορίας μας πάνω από αυτό με το «git rebase - toto».
Το επιχείρημα `--onto` θα είναι το SHA-1 που μόλις επιστρέψαμε από το` commit-tree` και το σημείο rebase θα είναι το τρίτο commit (ο γονέας της πρώτης υποβολής που θέλουμε να κρατήσουμε, `9c68fdc`):

OK, so now that we have a base commit, we can rebase the rest of our history on top of that with `git rebase --onto`.
The `--onto` argument will be the SHA-1 we just got back from `commit-tree` and the rebase point will be the third commit (the parent of the first commit we want to keep, `9c68fdc`):

[source,console]
----
$ git rebase --onto 622e88 9c68fdc
First, rewinding head to replay your work on top of it...
Applying: fourth commit
Applying: fifth commit
----

image::images/replace4.png[]

OK, so now we've re-written our recent history on top of a throw away base commit that now has instructions in it on how to reconstitute the entire history if we wanted to.
We can push that new history to a new project and now when people clone that repository, they will only see the most recent two commits and then a base commit with instructions.

Εντάξει, οπότε τώρα έχουμε ξαναγράψει την πρόσφατη ιστορία μας πάνω από μια βάση απόρριψης που υποβάλλει ότι τώρα έχει οδηγίες σε αυτό για το πώς να ανακατασκευάσει ολόκληρη την ιστορία αν θέλαμε.
Μπορούμε να προωθήσουμε αυτή τη νέα ιστορία σε ένα νέο έργο και τώρα που οι άνθρωποι κλωνοποιούν αυτό το αποθετήριο, θα δουν μόνο τις πιο πρόσφατες δύο υποβολές και έπειτα μια βάση διαπράττει οδηγίες.

Ας αλλάξουμε τώρα τους ρόλους σε κάποιον που κλωνοποιεί το έργο για πρώτη φορά που θέλει ολόκληρο το ιστορικό.
Για να αποκτήσουμε τα δεδομένα ιστορικού μετά την κλωνοποίηση αυτού του αποκομμένου αποθετηρίου, κάποιος θα πρέπει να προσθέσει ένα δεύτερο απομακρυσμένο για το ιστορικό αποθετήριο και να φέρω:

Let's now switch roles to someone cloning the project for the first time who wants the entire history.
To get the history data after cloning this truncated repository, one would have to add a second remote for the historical repository and fetch:

[source,console]
----
$ git clone https://github.com/schacon/project
$ cd project

$ git log --oneline master
e146b5f fifth commit
81a708d fourth commit
622e88e get history from blah blah blah

$ git remote add project-history https://github.com/schacon/project-history
$ git fetch project-history
From https://github.com/schacon/project-history
 * [new branch]      master     -> project-history/master
----

Τώρα ο συνεργάτης θα έχει τις πρόσφατες υποβολές του στον κλάδο «master» και τα ιστορικά υποβάλλει στον κλάδο `project-history/master`.

Now the collaborator would have their recent commits in the `master` branch and the historical commits in the `project-history/master` branch.

[source,console]
----
$ git log --oneline master
e146b5f fifth commit
81a708d fourth commit
622e88e get history from blah blah blah

$ git log --oneline project-history/master
c6e1e95 fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit
----

Για να τα συνδυάσουμε, μπορούμε απλά να καλέσουμε το `git replace` με τη υποβολή που θέλουμε να αντικαταστήσουμε και στη συνέχεια την εντολή που θέλουμε να την αντικαταστήσουμε.
Επομένως, θέλουμε να αντικαταστήσουμε την "τέταρτη" υποβολή στον κύριο κλάδο με την "τέταρτη" υποβολή στον κλάδο `project-history / master`:

To combine them, you can simply call `git replace` with the commit you want to replace and then the commit you want to replace it with.
So we want to replace the "fourth" commit in the master branch with the "fourth" commit in the `project-history/master` branch:

[source,console]
----
$ git replace 81a708d c6e1e95
----

Αν κοιτάξουμε τώρα το ιστορικό του κλάδου `master`, φαίνεται να μοιάζει με αυτό:

[source,console]
----
$ git log --oneline master
e146b5f fifth commit
81a708d fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit
----

Καλά, σωστά; Χωρίς να χρειάζεται να αλλάξουμε όλα τα SHA-1s upstream, μπορέσαμε να αντικαταστήσουμε μια υποβολή στην ιστορία μας με μια εντελώς διαφορετική υποβολή και όλα τα κανονικά εργαλεία («bisect», «φταίει» κ.λπ.) θα δουλεύουν με τον τρόπο που θα περίμενε κανείς να .

Cool, right?  Without having to change all the SHA-1s upstream, we were able to replace one commit in our history with an entirely different commit and all the normal tools (`bisect`, `blame`, etc) will work how we would expect them to.

image::images/replace5.png[]

Είναι ενδιαφέρον ότι εξακολουθεί να εμφανίζει το στοιχείο `81a708d` ως SHA-1, παρόλο που χρησιμοποιεί πραγματικά τα` `c6e1e95` 'δεδομένα αποστολής με τα οποία το αντικαταστήσαμε.
Ακόμα και αν εκτελέσουμε μια εντολή όπως `cat-file`, θα μας δείξει τα αντικατασταθέντα δεδομένα:

Interestingly, it still shows `81a708d` as the SHA-1, even though it's actually using the `c6e1e95` commit data that we replaced it with.
Even if you run a command like `cat-file`, it will show you the replaced data:

[source,console]
----
$ git cat-file -p 81a708d
tree 7bc544cf438903b65ca9104a1e30345eee6c083d
parent 9c68fdceee073230f19ebb8b5e7fc71b479c0252
author Scott Chacon <schacon@gmail.com> 1268712581 -0700
committer Scott Chacon <schacon@gmail.com> 1268712581 -0700

fourth commit
----

Remember that the actual parent of `81a708d` was our placeholder commit (`622e88e`), not `9c68fdce` as it states here.

Ας θυμηθούμε ότι ο πραγματικός γονέας του `81a708d` ήταν ο εντοπισμός των εντολών κράτησης θέσης (`622e88e`), όχι η `9c68fdce` όπως δηλώνεται εδώ.

Κάτι ακόμα ενδιαφέρον είναι ότι αυτά τα δεδομένα διατηρούνται στις αναφορές μας:

[source,console]
----
$ git for-each-ref
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/heads/master
c6e1e95051d41771a649f3145423f8809d1a74d4 commit	refs/remotes/history/master
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/remotes/origin/HEAD
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/remotes/origin/master
c6e1e95051d41771a649f3145423f8809d1a74d4 commit	refs/replace/81a708dd0e167a3f691541c7a6463343bc457040
----

Αυτό σημαίνει ότι είναι εύκολο να μοιραστούμε την αντικατάστασή μας με άλλους, διότι μπορούμε να το προωθήσουμε στο διακομιστή μας και άλλοι άνθρωποι μπορούν εύκολα να το κατεβάσουν.
Αυτό δεν είναι τόσο χρήσιμο στο σενάριο εμβολιασμού ιστορίας που έχουμε πάει εδώ (αφού όλοι θα κατεβάζονταν και οι δύο ιστορίες ούτως ή άλλως, οπότε γιατί να τις χωρίσετε;) αλλά μπορεί να είναι χρήσιμο και σε άλλες περιπτώσεις.

This means that it's easy to share our replacement with others, because we can push this to our server and other people can easily download it.
This is not that helpful in the history grafting scenario we've gone over here (since everyone would be downloading both histories anyhow, so why separate them?) but it can be useful in other circumstances.
