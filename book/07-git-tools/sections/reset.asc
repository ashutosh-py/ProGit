[[_git_reset]]
=== Reset Demystified

Πριν προχωρήσουμε σε πιο εξειδικευμένα εργαλεία, ας μιλήσουμε για τα `reset` και `checkout`.
Αυτές οι εντολές είναι δύο από τα πιο δυσνόητα σημεία του Git όταν τα συναντά κανείς για πρώτη φορά.
Κάνουν τόσο πολλά πράγματα, που φαίνεται να μην υπάρχει καμία ελπίδα πραγματικής κατανόησης σωστής χρήσης τους.
Γι 'αυτό, συνιστούμε μια απλή μεταφορά.

For this, we recommend a simple metaphor.

==== Τα τρία δέντρα

Ένας ευκολότερος τρόπος για να σκεφτούμε τα `reset` και `checkout` είναι μέσω του πνευματικού πλαισίου του Git που είναι διαχειριστής περιεχομένου τριών διαφορετικών δέντρων.
Με το ``δέντρο'' εδώ εννοούμε ουσιαστικά ``συλλογή αρχείων'', όχι ειδικά τη δομή δεδομένων.
(Υπάρχουν μερικές περιπτώσεις στις οποίες ο δείκτης δεν λειτουργεί ακριβώς όπως ένα δέντρο, αλλά για τον σκοπό μας είναι ευκολότερο να το σκεφτούμε με αυτόν τον τρόπο προς το παρόν.)

Το Git, ως σύστημα, διαχειρίζεται και μεταχειρίζεται τρία δέντρα στην κανονική του λειτουργία:

[cols="1,2",options="header"]
|================================
| Δέντρο             | Ρόλος
| HEAD               | Στιγμιότυπο τελευταίας υποβολής, επόμενος γονέας
| Ευρετήριο          | Προτεινόμενο στιγμιότυπο για την επόμενη υποβολή
| Κατάλογος Εργασίας | Αμμοδοχείο
|================================

===== Το δέντρο HEAD

Ο HEAD είναι ο δείκτης στην αναφορά του τρέχοντος κλάδου, ο οποίος με τη σειρά του είναι ένας δείκτης στην τελευταία υποβολή που έγινε σε αυτόν τον κλάδο.
Αυτό σημαίνει ότι ο HEAD θα είναι ο γονέας της επόμενης υποβολής που δημιουργείται.
Είναι γενικά απλούστερο να σκεφτόμαστε τον HEAD ως το στιγμιότυπο *της τελευταίας μας υποβολής*.

Στην πραγματικότητα, είναι αρκετά εύκολο να δούμε με τι μοιάζει αυτό το στιγμιότυπο.
Ακολουθεί ένα παράδειγμα της πραγματικής λίστας καταλόγου και των αθροισμάτων ελέγχου SHA-1 για κάθε αρχείο στο στιγμιότυπο HEAD:

[source,console]
----
$ git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

$ git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib
----

Οι εντολές `cat-file` και `ls-tree` είναι εντολές ``διοχέτευσης'' που χρησιμοποιούνται για πράγματα χαμηλότερου επιπέδου και σπάνια  χρησιμοποιούνται στην καθημερινή εργασία μας, αλλά μας βοηθούν να δούμε τι συμβαίνει εδώ.

[[_the_index]]
===== Το Ευρετήριο

Το Ευρετήριο είναι *η προτεινόμενη επόμενη υποβολή*.
Έχουμε επίσης αναφερθεί σε αυτήν την έννοια ως ``ενδιάμεσο στάδιο'' του Git, καθώς αυτό εξετάζει το Git όταν τρέχουμε την `git commit'.

Από τεχνικής άποψης το Ευρετήριο δεν είναι δομή δέντρου --στην πραγματικότητα έχει υλοποιηθεί ως ισοπεδωμένο δηλωτικό (manifest)-- αλλά για τον σκοπό μας είναι αρκετά κοντά σε ένα δένδρο.

Το Git γεμίζει αυτό το ευρετήριο με μια λίστα των περιεχομένων όλων των τελευταίων αρχείων που έχουν γίνει check out στον κατάλογο εργασίας μας και με τι έμοιαζαν τα αρχεία όταν έγιναν checkout.
Στη συνέχεια, αντικαθιστoύμε μερικά από αυτά τα αρχεία με νέες εκδόσεις τους και εκτελούμε μία `git commit` που το μετατρέπει στο δέντρο για μια νέα υποβολή.

[source,console]
----
$ git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb
----

Και πάλι εδώ χρησιμοποιούμε την εντολή `ls-files ', η οποία είναι περισσότερο μια εντολή παρασκηνίου που μας δείχνει με τι μοιάζει το Ευρετήριο μας αυτήν τη στιγμή.

===== Ο Κατάλογος Εργασίας

Τέλος, έχουμε τον κατάλογο εργασίας μας.
Τα άλλα δύο δέντρα αποθηκεύουν το περιεχόμενό τους με έναν αποτελεσματικό αλλά καθόλου βολικό τρόπο, μέσα στον φάκελο `.git`.
Ο κατάλογος εργασίας το απλώνει σε πραγματικά αρχεία, πράγμα που καθιστά την επεξεργασία τους πολύ πιο εύκολη για μας.
Μπορούμε να σκεφτούμε τον κατάλογο εργασίας ως *αμμοδοχείο*, όπου μπορούμε να δοκιμάσουμε αλλαγές πριν να τις υποβάλλουμε στο ενδιάμεσο στάδιο (Ευρετήριο) και στη συνέχεια στο ιστορικό.

[source,console]
----
$ tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files
----

==== Η ροή εργασίας

Ο κύριος σκοπός του Git είναι να καταγράφει στιγμιότυπα του έργου μας σε διαδοχικά καλύτερες καταστάσεις, χειριζόμενο αυτά τα τρία δέντρα.

image::images/reset-workflow.png[]

Ας οπτικοποιήσουμε αυτήν τη διαδικασία: ας πούμε ότι πηγαίνουμε σε έναν νέο κατάλογο με μόνον ένα αρχείο σε αυτόν.
Θα ονομάσουμε αυτήν την έκδοση του αρχείου *v1* και θα το απεικονίζουμε με μπλε χρώμα.
Τώρα τρέχουμε την `git init`, η οποία θα δημιουργήσει ένα αποθετήριο Git με μια αναφορά HEAD που δείχνει σε έναν κλάδο που δεν υπάρχει (ο `master` δεν υπάρχει ακόμα).

image::images/reset-ex1.png[]

Σε αυτό το σημείο, μόνο το δέντρο του καταλόγου εργασίας έχει κάποιο περιεχόμενο.

Τώρα θέλουμε να υποβάλουμε αυτό το αρχείο, οπότε χρησιμοποιούμε την `git add` για να πάρουμε το περιεχόμενο που βρίσκεται στον Κατάλογο Εργασίας και να το αντιγράψουμε στο Ευρετήριο.

image::images/reset-ex2.png[]

Στη συνέχεια, τρέχουμε την `git commit`, η οποία παίρνει τα περιεχόμενα του Ευρετηρίου και τα αποθηκεύει ως μόνιμο στιγμιότυπο, δημιουργεί ένα αντικείμενο υποβολής το οποίο δείχνει σε αυτό το στιγμιότυπο και ενημερώνει τον `master` να δείχνει σε αυτήν τη υποβολή.

image::images/reset-ex3.png[]

Αν εκτελέσουμε την `git status`, δεν θα δούμε αλλαγές, αφού και τα τρία δέντρα είναι τα ίδια.

Τώρα θέλουμε να κάνουμε μια αλλαγή σε αυτό το αρχείο και να την υποβάλλουμε.
Θα επαναληφθεί η ίδια διαδικασία· πρώτα αλλάζουμε το αρχείο στον Κατάλογο Εργασίας μας.
Ας ονομάσουμε αυτην την έκδοση του αρχείου *v2* και θα την απεικονίζουμε με κόκκινο χρώμα.

Now we want to make a change to that file and commit it.
image::images/reset-ex4.png[]

Αν εκτελέσουμε την εντολή `git status` τώρα, το αρχείο θα εμφανιστεί με κόκκινο χρώμα με την ένδειξη ``Changes not staged for commit'', επειδή αυτή η εγγραφή διαφέρει μεταξύ του Ευρετηρίου και του Καταλόγου Εργασίας.
Στη συνέχεια τρέχουμε την `git add` σε αυτό για να το προσθέσουμε στο Ευρετήριο μας.

image::images/reset-ex5.png[]

Σε αυτό το σημείο, αν εκτελέσουμε την `git status` θα δούμε το αρχείο πράσινο κάτω από την ένδειξη ``Changes to be committed'' επειδή το Ευρετήριο και ο HEAD διαφέρουν --δηλαδή, η προτεινόμενη επόμενη υποβολή μας τώρα είναι διαφορετική από την τελευταία μας υποβολή.
Τέλος, τρέχουμε `git commit` για να οριστικοποιήσουμε την υποβολή.

image::images/reset-ex6.png[]

Τώρα η `git status` δεν θα μας δώσει καμία έξοδο, αφού και τα τρία δέντρα είναι τα ίδια ξανά.

Όταν μεταβαίνουμε από έναν κλάδο σε άλλον ή κλωνοποιούμε, γίνεται μία παρόμοια διαδικασία.
Όταν κάνουμε checkout έναν κλάδο, αλλάζει τον *HEAD* ώστε να δείχνει στο ref του νέου κλάδου, γεμίζει το Ευρετήριο με το στιγμιότυπο αυτής της υποβολής και στη συνέχεια αντιγράφει τα περιεχόμενα του *Ευρετηρίου* στον *Κατάλογο Εργασίας*.

==== The Role of Reset

The `reset` command makes more sense when viewed in this context.

Η εντολή `reset 'έχει μεγαλύτερη σημασία όταν προβληθεί σε αυτό το πλαίσιο.

Για τους σκοπούς αυτών των παραδειγμάτων, ας πούμε ότι τροποποιήσαμε ξανά το `file.txt` και το υποβάλαμε για τρίτη φορά.
Έτσι τώρα η ιστορία μας μοιάζει με αυτό:

For the purposes of these examples, let's say that we've modified `file.txt` again and committed it a third time.
So now our history looks like this:

image::images/reset-start.png[]

Ας περάσουμε τώρα ακριβώς τι κάνει `reset 'όταν το αποκαλούμε.
Χειρίζεται άμεσα αυτά τα τρία δέντρα με έναν απλό και προβλέψιμο τρόπο.
Κάνει μέχρι τρεις βασικές λειτουργίες.

Let's now walk through exactly what `reset` does when you call it.
It directly manipulates these three trees in a simple and predictable way.
It does up to three basic operations.

===== Βήμα 1: Move HEAD

Το πρώτο πράγμα που θα κάνουμε είναι να επαναφέρουμε αυτό που δείχνει το HEAD.
Αυτό δεν είναι το ίδιο με την αλλαγή του ίδιου του HEAD (το οποίο κάνει αυτό το "checkout"). 'reset' μετακινεί τον κλάδο που δείχνει το HEAD.
Αυτό σημαίνει ότι αν το HEAD έχει οριστεί στον κλάδο `master` (δηλ. Βρισκόμαστε στον κλάδο `master`), το `git reset 9e5e6a4` θα ξεκινήσει κάνοντας το` master` point στο `9e5e6a4`.

The first thing `reset` will do is move what HEAD points to.
This isn't the same as changing HEAD itself (which is what `checkout` does); `reset` moves the branch that HEAD is pointing to.
This means if HEAD is set to the `master` branch (i.e. you're currently on the `master` branch), running `git reset 9e5e6a4` will start by making `master` point to `9e5e6a4`.

image::images/reset-soft.png[]

No matter what form of `reset` with a commit you invoke, this is the first thing it will always try to do.
With `reset --soft`, it will simply stop there.

Ανεξάρτητα από το είδος της «επαναφοράς» με μια υποβολή που επικαλείται, αυτό είναι το πρώτο πράγμα που θα προσπαθήσει πάντα να κάνει.
Με το `reset --soft ', θα σταματήσει απλά εκεί.

Τώρα πάρτε ένα δευτερόλεπτο για να δούμε αυτό το διάγραμμα και να συνειδητοποιήσουμε τι συνέβη: ουσιαστικά ανέτρεψε την τελευταία εντολή `git commit`.
Όταν εκτελούμε το `git commit ', το Git δημιουργεί μια νέα υποβολή και μετακινεί το κλάδο που HEAD δείχνει σε αυτό.
Όταν επαναφέρουμε την επιστροφή στο HEAD ~ (το γονικό της HEAD), μετακινούμε τον κλάδο πίσω στο σημείο όπου ήταν, χωρίς να αλλάξουμε τον Ευρετήριο ή τον Κατάλογο Εργασίας.
Θα μπορούσαμε τώρα να ενημερώσουμε τον Ευρετήριο και να εκτελέσουμε ξανά το `git commit` για να ολοκληρώσουμε τι θα έκανε η `git commit --amend` (βλ. <<_git_amend>>).

Now take a second to look at that diagram and realize what happened: it essentially undid the last `git commit` command.
When you run `git commit`, Git creates a new commit and moves the branch that HEAD points to up to it.
When you `reset` back to `HEAD~` (the parent of HEAD), you are moving the branch back to where it was, without changing the Index or Working Directory.
You could now update the Index and run `git commit` again to accomplish what `git commit --amend` would have done (see <<_git_amend>>).

===== Βήμα 2: Updating the Index (`--mixed`)

Note that if you run `git status` now you'll see in green the difference between the Index and what the new HEAD is.

Λάβουμε υπόψη ότι αν εκτελέσουμε την κατάσταση `git` τώρα θα δούμε με πράσινο τη διαφορά μεταξύ του Ευρετηρίου και του τι είναι το νέο HEAD.

Το επόμενο πράγμα `reset 'θα κάνει είναι να ενημερώσει τον Δείκτη με τα περιεχόμενα του οποίου στιγμιότυπου HEAD τώρα δείχνει.

The next thing `reset` will do is to update the Index with the contents of whatever snapshot HEAD now points to.

image::images/reset-mixed.png[]

If you specify the `--mixed` option, `reset` will stop at this point.
This is also the default, so if you specify no option at all (just `git reset HEAD~` in this case), this is where the command will stop.

Εάν καθορίσουμε την επιλογή `--mixed`, το` reset 'θα σταματήσει σε αυτό το σημείο.
Αυτή είναι και η προεπιλογή, οπότε αν δεν καθορίσουμε καθόλου επιλογή (μόνο `git reset HEAD ~` σε αυτή την περίπτωση), εδώ θα σταματήσει η εντολή.

Τώρα πάρτε ακόμα ένα δευτερόλεπτο για να δούμε αυτό το διάγραμμα και να συνειδητοποιήσουμε τι συνέβη: εξακολουθεί να παραβιάζει την τελευταία μας «υποβολή», αλλά και τα πάντα.
Επιστρέψαμε πάλι πριν εκτελέσουμε όλες τις εντολές μας `git add` και` git commit`.

Now take another second to look at that diagram and realize what happened: it still undid your last `commit`, but also _unstaged_ everything.
You rolled back to before you ran all your `git add` and `git commit` commands.

===== Βήμα 3: Updating the Working Directory (`--hard`)

The third thing that `reset` will do is to make the Working Directory look like the Index.
If you use the `--hard` option, it will continue to this stage.

image::images/reset-hard.png[]

So let's think about what just happened.
You undid your last commit, the `git add` and `git commit` commands, **and** all the work you did in your working directory.

Ας αναλογιστούμε λοιπόν τι συνέβη.
Καταργήσαμε την τελευταία δέσμευσή μας, τις εντολές `git add` και` git commit` ** και ** όλη την εργασία που κάναμε στον Κατάλογο Εργασίας μας.

Είναι σημαντικό να σημειωθεί ότι αυτή η σημαία (`--hard`) είναι ο μόνος τρόπος για να γίνει η εντολή` reset 'επικίνδυνη και μια από τις ελάχιστες περιπτώσεις όπου το Git θα καταστρέψει πραγματικά δεδομένα.
Οποιαδήποτε άλλη επίκληση του `reset 'μπορεί εύκολα να αναβληθεί, αλλά η επιλογή` --hard` δεν μπορεί, αφού αντικαθιστά με βίαιο τρόπο τα αρχεία στον Κατάλογο Εργασίας.
Σε αυτή τη συγκεκριμένη περίπτωση, εξακολουθούμε να έχουμε την έκδοση * v3 * του αρχείου μας σε μια υποβολή στο Git DB, και θα μπορούσαμε να το επιστρέψουμε εξετάζοντας το `reflog` μας, αλλά αν δεν το είχαμε υποβληθεί, ο Git θα είχε ακόμα να αντικαταστήσει το αρχείο και θα ήταν ανεπανόρθωτη.

It's important to note that this flag (`--hard`) is the only way to make the `reset` command dangerous, and one of the very few cases where Git will actually destroy data.
Any other invocation of `reset` can be pretty easily undone, but the `--hard` option cannot, since it forcibly overwrites files in the Working Directory.
In this particular case, we still have the *v3* version of our file in a commit in our Git DB, and we could get it back by looking at our `reflog`, but if we had not committed it, Git still would have overwritten the file and it would be unrecoverable.

===== Ανακεφαλαίωση

Η εντολή `reset` αντικαθιστά αυτά τα τρία δέντρα με συγκεκριμένη σειρά, σταματώντας όταν τα λέτε σε:

1. Μετακινήστε τα σημεία κλάδου HEAD στο _ (σταματήστε εδώ εάν `--soft`) _
2. Κάντε τον δείκτη να μοιάζει με HEAD _ (σταματήστε εδώ εκτός αν `--hard`) _
3. Κάντε τον Κατάλογο Εργασίας να μοιάζει με τον Ευρετήριο

The `reset` command overwrites these three trees in a specific order, stopping when you tell it to:

1. Move the branch HEAD points to _(stop here if `--soft`)_
2. Make the Index look like HEAD _(stop here unless `--hard`)_
3. Make the Working Directory look like the Index

==== Reset With a Path
==== Επαναφορά με μια διαδρομή

Αυτό καλύπτει τη συμπεριφορά της «επαναφοράς» στη βασική της μορφή, αλλά μπορούμε επίσης να της προσφέρουμε ένα μονοπάτι για να ενεργήσουμε.
Αν καθορίσουμε μια διαδρομή, το `reset 'θα παραλείψει το βήμα 1 και θα περιορίσει το υπόλοιπο των ενεργειών του σε ένα συγκεκριμένο αρχείο ή σύνολο αρχείων.
Αυτό το πραγματικό είδος έχει νόημα --το HEAD είναι απλώς ένας δείκτης και δεν μπορούμε να επισημάνουμε μέρος μιας υποβολής και μέρος άλλου.
Αλλά το Ευρετήριο και ο Κατάλογος Εργασίας _μπορούν_ να ενημερώνονται εν μέρει, οπότε η επαναφορά συνεχίζεται με τα βήματα 2 και 3.

That covers the behavior of `reset` in its basic form, but you can also provide it with a path to act upon.
If you specify a path, `reset` will skip step 1, and limit the remainder of its actions to a specific file or set of files.
This actually sort of makes sense – HEAD is just a pointer, and you can't point to part of one commit and part of another.
But the Index and Working directory _can_ be partially updated, so reset proceeds with steps 2 and 3.

Επομένως, υποθέστε ότι τρέχουμε το `git reset file.txt`.
Αυτή η φόρμα (αφού δεν καθορίσατε μια δέσμευση SHA-1 ή υποκατάστημα και δεν έχουμε καθορίσει `--soft` ή` --hard`) είναι συντομογραφία για το `git reset - mixed HEAD file.txt`, το οποίο θα:

So, assume we run `git reset file.txt`.
This form (since you did not specify a commit SHA-1 or branch, and you didn't specify `--soft` or `--hard`) is shorthand for `git reset --mixed HEAD file.txt`, which will:

1. Μετακινήστε τα σημεία κλάδου HEAD στο _ (παρακάμπτονται) _
2. Κάντε τον δείκτη να μοιάζει με HEAD _ (σταματήστε εδώ) _

1. Move the branch HEAD points to _(skipped)_
2. Make the Index look like HEAD _(stop here)_

Έτσι, ουσιαστικά απλά αντιγράφει το `file.txt` από το HEAD στο ευρετήριο.

So it essentially just copies `file.txt` from HEAD to the Index.

image::images/reset-path1.png[]

Αυτό έχει το πρακτικό αποτέλεσμα της μη καταχώρησης του αρχείου.
Αν κοιτάξουμε το διάγραμμα για αυτή την εντολή και σκεφτούμε τι κάνει το «git add», είναι ακριβώς αντίθετα.

This has the practical effect of _unstaging_ the file.
If we look at the diagram for that command and think about what `git add` does, they are exact opposites.

image::images/reset-path2.png[]

This is why the output of the `git status` command suggests that you run this to unstage a file.
(See <<_unstaging>> for more on this.)

Αυτός είναι ο λόγος για τον οποίο η έξοδος της εντολής `git status` υποδηλώνει ότι εκτελούμε αυτήν την ενέργεια για να διαγράψουμε ένα αρχείο.
(Δούμε << _ unstaging >> για περισσότερα σχετικά με αυτό.)

Θα μπορούσαμε εξίσου εύκολα να μην αφήσουμε τον Git να υποθέσει ότι εννοούσαμε `` τραβήξτε τα δεδομένα από το HEAD '' καθορίζοντας μια συγκεκριμένη δέσμευση για να τραβήξουμε την έκδοση αρχείου από.
Θα τρέξαμε μόνο κάτι σαν το `git reset eb43bf file.txt`.

We could just as easily not let Git assume we meant ``pull the data from HEAD'' by specifying a specific commit to pull that file version from.
We would just run something like `git reset eb43bf file.txt`.

image::images/reset-path3.png[]

This effectively does the same thing as if we had reverted the content of the file to *v1* in the Working Directory, ran `git add` on it, then reverted it back to *v3* again (without actually going through all those steps).
If we run `git commit` now, it will record a change that reverts that file back to *v1*, even though we never actually had it in our Working Directory again.

Αυτό ουσιαστικά κάνει το ίδιο πράγμα σαν να είχαμε επανέλθει το περιεχόμενο του αρχείου στο * v1 * στον Κατάλογο Εργασίας, να τρέξουμε `git add` πάνω του και στη συνέχεια να το επαναφέρουμε ξανά στο * v3 * ξανά (χωρίς πραγματικά να περάσουμε όλα αυτά τα βήματα ).
Αν εκτελέσουμε τώρα το `git commit ', θα καταγράψει μια αλλαγή που θα επαναφέρει αυτό το αρχείο πίσω στο * v1 *, παρόλο που ποτέ δεν το είχαμε ξαναγίνει στον Working Directory.

Είναι επίσης ενδιαφέρον να σημειώσουμε ότι όπως και το `git add`, η εντολή 'reset' θα δεχτεί μια επιλογή` --patch 'για την απόκτηση περιεχομένου με βάση το hunk-by-hunk.
Επομένως, μπορούμε να επιλύσουμε επιλεκτικά ή να επαναφέρουμε περιεχόμενο.

It's also interesting to note that like `git add`, the `reset` command will accept a `--patch` option to unstage content on a hunk-by-hunk basis.
So you can selectively unstage or revert content.

==== Squashing

Ας δούμε πώς να κάνουμε κάτι ενδιαφέρον με αυτή τη νέα δύναμη - το squashing δεσμεύεται.

Let's look at how to do something interesting with this newfound power – squashing commits.

Say you have a series of commits with messages like ``oops.'', ``WIP'' and ``forgot this file''.
You can use `reset` to quickly and easily squash them into a single commit that makes you look really smart.
(<<_squashing>> shows another way to do this, but in this example it's simpler to use `reset`.)

Πούμε ότι έχουμε μια σειρά δεσμεύσεων με μηνύματα όπως `` oops. '', `` WIP '' και `` ξεχάσατε αυτό το αρχείο ''.
Μπορούμε να χρησιμοποιήσουμε το `reset 'για να τα σκουπίσουμε γρήγορα και εύκολα σε μια ενιαία δέσμευση που μας κάνει να φανούμε πραγματικά έξυπνος.
(<< _ squashing >> δείχνει έναν άλλο τρόπο για να το κάνουμε αυτό, αλλά σε αυτό το παράδειγμα είναι απλούστερο να χρησιμοποιήσουμε το 'reset'.)

Ας υποθέσουμε ότι έχουμε ένα έργο όπου το πρώτο commit έχει ένα αρχείο, το δεύτερο commit προσθέτει ένα νέο αρχείο και αλλάζει το πρώτο, και το τρίτο commit κάνει την αλλαγή του πρώτου αρχείου.
Η δεύτερη δέσμευση ήταν ένα έργο σε εξέλιξη και θέλουμε να το σκουπίσουμε.

Let's say you have a project where the first commit has one file, the second commit added a new file and changed the first, and the third commit changed the first file again.
The second commit was a work in progress and you want to squash it down.

image::images/reset-squash-r1.png[]

Μπορούμε να εκτελέσουμε την `git reset --soft HEAD~2` για να μετακινήσουμε τον κλάδο HEAD πίσω σε μια παλαιότερη υποβολή (την πρώτη υποβολή που θέλουμε να κρατήσουμε):

image::images/reset-squash-r2.png[]

Και στη συνέχεια εκτελούμε ξανά την `git commit`:

image::images/reset-squash-r3.png[]

Τώρα μπορούμε να δούμε ότι το ιστορικό που έχουμε φτάσει στο παρελθόν, το ιστορικό που θα πιέζουμε, τώρα μοιάζει να είχατε κάποιον να δεσμευτεί με το αρχείο `a.txt` v1, στη συνέχεια ένα δευτερόλεπτο που τροποποίησε και το` file-a.txt 'στο v3 και πρόσθεσε ` file-b.txt ".
Η δέσμευση με την έκδοση v2 του αρχείου δεν βρίσκεται πλέον στο ιστορικό.

Now you can see that your reachable history, the history you would push, now looks like you had one commit with `file-a.txt` v1, then a second that both modified `file-a.txt` to v3 and added `file-b.txt`.
The commit with the v2 version of the file is no longer in the history.


==== Check It Out
==== Ελέγξτε το

Τέλος, μπορούμε να αναρωτηθούμε ποια είναι η διαφορά ανάμεσα στο 'checkout' και 'reset'.
Όπως το `reset ', το` checkout` χειρίζεται τα τρία δέντρα και είναι λίγο διαφορετικό ανάλογα με το αν δίνουμε στην εντολή μια διαδρομή αρχείου ή όχι.

Finally, you may wonder what the difference between `checkout` and `reset` is.
Like `reset`, `checkout` manipulates the three trees, and it is a bit different depending on whether you give the command a file path or not.

===== Without Paths
===== Χωρίς μονοπάτια

Το τρέξιμο του git checkout [branch] `είναι αρκετά παρόμοιο με το τρέξιμο` git reset --hard [branch] `επειδή ενημερώνει και τα τρία δέντρα για να μοιάζει με το [branch], αλλά υπάρχουν δύο σημαντικές διαφορές.

Running `git checkout [branch]` is pretty similar to running `git reset --hard [branch]` in that it updates all three trees for you to look like `[branch]`, but there are two important differences.

First, unlike `reset --hard`, `checkout` is working-directory safe; it will check to make sure it's not blowing away files that have changes to them.
Actually, it's a bit smarter than that – it tries to do a trivial merge in the Working Directory, so all of the files you _haven't_ changed in  will be updated.
`reset --hard`, on the other hand, will simply replace everything across the board without checking.

Πρώτον, σε αντίθεση με το `reset --hard`, το 'checkout` είναι ασφαλές για τον Κατάλογο Εργασίας. θα ελέγξει για να βεβαιωθεί ότι δεν φυσά μακριά τα αρχεία που έχουν αλλαγές σε αυτά.
Στην πραγματικότητα, είναι λίγο πιο έξυπνο από αυτό - προσπαθεί να κάνει μια τετριμμένη συγχώνευση στον Κατάλογο Εργασίας, έτσι ώστε όλα τα αρχεία που δεν έχουμε αλλάξει να ενημερωθούν.
Το 'reset - hard`, από την άλλη πλευρά, απλώς θα αντικαταστήσει τα πάντα σε όλο το σκάφος χωρίς έλεγχο.

Η δεύτερη σημαντική διαφορά είναι ο τρόπος ενημέρωσης του HEAD.
Όπου το `reset 'θα μετακινήσει τον κλάδο που δείχνει το HEAD, το' checkout 'θα μετακινήσει το ίδιο το HEAD για να δείξει σε άλλο κλάδο.

The second important difference is how it updates HEAD.
Where `reset` will move the branch that HEAD points to, `checkout` will move HEAD itself to point to another branch.

For instance, say we have `master` and `develop` branches which point at different commits, and we're currently on `develop` (so HEAD points to it).
If we run `git reset master`, `develop` itself will now point to the same commit that `master` does.
If we instead run `git checkout master`, `develop` does not move, HEAD itself does.
HEAD will now point to `master`.

Για παράδειγμα, λέμε ότι έχουμε «κύριους» και «αναπτυσσόμενους» κλάδους που υποδηλώνουν διαφορετικές δεσμεύσεις και επί του παρόντος βρισκόμαστε σε `ανάπτυξη` (έτσι HEAD επισημαίνει σε αυτό).
Εάν εκτελέσουμε το `git reset master ', το` `ανάπτυξη' 'θα επισημάνει τώρα την ίδια δέσμευση που κάνει` master'.
Αν αντίθετα τρέξουμε το `master master checkout ', το` develop' δεν κινούμαι, το HEAD το κάνει.
Το HEAD θα δείχνει τώρα σε `master`.

Επομένως, και στις δύο περιπτώσεις κινείστε το HEAD για να υποδείξουμε το A, αλλά το πώς το κάνουμε είναι πολύ διαφορετικό.
'reset' θα μετακινήσει τα σημεία των κλάδων HEAD στο 'checkout' μετακινεί το ίδιο το HEAD.

So, in both cases we're moving HEAD to point to commit A, but _how_ we do so is very different.
`reset` will move the branch HEAD points to, `checkout` moves HEAD itself.

image::images/reset-checkout.png[]

===== With Paths
===== Με Διαδρομές

Ο άλλος τρόπος για να εκτελέσουμε το 'checkout' είναι με μια διαδρομή αρχείου, η οποία, όπως 'reset', δεν κινεί το HEAD.
Είναι ακριβώς όπως το `git reset [branch] file 'με το ότι ενημερώνει το ευρετήριο με αυτό το αρχείο σε αυτή τη δέσμευση, αλλά επίσης αντικαθιστά το αρχείο στον Κατάλογο Εργασίας.
Θα ήταν ακριβώς όπως το `git reset - hard [branch] file '(αν το` reset' θα μας άφηνε να τρέξουμε αυτό) - δεν είναι ασφαλές για τον Κατάλογο Εργασίας και δεν κινεί το HEAD.

The other way to run `checkout` is with a file path, which, like `reset`, does not move HEAD.
It is just like `git reset [branch] file` in that it updates the index with that file at that commit, but it also overwrites the file in the working directory.
It would be exactly like `git reset --hard [branch] file` (if `reset` would let you run that) – it's not working-directory safe, and it does not move HEAD.

Επίσης, όπως το `git reset` και το` git add`, το `checkout` θα δεχτεί μια επιλογή` --patch 'για να μπορούμε να επαναφέρουμε επιλεκτικά τα περιεχόμενα του αρχείου σε βάση hunk-by-hunk.

Also, like `git reset` and `git add`, `checkout` will accept a `--patch` option to allow you to selectively revert file contents on a hunk-by-hunk basis.

==== Ανακεφαλαίωση

Ας ελπίσουμε τώρα ότι καταλαβαίνουμε και αισθανόμαστε πιο άνετα με την εντολή `reset ', αλλά ίσως εξακολουθούμε να έχουμε λίγη σύγχυση σχετικά με τον τρόπο που διαφέρει από το' checkout 'και δεν θα μπορούσαμε να θυμηθούμε όλους τους κανόνες των διαφορετικών επικλήσεων.

Hopefully now you understand and feel more comfortable with the `reset` command, but are probably still a little confused about how exactly it differs from `checkout` and could not possibly remember all the rules of the different invocations.

Εδώ είναι ένα σκονάκι για το οποίο οι εντολές επηρεάζουν τα δέντρα.
Η στήλη `` HEAD '' διαβάζει `` REF '' αν αυτή η εντολή μετακινεί την αναφορά (κλάδο) στην οποία το HEAD δείχνει και `` HEAD '' αν μετακινεί το ίδιο το HEAD.
Δώστε ιδιαίτερη προσοχή στο 'WD Safe'; στήλη --αν αναφέρει * ΟΧΙ *, πάρτε ένα δευτερόλεπτο για να σκεφτούμε πριν εκτελέσουμε αυτήν την εντολή.

Here's a cheat-sheet for which commands affect which trees.
The ``HEAD'' column reads ``REF'' if that command moves the reference (branch) that HEAD points to, and ``HEAD'' if it moves HEAD itself.
Pay especial attention to the 'WD Safe?' column – if it says *NO*, take a second to think before running that command.

[options="header", cols="3,1,1,1,1"]
|================================
| | HEAD | Index | Workdir | WD Safe?
| *Commit Level* | | | |
| `reset --soft [commit]` | REF | NO | NO | YES
| `reset [commit]` | REF | YES | NO | YES
| `reset --hard [commit]` | REF | YES | YES | *NO*
| `checkout [commit]` | HEAD | YES | YES | YES
| *File Level* | | | |
| `reset (commit) [file]` | NO | YES | NO | YES
| `checkout (commit) [file]` | NO | YES | YES | *NO*
|================================
