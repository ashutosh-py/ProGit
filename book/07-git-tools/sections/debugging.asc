=== Debugging with Git

Το Git παρέχει επίσης μερικά εργαλεία για να μας βοηθήσουν να εντοπίσουμε ζητήματα στα έργα μας.
Επειδή το Git έχει σχεδιαστεί για να λειτουργεί με σχεδόν οποιοδήποτε είδος έργου, αυτά τα εργαλεία είναι αρκετά γενικά, αλλά συχνά μπορούν να μας βοηθήσουν να κυνηγήσουμε για ένα σφάλμα ή έναν ένοχο όταν τα πράγματα πάνε στραβά.

Git also provides a couple of tools to help you debug issues in your projects.
Because Git is designed to work with nearly any type of project, these tools are pretty generic, but they can often help you hunt for a bug or culprit when things go wrong.

[[_file_annotation]]
==== File Annotation

Αν εντοπίζουμε ένα σφάλμα στον κώδικα μας και θέλουμε να μάθουμε πότε εισήχθη και γιατί, ο σχολιασμός αρχείων είναι συχνά το καλύτερο εργαλείο μας.
Σας δείχνει ποιο ήταν το τελευταίο για να τροποποιήσουμε κάθε γραμμή οποιουδήποτε αρχείου.
Έτσι, εάν δούμε ότι μια μέθοδος στον κώδικα μας είναι buggy, μπορούμε να προσθέσουμε σχολιασμό στο αρχείο με `git blame 'για να δούμε πότε εκδόθηκε η τελευταία γραμμή της μεθόδου και από ποιον.
Αυτό το παράδειγμα χρησιμοποιεί την επιλογή `-L` για να περιορίσει την έξοδο στις γραμμές 12 έως 22:

If you track down a bug in your code and want to know when it was introduced and why, file annotation is often your best tool.
It shows you what commit was the last to modify each line of any file.
So, if you see that a method in your code is buggy, you can annotate the file with `git blame` to see when each line of the method was last edited and by whom.
This example uses the `-L` option to limit the output to lines 12 through 22:

[source,console]
----
$ git blame -L 12,22 simplegit.rb
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 12)  def show(tree = 'master')
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 13)   command("git show #{tree}")
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 14)  end
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 15)
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 16)  def log(tree = 'master')
79eaf55d (Scott Chacon  2008-04-06 10:15:08 -0700 17)   command("git log #{tree}")
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 18)  end
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 19)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20)  def blame(path)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 21)   command("git blame #{path}")
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22)  end
----

Notice that the first field is the partial SHA-1 of the commit that last modified that line.
The next two fields are values extracted from that commit–the author name and the authored date of that commit – so you can easily see who modified that line and when.
After that come the line number and the content of the file.
Also note the `^4832fe2` commit lines, which designate that those lines were in this file’s original commit.
That commit is when this file was first added to this project, and those lines have been unchanged since.
This is a tad confusing, because now you’ve seen at least three different ways that Git uses the `^` to modify a commit SHA-1, but that is what it means here.

Παρατηρήστε ότι το πρώτο πεδίο είναι το μερικό SHA-1 της δέσμευσης που τροποποίησε τελευταία αυτή τη γραμμή.
Τα επόμενα δύο πεδία είναι τιμές που εξάγονται από αυτήν την δέσμευση - το όνομα συγγραφέα και η ημερομηνία συντάξεως αυτής της δέσμευσης - για να μπορούμε εύκολα να δούμε ποιος τροποποίησε αυτήν τη γραμμή και πότε.
Μετά από αυτό έρχονται ο αριθμός γραμμής και το περιεχόμενο του αρχείου.
Σημειώστε επίσης τις γραμμές δέσμευσης `^ 4832fe2`, οι οποίες υποδηλώνουν ότι αυτές οι γραμμές ήταν σε αυθεντική δέσμευση αυτού του αρχείου.
Αυτή η δέσμευση είναι όταν το αρχείο αυτό προστέθηκε για πρώτη φορά σε αυτό το έργο και οι γραμμές αυτές δεν έχουν αλλάξει από τότε.
Αυτό είναι ένα θέμα που προκαλεί σύγχυση, επειδή τώρα έχουμε δει τουλάχιστον τρεις διαφορετικούς τρόπους με τους οποίους το Git χρησιμοποιεί το `^` για να τροποποιήσει ένα commit SHA-1, αλλά αυτό σημαίνει αυτό εδώ.

Ένα άλλο πολύ ωραίο θέμα για το Git είναι ότι δεν παρακολουθεί ρητά το όνομα του αρχείου.
Καταγράφει τα στιγμιότυπα και στη συνέχεια προσπαθεί να καταλάβει τι μετονομάστηκε σιωπηρά, μετά από το γεγονός.
Ένα από τα ενδιαφέροντα χαρακτηριστικά του είναι ότι μπορούμε να του ζητήσουμε να καταλάβει όλα τα είδη των κινήσεων κώδικα επίσης.
Εάν μεταβιβάσουμε το `-C` στο` git fault ', ο Git αναλύει το αρχείο που σχολιάζουμε και προσπαθεί να καταλάβει σε ποιά αποσπάσματα κώδικα μέσα του αρχικά προήλθε αν είχε αντιγραφεί από αλλού.
Για παράδειγμα, λέτε ότι refactoring ένα αρχείο που ονομάζεται `GITServerHandler.m` σε πολλά αρχεία, ένα από τα οποία είναι` GITPackUpload.m`.
Κατηγορώντας το `GITPackUpload.m` με την επιλογή` -C`, μπορούμε να δούμε πού προέρχονταν αρχικά τα τμήματα του κώδικα:

Another cool thing about Git is that it doesn’t track file renames explicitly.
It records the snapshots and then tries to figure out what was renamed implicitly, after the fact.
One of the interesting features of this is that you can ask it to figure out all sorts of code movement as well.
If you pass `-C` to `git blame`, Git analyzes the file you’re annotating and tries to figure out where snippets of code within it originally came from if they were copied from elsewhere.
For example, say you are refactoring a file named `GITServerHandler.m` into multiple files, one of which is `GITPackUpload.m`.
By blaming `GITPackUpload.m` with the `-C` option, you can see where sections of the code originally came from:

[source,console]
----
$ git blame -C -L 141,153 GITPackUpload.m
f344f58d GITServerHandler.m (Scott 2009-01-04 141)
f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromC
f344f58d GITServerHandler.m (Scott 2009-01-04 143) {
70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@"GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString *parentSha;
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit = [g
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@"GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)
56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) {
56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 [refDict setOb
56ef2caf GITServerHandler.m (Scott 2009-01-05 153)
----

Αυτό είναι πραγματικά χρήσιμο.
Κανονικά, παίρνουμε καθώς το αρχικό υποβάλλει τη δέσμευση από όπου αντιγράψαμε τον κώδικα, επειδή αυτή είναι η πρώτη φορά που αγγίξαμε αυτές τις γραμμές σε αυτό το αρχείο.
Το Git μας λέει την αρχική δέσμευση όπου γράψαμε αυτές τις γραμμές, ακόμα κι αν ήταν σε άλλο αρχείο.

This is really useful.
Normally, you get as the original commit the commit where you copied the code over, because that is the first time you touched those lines in this file.
Git tells you the original commit where you wrote those lines, even if it was in another file.

[[_binary_search]]
==== Δυαδική αναζήτηση

Annotating a file helps if you know where the issue is to begin with.
If you don’t know what is breaking, and there have been dozens or hundreds of commits since the last state where you know the code worked, you’ll likely turn to `git bisect` for help.
The `bisect` command does a binary search through your commit history to help you identify as quickly as possible which commit introduced an issue.

Ο σχολιασμός ενός αρχείου βοηθάει αν ξέρουμε πού θα αρχίσει το πρόβλημα.
Αν δεν ξέρουμε τι σπάει και υπήρξαν δεκάδες ή εκατοντάδες υποβολές από την τελευταία κατάσταση όπου γνωρίζουμε ότι ο κώδικας λειτούργησε, πιθανότατα θα στραφούμε προς το `git bisect` για βοήθεια.
Η εντολή `bisect` κάνει μια δυαδική αναζήτηση μέσω του ιστορικού των υποβολών μας για να μας βοηθήσει να εντοπίσουμε το συντομότερο δυνατό ποια είναι η δέσμευση ενός προβλήματος.

Ας υποθέσουμε ότι μόλις απήγαγα μια έκδοση του κώδικά μας σε ένα περιβάλλον παραγωγής, παίρνουμε αναφορές σφαλμάτων σχετικά με κάτι που δεν συνέβαινε στο αναπτυξιακό μας περιβάλλον και δεν μπορούμε να φανταστούμε γιατί ο κώδικας το κάνει αυτό.
Πηγαίνουμε πίσω στον κωδικό μας, και αποδεικνύεται ότι μπορούμε να αναπαραγάγουμε το ζήτημα, αλλά δεν μπορούμε να καταλάβουμε τι συμβαίνει.
Μπορούμε να διασταυρώσουμε τον κώδικα για να μάθουμε.
Αρχικά τρέχουμε το `git bisect start` για να πάρουμε τα πράγματα και στη συνέχεια χρησιμοποιούμε το` git bisect bad` για να πούμε στο σύστημα ότι η τρέχουσα δέσμευση που χρησιμοποιούμε είναι σπασμένη.
Στη συνέχεια, πρέπει να πούμε στο bisect όταν ήταν η τελευταία γνωστή καλή κατάσταση, χρησιμοποιώντας το "git bisect good [good_commit]":

Let’s say you just pushed out a release of your code to a production environment, you’re getting bug reports about something that wasn’t happening in your development environment, and you can’t imagine why the code is doing that.
You go back to your code, and it turns out you can reproduce the issue, but you can’t figure out what is going wrong.
You can bisect the code to find out.
First you run `git bisect start` to get things going, and then you use `git bisect bad` to tell the system that the current commit you’re on is broken.
Then, you must tell bisect when the last known good state was, using `git bisect good [good_commit]`:

[source,console]
----
$ git bisect start
$ git bisect bad
$ git bisect good v1.0
Bisecting: 6 revisions left to test after this
[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo
----

Το Git κατάλαβε ότι περίπου 12 υποβολές ήρθαν μεταξύ της δέσμευσης που σημειώσαμε ως της τελευταίας καλής δέσμευσης (v1.0) και της τρέχουσας κακής έκδοσης, και έβγαλε την μέση για εσάς.
Σε αυτό το σημείο, μπορούμε να εκτελέσουμε τη δοκιμή μας για να διαπιστώσουμε εάν υπάρχει το ζήτημα από την αποστολή αυτής της δέσμευσης.
Εάν συμβαίνει, τότε εισήχθη κάποια στιγμή πριν από αυτή τη μέση δέσμευση? αν δεν το κάνει, τότε το πρόβλημα εισήχθη κάποτε μετά τη μεσολάβηση.
Αποδεικνύεται ότι δεν υπάρχει θέμα εδώ και λέτε στο Git ότι δακτυλογράφοντας `git bisect good` και συνεχίζουμε το ταξίδι μας:

Git figured out that about 12 commits came between the commit you marked as the last good commit (v1.0) and the current bad version, and it checked out the middle one for you.
At this point, you can run your test to see if the issue exists as of this commit.
If it does, then it was introduced sometime before this middle commit; if it doesn’t, then the problem was introduced sometime after the middle commit.
It turns out there is no issue here, and you tell Git that by typing `git bisect good` and continue your journey:

[source,console]
----
$ git bisect good
Bisecting: 3 revisions left to test after this
[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing
----

Τώρα είστε σε μια άλλη δέσμευση, στα μισά του δρόμου μεταξύ εκείνου που μόλις δοκιμάσαμε και της κακής μας δέσμευσης.
Πραγματοποιούμε ξανά τη δοκιμή μας και διαπιστώστε ότι αυτή η δέσμευση είναι σπασμένη, ώστε να πούμε στο Git ότι με το 'git bisect bad`:

Now you’re on another commit, halfway between the one you just tested and your bad commit.
You run your test again and find that this commit is broken, so you tell Git that with `git bisect bad`:

[source,console]
----
$ git bisect bad
Bisecting: 1 revisions left to test after this
[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table
----

Αυτή η δέσμευση είναι μια χαρά, και τώρα η Git διαθέτει όλες τις πληροφορίες που χρειάζεται για να προσδιορίσει πού εισήχθη το θέμα.
Σας λέει το SHA-1 της πρώτης κακής δέσμευσης και δείξτε μερικές από τις πληροφορίες της δέσμευσης και ποια αρχεία τροποποιήθηκαν σε αυτή τη δέσμευση, ώστε να μπορούμε να καταλάβουμε τι συνέβη που μπορεί να έχει εισαγάγει αυτό το σφάλμα:

This commit is fine, and now Git has all the information it needs to determine where the issue was introduced.
It tells you the SHA-1 of the first bad commit and show some of the commit information and which files were modified in that commit so you can figure out what happened that may have introduced this bug:

[source,console]
----
$ git bisect good
b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit
commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04
Author: PJ Hyett <pjhyett@example.com>
Date:   Tue Jan 27 14:48:32 2009 -0800

    secure this thing

:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730
f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config
----

Όταν τελειώσουμε, θα πρέπει να εκτελέσουμε το `git bisect reset` για να επαναφέρουμε το HEAD στο σημείο που ήσασταν πριν ξεκινήσουμε ή θα καταλήξουμε σε μια περίεργη κατάσταση:

When you’re finished, you should run `git bisect reset` to reset your HEAD to where you were before you started, or you’ll end up in a weird state:

[source,console]
----
$ git bisect reset
----

Αυτό είναι ένα ισχυρό εργαλείο που μπορεί να μας βοηθήσει να ελέγξουμε εκατοντάδες υποβολών για ένα εισαγόμενο σφάλμα μέσα σε λίγα λεπτά.
Στην πραγματικότητα, αν έχουμε ένα σενάριο που θα βγεί από το 0 εάν το έργο είναι καλό ή μη, αν το έργο είναι κακό, μπορούμε να αυτοματοποιήσουμε πλήρως το `git bisect`.
Πρώτον, το πούμε ξανά για το εύρος της διχοτόμησης παρέχοντας τις γνωστές κακές και καλές υποβολές.
Μπορούμε να το κάνουμε αυτό με την καταχώρισή τους με την εντολή `bisect start` αν θέλουμε, αναφέροντας πρώτα τη γνωστή κακή διαπραγμάτευση και την γνωστή good commit δεύτερη:

This is a powerful tool that can help you check hundreds of commits for an introduced bug in minutes.
In fact, if you have a script that will exit 0 if the project is good or non-0 if the project is bad, you can fully automate `git bisect`.
First, you again tell it the scope of the bisect by providing the known bad and good commits.
You can do this by listing them with the `bisect start` command if you want, listing the known bad commit first and the known good commit second:

[source,console]
----
$ git bisect start HEAD v1.0
$ git bisect run test-error.sh
----

Με αυτόν τον τρόπο εκτελείται αυτόματα το `test-error.sh` σε κάθε ελεγχόμενη απόσπαση μέχρι να βρει η Git την πρώτη σπασμένη δέσμευση.
Μπορούμε επίσης να εκτελέσουμε κάτι όπως `make 'ή' make tests 'ή ό, τι έχουμε που εκτελεί αυτοματοποιημένες δοκιμές για εσάς.

Doing so automatically runs `test-error.sh` on each checked-out commit until Git finds the first broken commit.
You can also run something like `make` or `make tests` or whatever you have that runs automated tests for you.
