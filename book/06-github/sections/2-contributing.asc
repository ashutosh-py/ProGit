=== Συμβολή σε ένα έργο

Τώρα που ο λογαριασμός μας έχει ρυθμιστεί, ας δούμε κάποιες λεπτομέρειες που θα μπορούσαν να σας βοηθήσουν να συμβάλλουμε σε ένα υπάρχον έργο.

Now that our account is set up, let's walk through some details that could be useful in helping you contribute to an existing project.

==== Forking Projects

(((forking)))
If you want to contribute to an existing project to which you don’t have push access, you can ``fork'' the project.
What this means is that GitHub will make a copy of the project that is entirely yours; it lives in your user's namespace, and you can push to it.

Εάν θέλουμε να συνεισφέρουμε σε ένα υπάρχον έργο στο οποίο δεν έχουμε πρόσβαση push, μπορούμε να `` fork '' το έργο.
Αυτό σημαίνει ότι το GitHub θα κάνει ένα αντίγραφο του έργου που είναι εξ ολοκλήρου δικός σας. ζει στο χώρο ονομάτων του χρήστη και μπορούμε να τον σπρώξουμε.

[ΣΗΜΕΙΩΣΗ]
====
Ιστορικά, ο όρος "πιρούνι" ήταν κάπως αρνητικός στο πλαίσιο, που σημαίνει ότι κάποιος πήρε ένα έργο ανοιχτού κώδικα προς μια διαφορετική κατεύθυνση, δημιουργώντας μερικές φορές ένα ανταγωνιστικό έργο και χωρίζοντας τους συνεισφέροντες.
Στο GitHub, το `` fork '' είναι απλά το ίδιο έργο στο δικό σας χώρο ονομάτων, επιτρέποντάς σας να κάνουμε δημόσιες αλλαγές σε ένα έργο ως τρόπο να συμβάλλουμε πιο ανοιχτά.
====

[NOTE]
====
Historically, the term ``fork'' has been somewhat negative in context, meaning that someone took an open source project in a different direction, sometimes creating a competing project and splitting the contributors.
In GitHub, a ``fork'' is simply the same project in your own namespace, allowing you to make changes to a project publicly as a way to contribute in a more open manner.
====

This way, projects don’t have to worry about adding users as collaborators to give them push access.
People can fork a project, push to it, and contribute their changes back to the original repository by creating what's called a Pull Request, which we'll cover next.
This opens up a discussion thread with code review, and the owner and the contributor can then communicate about the change until the owner is happy with it, at which point the owner can merge it in.

Με αυτόν τον τρόπο, τα έργα δεν χρειάζεται να ανησυχούν για την προσθήκη χρηστών ως συνεργατών για να τους δώσουν ώθηση στην πρόσβαση.
Οι άνθρωποι μπορούν να διανοίξουν ένα έργο, να τον σπρώξουν και να συμβάλουν τις αλλαγές τους στην αρχική αποθήκη δημιουργώντας αυτό που ονομάζεται Αίτημα Pull, το οποίο θα καλύψουμε στη συνέχεια.
Αυτό ανοίγει ένα νήμα συζήτησης με αναθεώρηση κώδικα και ο ιδιοκτήτης και ο συνεισφέρων μπορούν στη συνέχεια να επικοινωνήσουν σχετικά με την αλλαγή μέχρι ο ιδιοκτήτης να είναι ευχαριστημένος με αυτό, οπότε ο ιδιοκτήτης μπορεί να τα συγχωνεύσει.

Για να περάσουμε ένα έργο, επισκεφθούμε τη σελίδα του έργου και κάντε κλικ στο πλήκτρο `` Fork '' στο επάνω δεξιό μέρος της σελίδας.

To fork a project, visit the project page and click the ``Fork'' button at the top-right of the page.

.Το κουμπί ``Fork''.
image::images/forkbutton.png[Το κουμπί ``Fork''.]

Μετά από λίγα δευτερόλεπτα, θα μεταφερθούμε στη νέα σελίδα του έργου σας, με το δικό σας αντίγραφο του κώδικα που μπορούμε να εγγράψουμε.

After a few seconds, you'll be taken to your new project page, with your own writeable copy of the code.


[[_github_flow]]
==== The GitHub Flow

(((GitHub, Flow)))
GitHub is designed around a particular collaboration workflow, centered on Pull Requests.
This flow works whether you're collaborating with a tightly-knit team in a single shared repository, or a globally-distributed company or network of strangers contributing to a project through dozens of forks.
It is centered on the <<_topic_branch>> workflow covered  in <<_git_branching>>.

Το GitHub σχεδιάζεται γύρω από μια συγκεκριμένη ροή εργασίας συνεργασίας, με επίκεντρο τα Pull Requests.
Αυτή η ροή λειτουργεί ούμε συνεργάζεστε με μια στενά συνδεδεμένη ομάδα σε ένα κοινό χώρο αποθεματοποίησης ούμε μια παγκόσμια κατανεμημένη εταιρεία ή δίκτυο ξένων που συμβάλλουν σε ένα έργο μέσω δεκάδων διχάλων.
Βασίζεται στη ροή εργασιών <<_topic_branch>> που καλύπτεται στο <<_git_branching>>.

Δούμε πώς λειτουργεί γενικά:

Here's how it generally works:

1. Create a topic branch from `master`.
2. Make some commits to improve the project.
3. Push this branch to your GitHub project.
4. Open a Pull Request on GitHub.
5. Discuss, and optionally continue committing.
6. The project owner merges or closes the Pull Request.

1. Δημιουργήστε ένα κλάδο θέματος από το "master".
2. Κάντε ορισμένες δεσμεύσεις για τη βελτίωση του έργου.
3. Πιέστε αυτό το υποκατάστημα στο έργο GitHub.
4. Ανοίξτε μια αίτηση τράβηγμα στο GitHub.
5. Συζητήστε και, προαιρετικά, συνεχίστε τη δέσμευση.
6. Ο ιδιοκτήτης του έργου συγχωνεύει ή κλείνει το αίτημα εξαναγκασμού.

Αυτό είναι βασικά η ροή εργασιών Integration Manager που καλύπτεται στο <<_integration_manager>>, αλλά αντί να χρησιμοποιήσουμε το ηλεκτρονικό ταχυδρομείο για να επικοινωνήσουμε και να αναθεωρήσουμε τις αλλαγές, οι ομάδες χρησιμοποιούν τα εργαλεία που βασίζονται στο web του GitHub.

This is basically the Integration Manager workflow covered in <<_integration_manager>>, but instead of using email to communicate and review changes, teams use GitHub's web based tools.

Ας δούμε ένα παράδειγμα της πρότασης αλλαγής σε ένα έργο ανοιχτού κώδικα που φιλοξενείται στο GitHub χρησιμοποιώντας αυτή τη ροή.

Let's walk through an example of proposing a change to an open source project hosted on GitHub using this flow.

===== Creating a Pull Request

Ο Tony ψάχνει κώδικα για να τρέξει στον προγραμματιζόμενο μικροελεγκτή του Arduino και βρήκε ένα μεγάλο αρχείο προγράμματος στο GitHub στη διεύθυνση https://github.com/schacon/blink [].

Tony is looking for code to run on his Arduino programmable microcontroller and has found a great program file on GitHub at https://github.com/schacon/blink[].

.Το έργο στο οποίο θέλουμε να συμβάλουμε.
image::images/blink-01-start.png[Το έργο στο οποίο θέλουμε να συμβάλουμε.]

Το μόνο πρόβλημα είναι ότι ο ρυθμός αναλαμπής είναι πολύ γρήγορος, πιστεύουμε ότι είναι πολύ καλύτερο να περιμένουμε 3 δευτερόλεπτα αντί για 1 μεταξύ κάθε αλλαγής κατάστασης.
Ας βελτιώσουμε λοιπόν το πρόγραμμα και το υποβάλαμε στο σχέδιο ως μια προτεινόμενη αλλαγή.

The only problem is that the blinking rate is too fast, we think it's much nicer to wait 3 seconds instead of 1 in between each state change.
So let's improve the program and submit it back to the project as a proposed change.

Πρώτον, κάνουμε κλικ στο κουμπί 'Πιρούνι', όπως αναφέρθηκε προηγουμένως, για να λάβουμε το δικό μας αντίγραφο του έργου.
Το όνομα χρήστη εδώ είναι `` tonychacon '', ώστε το αντίγραφο αυτού του έργου να είναι `https: // github.com / tonychacon / blink` και εκεί μπορούμε να το επεξεργαστούμε.
Θα το κλωνοποιήσουμε τοπικά, θα δημιουργήσουμε ένα υποκατάστημα θέματος, θα αλλάξουμε τον κώδικα και τέλος θα ωθήσουμε αυτή την αλλαγή πίσω στο GitHub.

First, we click the 'Fork' button as mentioned earlier to get our own copy of the project.
Our user name here is ``tonychacon'' so our copy of this project is at `https://github.com/tonychacon/blink` and that's where we can edit it.
We will clone it locally, create a topic branch, make the code change and finally push that change back up to GitHub.

[source,console]
----
$ git clone https://github.com/tonychacon/blink <1>
Cloning into 'blink'...

$ cd blink
$ git checkout -b slow-blink <2>
Switched to a new branch 'slow-blink'

$ sed -i '' 's/1000/3000/' blink.ino <3>

$ git diff --word-diff <4>
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
}

$ git commit -a -m 'three seconds is better' <5>
[slow-blink 5ca509d] three seconds is better
 1 file changed, 2 insertions(+), 2 deletions(-)

$ git push origin slow-blink <6>
Username for 'https://github.com': tonychacon
Password for 'https://tonychacon@github.com':
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
 * [new branch]      slow-blink -> slow-blink
----

<1> Clone our fork of the project locally
<2> Create a descriptive topic branch
<3> Make our change to the code
<4> Check that the change is good
<5> Commit our change to the topic branch
<6> Push our new topic branch back up to our GitHub fork

<1> Κλωνοποιήστε το πιρούνι του έργου σε τοπικό επίπεδο
<2> Δημιουργήστε ένα κλάδο περιγραφικού θέματος
<3> Κάνουμε την αλλαγή στον κώδικα
<4> Ελέγξτε ότι η αλλαγή είναι καλή
<5> Επαναλάβουμε την αλλαγή στο υποκατάστημα θεμάτων
<6> Πιέστε το υποκατάστημα του νέου μας θέματος πίσω στη διακλάδωση GitHub

Τώρα, αν επιστρέψουμε στο πηρούνι μας στο GitHub, μπορούμε να δούμε ότι ο GitHub παρατήρησε ότι προωθήσαμε ένα νέο θέμα και δημιουργήσαμε ένα μεγάλο πράσινο κουμπί για να ελέγξουμε τις αλλαγές μας και να ανοίξουμε ένα Pull Request στο αρχικό έργο.

Now if we go back to our fork on GitHub, we can see that GitHub noticed that we pushed a new topic branch up and present us with a big green button to check out our changes and open a Pull Request to the original project.

Μπορούμε εναλλακτικά να μεταβούμε στη σελίδα `` Υποκαταστήματα '' στη διεύθυνση https://github.com/ <user> / <project> / branches »για να εντοπίσουμε το υποκατάστημά σας και να ανοίξουμε μια νέα αίτηση απόκτησης από εκεί.

You can alternatively go to the ``Branches'' page at `https://github.com/<user>/<project>/branches` to locate your branch and open a new Pull Request from there.

.Κουμπί ``Pull Request''
image::images/blink-02-pr.png[Κουμπί ``Pull Request''.]

(((GitHub, pull requests)))
If we click that green button, we'll see a screen that allows us to create a title and description for the change we would like to request so the project owner has a good reason to consider it. It is generally a good idea to spend some effort making this description as useful as possible so the author knows why this is being suggested and why it would be a valuable change for them to accept.

Αν κάνουμε κλικ σε αυτό το πράσινο κουμπί, θα δούμε μια οθόνη που θα μας επιτρέψει να δημιουργήσουμε έναν τίτλο και μια περιγραφή για την αλλαγή που θα θέλαμε να ζητήσουμε, ώστε ο ιδιοκτήτης του έργου να έχει καλό λόγο να το εξετάσει. Είναι γενικά καλή ιδέα να ξοδέψουμε κάποια προσπάθεια καθιστώντας αυτή την περιγραφή όσο το δυνατόν πιο χρήσιμη, ώστε ο συντάκτης να γνωρίζει γιατί αυτό προτείνεται και γιατί θα ήταν μια πολύτιμη αλλαγή για να δεχτεί.

Επίσης, βλέπουμε μια λίστα των δεσμεύσεων στο κλάδο των θέσεών μας που είναι `` μπροστά '' του κλάδου `master` (στην περίπτωση αυτή, μόνο) και μια ενοποιημένη διαφορά όλων των αλλαγών που θα γίνουν σε περίπτωση που αυτό το τμήμα πάρει συγχωνεύονται από τον ιδιοκτήτη του έργου.

We also see a list of the commits in our topic branch that are ``ahead'' of the `master` branch (in this case, just the one) and a unified diff of all the changes that will be made should this branch get merged by the project owner.

.Σελίδα δημιουργίας αιτήματος τραβήγματος
image::images/blink-03-pull-request-open.png[Σελίδα δημιουργίας αιτήματος τραβήγματος.]

Όταν πατήσουμε το κουμπί "Δημιουργία αιτήματος έλξης" σε αυτήν την οθόνη, ο κάτοχος του έργου που έχουμε διώξει θα λάβει ειδοποίηση ότι κάποιος προτείνει μια αλλαγή και θα συνδεθεί με μια σελίδα που περιέχει όλες αυτές τις πληροφορίες.

When you hit the 'Create pull request' button on this screen, the owner of the project you forked will get a notification that someone is suggesting a change and will link to a page that has all of this information on it.

[ΣΗΜΕΙΩΣΗ]
====
Παρόλο που τα Pull Requests χρησιμοποιούνται συνήθως για δημόσια έργα όπως αυτό όταν ο συνεισφέρων έχει μια πλήρη αλλαγή έτοιμη να γίνει, είναι επίσης συχνά χρησιμοποιείται σε εσωτερικά έργα _at αρχή_ του κύκλου ανάπτυξης. Επειδή μπορούμε να συνεχίσουμε να πιέζουμε στο κλάδο των θεμάτων ακόμα και μετά από το άνοιγμα του Pull Request, αυτό συχνά ανοίγει νωρίς και χρησιμοποιείται ως ένας τρόπος για να επαναλάβουμε την εργασία ως ομάδα μέσα σε ένα πλαίσιο, αντί να ανοίξουμε στο τέλος της διαδικασίας.
====
[NOTE]
====
Though Pull Requests are used commonly for public projects like this when the contributor has a complete change ready to be made, it's also often used in internal projects _at the beginning_ of the development cycle. Since you can keep pushing to the topic branch even *after* the Pull Request is opened, it's often opened early and used as a way to iterate on work as a team within a context, rather than opened at the very end of the process.
====

===== Iterating on a Pull Request

At this point, the project owner can look at the suggested change and merge it, reject it or comment on it. Let's say that he likes the idea, but would prefer a slightly longer time for the light to be off than on.

Σε αυτό το σημείο, ο ιδιοκτήτης του έργου μπορεί να εξετάσει την προτεινόμενη αλλαγή και να την συγχωνεύσει, να την απορρίψει ή να την σχολιάσει. Ας πούμε ότι του αρέσει η ιδέα, αλλά θα προτιμούσε λίγο μεγαλύτερο χρόνο για το φως να είναι εκτός από το.

Όπου αυτή η συζήτηση μπορεί να πραγματοποιηθεί μέσω ηλεκτρονικού ταχυδρομείου στις ροές εργασιών που παρουσιάζονται στο <<_distributed_git>>, στο GitHub αυτό συμβαίνει στο διαδίκτυο. Ο κάτοχος του έργου μπορεί να ελέγξει την ενοποιημένη διαφορά και να αφήσει ένα σχόλιο κάνοντας κλικ σε οποιαδήποτε από τις γραμμές.

Where this conversation may take place over email in the workflows presented in <<_distributed_git>>, on GitHub this happens online. The project owner can review the unified diff and leave a comment by clicking on any of the lines.

.Comment on a specific line of code in a Pull Request
image::images/blink-04-pr-comment.png[PR line comment]

Μόλις ο διαχειριστής κάνει αυτό το σχόλιο, ο χρήστης που άνοιξε το Pull Request (και όντως οποιοσδήποτε άλλος παρακολουθεί τον αποθετήριο) θα λάβει μια ειδοποίηση. Θα ξεκινήσουμε να προσαρμόζουμε αυτό αργότερα, αλλά εάν είχε ενεργοποιημένες τις ειδοποιήσεις μέσω ηλεκτρονικού ταχυδρομείου, ο Tony θα έλαβε ένα μήνυμα όπως αυτό:

Once the maintainer makes this comment, the person who opened the Pull Request (and indeed, anyone else watching the repository) will get a notification. We'll go over customizing this later, but if he had email notifications turned on, Tony would get an email like this:

[[_email_notification]]
.Comments sent as email notifications
image::images/blink-04-email.png[Email notification]

Οποιοσδήποτε μπορεί επίσης να αφήσει γενικά σχόλια για το Pull Request. Στο <<_pr_discussion>> μπορούμε να δούμε ένα παράδειγμα του ιδιοκτήτη του έργου που σχολιάζει μια γραμμή κώδικα και στη συνέχεια αφήνει ένα γενικό σχόλιο στο τμήμα συζήτησης. Μπορούμε να δούμε ότι τα σχόλια του κώδικα συμπεριλαμβάνονται και στη συνομιλία.

Anyone can also leave general comments on the Pull Request. In <<_pr_discussion>> we can see an example of the project owner both commenting on a line of code and then leaving a general comment in the discussion section. You can see that the code comments are brought into the conversation as well.

[[_pr_discussion]]
.Pull Request discussion page
image::images/blink-05-general-comment.png[PR discussion page]

Now the contributor can see what they need to do in order to get their change accepted. Luckily this is also a very simple thing to do. Where over email you may have to re-roll your series and resubmit it to the mailing list, with GitHub you simply commit to the topic branch again and push.

Τώρα ο συνεισφέρων μπορεί να δει τι πρέπει να κάνουν για να γίνει αποδεκτή η αλλαγή τους. Ευτυχώς αυτό είναι επίσης ένα πολύ απλό πράγμα που πρέπει να κάνουμε. Όπου μέσω ηλεκτρονικού ταχυδρομείου ίσως χρειαστεί να επαναλάβουμε τη σειρά σας και να την υποβάλουμε εκ νέου στη λίστα αλληλογραφίας, με το GitHub απλά δεσμεύεστε στο κλάδο του θέματος ξανά και πιέζουμε.

Αν ο συνεισφέρων κάνει αυτό, τότε ο κάτοχος του έργου θα ενημερωθεί ξανά και όταν θα επισκεφθεί τη σελίδα θα δει ότι έχει αντιμετωπιστεί. Στην πραγματικότητα, από τη στιγμή που μια γραμμή κώδικα άλλαξε και είχε ένα σχόλιο σε αυτό, το GitHub παρατηρεί ότι και καταρρέει την ξεπερασμένη διαφορά.

If the contributor does that then the project owner will get notified again and when they visit the page they will see that it's been addressed. In fact, since a line of code changed that had a comment on it, GitHub notices that and collapses the outdated diff.

[[_pr_final]]
.Pull Request final
image::images/blink-06-final.png[PR final]

An interesting thing to notice is that if you click on the ``Files Changed'' tab on this Pull Request, you'll get the ``unified'' diff -- that is, the total aggregate difference that would be introduced to your main branch if this topic branch was merged in. In `git diff` terms, it basically automatically shows you `git diff master...<branch>` for the branch this Pull Request is based on. See <<_what_is_introduced>> for more about this type of diff.

Ένα ενδιαφέρον πράγμα που πρέπει να παρατηρήσουμε είναι ότι αν κάνουμε κλικ στην καρτέλα `` Files Changed '' σε αυτή την Pull Request, θα πάρουμε την `` unified '' diff - δηλαδή, τη συνολική συνολική διαφορά που θα εισάγεται στην κύριο υποκατάστημα αν αυτό το κλάδο θέμα συγχωνεύθηκε. Στους όρους `git diff`, βασικά αυτόματα σας δείχνει` git diff master ... <branch> `για το υποκατάστημα στο οποίο βασίζεται αυτό το Request Pull. Δούμε την ενότητα << _εμφανίζεται>> για περισσότερες πληροφορίες σχετικά με αυτό το είδος διαφοράς.

Το άλλο πράγμα που θα παρατηρήσουμε είναι ότι το GitHub ελέγχει εάν το Pull Request συγχωνεύεται καθαρά και παρέχει ένα κουμπί για να κάνει τη συγχώνευση για εσάς στο διακομιστή. Αυτό το κουμπί εμφανίζεται μόνο αν έχουμε πρόσβαση εγγραφής στο χώρο αποθήκευσης και είναι δυνατή μια τετριμμένη συγχώνευση. Εάν κάνουμε κλικ σε αυτό, το GitHub θα εκτελέσει μια συγχώνευση `` non-fast forward '', πράγμα που σημαίνει ότι ακόμα και αν η συγχώνευση * θα μπορούσε να είναι γρήγορη κίνηση προς τα εμπρός, θα δημιουργήσει ακόμα μια δέσμευση συγχώνευσης.

The other thing you'll notice is that GitHub checks to see if the Pull Request merges cleanly and provides a button to do the merge for you on the server. This button only shows up if you have write access to the repository and a trivial merge is possible. If you click it GitHub will perform a ``non-fast-forward'' merge, meaning that even if the merge *could* be a fast-forward, it will still create a merge commit.

If you would prefer, you can simply pull the branch down and merge it locally. If you merge this branch into the `master` branch and push it to GitHub, the Pull Request will automatically be closed.

Αν προτιμάτε, μπορούμε απλά να τραβήξουμε το υποκατάστημα προς τα κάτω και να το συγχωνεύσουμε τοπικά. Εάν συγχωνεύσουμε αυτόν τον κλάδο στον κλάδο `master` και τον σπρώξουμε στο GitHub, το Pull Request θα κλείσει αυτόματα.

Αυτή είναι η βασική ροή εργασίας που χρησιμοποιούν τα περισσότερα έργα του GitHub. Οι κλάδοι θεμάτων δημιουργούνται, ανοίγουν οι Αίτημα Ανάκλησης, ακολουθεί συζήτηση, ενδεχομένως γίνεται περισσότερη δουλειά στο υποκατάστημα και τελικά η αίτηση ούμε κλείνει ούμε συγχωνεύεται.

This is the basic workflow that most GitHub projects use. Topic branches are created, Pull Requests are opened on them, a discussion ensues, possibly more work is done on the branch and eventually the request is either closed or merged.

[ΣΗΜΕΙΩΣΗ]
.Όχι μόνο διχάλες
====
Είναι σημαντικό να σημειώσουμε ότι μπορούμε επίσης να ανοίξουμε ένα ερώτημα έλξης μεταξύ δύο υποκαταστημάτων στο ίδιο αποθετήριο. Εάν εργάζεστε σε μια λειτουργία με κάποιον και έχουμε και οι δύο πρόσβαση σε εγγραφή στο έργο, μπορούμε να σπρώξουμε ένα υποκατάστημα θέματος στο αποθετήριο και να ανοίξουμε μια Αίτηση Τράβηγμα σε αυτό στον κλάδο `master` του ίδιου έργου για να ξεκινήσει ο κώδικας αναθεώρηση και διαδικασία συζήτησης. Δεν είναι απαραίτητο το τσιμπούρισμα.
====
[NOTE]
.Not Only Forks
====
It's important to note that you can also open a Pull Request between two branches in the same repository. If you're working on a feature with someone and you both have write access to the project, you can push a topic branch to the repository and open a Pull Request on it to the `master` branch of that same project to initiate the code review and discussion process. No forking necessary.
====

==== Advanced Pull Requests

Τώρα που καλύψαμε τα βασικά στοιχεία της συμβολής σε ένα έργο στο GitHub, ας καλύψουμε μερικές ενδιαφέρουσες συμβουλές και κόλπα σχετικά με τα Pull Requests, ώστε να μπορούμε να είστε πιο αποτελεσματικοί στη χρήση τους.

Now that we've covered the basics of contributing to a project on GitHub, let's cover a few interesting tips and tricks about Pull Requests so you can be more effective in using them.

===== Pull Requests as Patches

Είναι σημαντικό να καταλάβουμε ότι πολλά έργα δεν σκέφτονται πραγματικά τα Pull Requests ως ουρές τέλειων μπαλωμάτων που πρέπει να εφαρμόζουν καθαρά, καθώς τα περισσότερα έργα που βασίζονται σε κατάλογο αλληλογραφίας σκέφτονται τις συμβολές της σειράς patch. Τα περισσότερα έργα του GitHub σκέφτονται τα τμήματα Pull Request ως επαναληπτικές συνομιλίες γύρω από μια προτεινόμενη αλλαγή, με αποκορύφωμα μια ενοποιημένη διαφορά που εφαρμόζεται με τη συγχώνευση.

It's important to understand that many projects don't really think of Pull Requests as queues of perfect patches that should apply cleanly in order, as most mailing list-based projects think of patch series contributions. Most GitHub projects think about Pull Request branches as iterative conversations around a proposed change, culminating in a unified diff that is applied by merging.

This is an important distinction, because generally the change is suggested before the code is thought to be perfect, which is far more rare with mailing list based patch series contributions. This enables an earlier conversation with the maintainers so that arriving at the proper solution is more of a community effort. When code is proposed with a Pull Request and the maintainers or community suggest a change, the patch series is generally not re-rolled, but instead the difference is pushed as a new commit to the branch, moving the conversation forward with the context of the previous work intact.

Αυτή είναι μια σημαντική διάκριση, διότι γενικά η αλλαγή προτείνεται προτού ο κώδικας θεωρηθεί τέλειος, ο οποίος είναι πολύ πιο σπάνιος με τις συνεισφορές της σειράς αλληλογραφίας με βάση τη λίστα αλληλογραφίας. Αυτό επιτρέπει μια προηγούμενη συζήτηση με τους διαχειριστές ώστε η επίτευξη της σωστής λύσης να είναι περισσότερο από μια κοινοτική προσπάθεια. Όταν ο κώδικας προτείνεται με μια Αίτηση Pull και οι συντηρητές ή η κοινότητα προτείνουν μια αλλαγή, η σειρά των patch γενικά δεν ανακυκλώνεται, αλλά η διαφορά ωθείται ως νέα δέσμευση στον κλάδο, μετακινώντας τη συνομιλία προς τα εμπρός με το πλαίσιο της προηγούμενη εργασία άθικτη.

Για παράδειγμα, αν επιστρέψουμε και κοιτάξουμε ξανά το <<_pr_final>>, θα παρατηρήσουμε ότι ο συνεισφέρων δεν ανακάλεσε τη δέσμευσή του και έστειλε άλλο αίτημα. Αντ 'αυτού, πρόσθεσαν νέες δεσμεύσεις και τους ώθησαν στο υφιστάμενο υποκατάστημα. Με αυτόν τον τρόπο, αν επιστρέψουμε και θα εξετάσουμε αυτό το αίτημα εξαναγκασμού στο μέλλον, μπορούμε εύκολα να βρούμε όλο το πλαίσιο για το γιατί έγιναν οι αποφάσεις. Πατώντας το πλήκτρο `` Συγχώνευση '' στην τοποθεσία δημιουργεί σκόπιμα μια δέσμευση συγχώνευσης που αναφέρει το Pull Request έτσι ώστε να είναι εύκολο να επιστρέψουμε και να διερευνήσουμε την αρχική συνομιλία αν χρειαστεί.

For instance, if you go back and look again at <<_pr_final>>, you'll notice that the contributor did not rebase his commit and send another Pull Request. Instead they added new commits and pushed them to the existing branch. This way if you go back and look at this Pull Request in the future, you can easily find all of the context of why decisions were made. Pushing the ``Merge'' button on the site purposefully creates a merge commit that references the Pull Request so that it's easy to go back and research the original conversation if necessary.

===== Keeping up with Upstream

Αν η ερώτησή σας για το τράβηγμα δεν είναι ενημερωμένη ή δεν συγχωνεύεται με άλλο τρόπο, θα θέλουμε να το διορθώσουμε, έτσι ώστε ο συντηρητής να μπορεί να το συγχωνεύσει εύκολα. Το GitHub θα δοκιμάσει αυτό για εσάς και θα σας ενημερώσει στο κάτω μέρος κάθε Αίτησης Τράβηξης εάν η συγχώνευση είναι ασήμαντη ή όχι.

If your Pull Request becomes out of date or otherwise doesn't merge cleanly, you will want to fix it so the maintainer can easily merge it. GitHub will test this for you and let you know at the bottom of every Pull Request if the merge is trivial or not.

[[_pr_fail]]
.Pull Request does not merge cleanly
image::images/pr-01-fail.png[PR merge failure]

If you see something like <<_pr_fail>>, you'll want to fix your branch so that it turns green and the maintainer doesn't have to do extra work.

Εάν δούμε κάτι σαν << _pr_fail>>, θα θελήσουμε να διορθώσουμε το κλαδί σας έτσι ώστε να γίνει πράσινο και ο συντηρητής δεν χρειάζεται να κάνει επιπλέον εργασία.

Έχουμε δύο κύριες επιλογές για να το κάνουμε αυτό. Μπορούμε ούμε να αναδιοργανώσουμε το υποκατάστημά σας πάνω από οποιοδήποτε υποκατάστημα-στόχο (συνήθως το κύριο τμήμα του χώρου αποθήκευσής σας) ή μπορούμε να συγχωνεύσουμε το υποκατάστημα-στόχο στο υποκατάστημά σας.

You have two main options in order to do this. You can either rebase your branch on top of whatever the target branch is (normally the `master` branch of the repository you forked), or you can merge the target branch into your branch.

Most developers on GitHub will choose to do the latter, for the same reasons we just went over in the previous section. What matters is the history and the final merge, so rebasing isn't getting you much other than a slightly cleaner history and in return is *far* more difficult and error prone.

Οι περισσότεροι προγραμματιστές στο GitHub θα επιλέξουν να κάνουν το τελευταίο, για τους ίδιους λόγους που μόλις πήγαμε στο προηγούμενο τμήμα. Αυτό που έχει σημασία είναι η ιστορία και η τελική συγχώνευση, οπότε η επαναχρησιμοποίηση δεν σας προσφέρει τίποτα άλλο από μια κάπως καθαρότερη ιστορία και σε αντάλλαγμα είναι * πολύ πιο δύσκολη και επιρρεπής σε σφάλματα.

Εάν θέλουμε να συγχωνεύσουμε το υποκατάστημα προορισμού για να καταστήσουμε το Pull Request ενοποιημένο, θα προσθέσουμε το αρχικό αποθετήριο ως νέο απομακρυσμένο, θα το παραλάβουμε, θα συγχωνεύσουμε τον κύριο κλάδο αυτού του αποθετηρίου στο υποκατάστημα του θέματος σας, θα διορθώσουμε τυχόν προβλήματα και τελικά θα τον σπρώξουμε επιστρέψτε στο ίδιο υποκατάστημα που ανοίξατε το ζήτημα έλξης.

If you want to merge in the target branch to make your Pull Request mergeable, you would add the original repository as a new remote, fetch from it, merge the main branch of that repository into your topic branch, fix any issues and finally push it back up to the same branch you opened the Pull Request on.

Για παράδειγμα, ας πούμε ότι στο παράδειγμα `` tonychacon '' που χρησιμοποιούσαμε πριν, ο αρχικός συγγραφέας έκανε μια αλλαγή που θα δημιουργούσε μια σύγκρουση στο Request Pull. Ας περάσουμε αυτά τα βήματα.

For example, let's say that in the ``tonychacon'' example we were using before, the original author made a change that would create a conflict in the Pull Request. Let's go through those steps.

[source,console]
----
$ git remote add upstream https://github.com/schacon/blink <1>

$ git fetch upstream <2>
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
 * [new branch]      master     -> upstream/master

$ git merge upstream/master <3>
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.

$ vim blink.ino <4>
$ git add blink.ino
$ git commit
[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \
    into slower-blink

$ git push origin slow-blink <5>
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
   ef4725c..3c8d735  slower-blink -> slow-blink
----

<1> Add the original repository as a remote named ``upstream''
<2> Fetch the newest work from that remote
<3> Merge the main branch into your topic branch
<4> Fix the conflict that occurred
<5> Push back up to the same topic branch

1> Προσθέστε το αρχικό αποθετήριο ως απομακρυσμένο όνομα `` upstream ''
<2> Λάβουμε το νεότερο έργο από αυτό το τηλεχειριστήριο
<3> Συγχώνευση του κύριου υποκαταστήματος στον κλάδο του θέματος
<4> Διορθώστε τη σύγκρουση που συνέβη
<5> Πιέστε ξανά στον ίδιο κλάδο θέμα

Μόλις το κάνουμε αυτό, το "Pull Request" θα ενημερωθεί αυτόματα και θα επανελεγχθεί για να διαπιστωθεί εάν συγχωνεύεται καθαρά.

Once you do that, the Pull Request will be automatically updated and re-checked to see if it merges cleanly.

[[_pr_merge_fix]]
.Pull Request now merges cleanly
image::images/pr-02-merge-fix.png[PR fixed]

One of the great things about Git is that you can do that continuously. If you have a very long-running project, you can easily merge from the target branch over and over again and only have to deal with conflicts that have arisen since the last time that you merged, making the process very manageable.

Ένα από τα σπουδαία πράγματα για το Git είναι ότι μπορούμε να το κάνουμε αυτό συνεχώς. Εάν έχουμε ένα πολύ μακροχρόνιο έργο, μπορούμε εύκολα να συγχωνευθούμε από τον κλάδο στόχο ξανά και ξανά και μόνο να αντιμετωπίσουμε τις συγκρούσεις που έχουν προκύψει από την τελευταία φορά που συγχωνεύσατε, κάνοντας τη διαδικασία πολύ εύχρηστη.

Εάν θέλουμε απολύτως να αναδιοργανώσουμε το υποκατάστημα για να το καθαρίσουμε, μπορούμε σίγουρα να το κάνουμε αυτό, αλλά είναι ιδιαίτερα ενθαρρυντικό να μην πιέσουμε το υποκατάστημα που έχει ήδη ανοίξει το Pull Request. Εάν άλλοι άνθρωποι το έχουν τραβήξει κάτω και κάνουν περισσότερα έργα σε αυτό, θα συναντήσουμε σε όλα τα θέματα που περιγράφονται στο <<_rebase_peril>>. Αντ 'αυτού, σπρώξτε το rebased υποκατάστημα σε ένα νέο υποκατάστημα στο GitHub και ανοίξτε ένα καινούργιο Pull Request αναφέροντας το παλιό και στη συνέχεια κλείστε το πρωτότυπο.

If you absolutely wish to rebase the branch to clean it up, you can certainly do so, but it is highly encouraged to not force push over the branch that the Pull Request is already opened on. If other people have pulled it down and done more work on it, you run into all of the issues outlined in <<_rebase_peril>>. Instead, push the rebased branch to a new branch on GitHub and open a brand new Pull Request referencing the old one, then close the original.

===== References

Your next question may be ``How do I reference the old Pull Request?''. It turns out there are many, many ways to reference other things almost anywhere you can write in GitHub.

Η επόμενη ερώτησή σας μπορεί να είναι `` Πώς μπορώ να αναφερθώ στο παλιό Αίτημα Ανάληψης; ''. Αποδεικνύεται ότι υπάρχουν πολλοί τρόποι να αναφερθούν άλλα πράγματα σχεδόν οπουδήποτε μπορούμε να γράψουμε στο GitHub.

Ας ξεκινήσουμε με τον τρόπο παραπομπής μιας άλλης Ζώνης Αίτησης ή μιας Έκδοσης. Όλα τα αιτήματα και τα ζητήματα έλξης έχουν εκχωρηθεί και είναι μοναδικά στο πλαίσιο του έργου. Για παράδειγμα, δεν μπορούμε να βρούμε το Αίτημα # 3 και το τεύχος # 3. Αν θέλουμε να αναφερθώ σε οποιοδήποτε απόσπασμα Αίτησης ή Έκδοσης από οποιοδήποτε άλλο, μπορούμε απλά να βάλουμε το `# <num> σε οποιοδήποτε σχόλιο ή περιγραφή. Μπορούμε επίσης να είστε πιο συγκεκριμένοι αν το ζήτημα ζήτησης ή ζήτησης διαμένει κάπου αλλού. γράψτε το όνομα χρήστη # <num> αν αναφέρεστε σε μια ερώτηση ζήτησης ή τραβήγματος σε μια διακλάδωση του χώρου αποθήκευσής σας ή στο όνομα χρήστη / repo # <num> για να αναφέρουμε κάτι σε άλλο χώρο αποθήκευσης.

Let's start with how to cross-reference another Pull Request or an Issue. All Pull Requests and Issues are assigned numbers and they are unique within the project. For example, you can't have Pull Request #3 _and_ Issue #3. If you want to reference any Pull Request or Issue from any other one, you can simply put `#<num>` in any comment or description. You can also be more specific if the Issue or Pull request lives somewhere else; write `username#<num>` if you're referring to an Issue or Pull Request in a fork of the repository you're in, or `username/repo#<num>` to reference something in another repository.

Ας δούμε ένα παράδειγμα. Ας υποθέσουμε ότι επαναπροσδιορίσαμε το υποκατάστημα στο προηγούμενο παράδειγμα, δημιούργησε ένα νέο αίτημα έλξης για αυτό και τώρα θέλουμε να αναφερθούμε στο παλιό αίτημα έλξης από το νέο. Θέλουμε επίσης να αναφερθούμε σε ένα ζήτημα στο πηρούνι του αποθετηρίου και ένα ζήτημα σε ένα εντελώς διαφορετικό έργο. Μπορούμε να συμπληρώσουμε την περιγραφή ακριβώς όπως <<_pr_references>>.

Let's look at an example. Say we rebased the branch in the previous example, created a new pull request for it, and now we want to reference the old pull request from the new one. We also want to reference an issue in the fork of the repository and an issue in a completely different project. We can fill out the description just like <<_pr_references>>.

[[_pr_references]]
.Cross references in a Pull Request.
image::images/mentions-01-syntax.png[PR references]

Όταν υποβάλαμε αυτό το αίτημα έλξης, θα δούμε όλα αυτά που αποδίδονται σαν <<_pr_references_render>>.

When we submit this pull request, we'll see all of that rendered like <<_pr_references_render>>.

[[_pr_references_render]]
.Cross references rendered in a Pull Request.
image::images/mentions-02-render.png[PR references rendered]

Notice that the full GitHub URL we put in there was shortened to just the information needed.

Παρατηρήστε ότι η πλήρης διεύθυνση URL του GitHub που βάλουμε εκεί συντομεύτηκε μόνο στις απαραίτητες πληροφορίες.

Τώρα, αν ο Tony επιστρέψει και κλείσει το αρχικό Pull Request, μπορούμε να δούμε ότι αναφέροντάς το στο νέο, το GitHub δημιούργησε αυτόματα ένα trackback στο Pull Request timeline. Αυτό σημαίνει ότι όποιος επισκέπτεται αυτή την Αίτηση Τραβίσματος και βλέπει ότι είναι κλειστός μπορεί εύκολα να συνδεθεί με εκείνον που την αντικατέστησε. Ο σύνδεσμος θα μοιάζει με το <<_pr_closed>>.

Now if Tony goes back and closes out the original Pull Request, we can see that by mentioning it in the new one, GitHub has automatically created a trackback event in the Pull Request timeline. This means that anyone who visits this Pull Request and sees that it is closed can easily link back to the one that superseded it. The link will look something like <<_pr_closed>>.

[[_pr_closed]]
.Cross references rendered in a Pull Request.
image::images/mentions-03-closed.png[PR closed]

Εκτός από τους αριθμούς έκδοσης, μπορούμε επίσης να αναφέρουμε μια συγκεκριμένη δέσμευση από το SHA-1. Πρέπει να ορίσουμε ένα πλήρες 40 χαρακτήρων SHA-1, αλλά εάν το GitHub διαπιστώσει ότι σε ένα σχόλιο, θα συνδεθεί άμεσα με τη δέσμευση. Και πάλι, μπορούμε να αναφέρουμε δεσμεύσεις σε πιρούνια ή άλλα αποθετήρια με τον ίδιο τρόπο που κάνατε με τα θέματα.

In addition to issue numbers, you can also reference a specific commit by SHA-1. You have to specify a full 40 character SHA-1, but if GitHub sees that in a comment, it will link directly to the commit. Again, you can reference commits in forks or other repositories in the same way you did with issues.

==== Markdown

Linking to other Issues is just the beginning of interesting things you can do with almost any text box on GitHub. In  Issue and Pull Request descriptions, comments, code comments and more, you can use what is called ``GitHub Flavored Markdown''. Markdown is like writing in plain text but which is rendered richly.

Η σύνδεση με άλλα θέματα είναι μόνο η αρχή των ενδιαφερόντων που μπορούμε να κάνουμε με σχεδόν οποιοδήποτε πλαίσιο κειμένου στο GitHub. Στις περιγραφές των αιτημάτων, των σχολίων, των σχολίων κώδικα και άλλων, μπορούμε να χρησιμοποιήσουμε αυτό που ονομάζεται `` GitHub Flavored Markdown ''. Το Markdown είναι σαν να γράφουμε σε απλό κείμενο αλλά το οποίο αποδίδεται πλούσια.

Βλέπε <<_example_markdown>> για ένα παράδειγμα του πώς μπορούν να γραφτούν σχόλια ή κείμενο και στη συνέχεια να αποτυπωθούν χρησιμοποιώντας το Markdown.

See <<_example_markdown>> for an example of how comments or text can be written and then rendered using Markdown.

[[_example_markdown]]
.An example of Markdown as written and as rendered.
image::images/markdown-01-example.png[Example Markdown]

===== GitHub Flavored Markdown

Η γεύση GitHub του Markdown προσθέτει περισσότερα πράγματα που μπορούμε να κάνουμε πέρα ​​από τη βασική σύνταξη Markdown. Αυτά μπορούν όλοι να είναι πραγματικά χρήσιμα όταν δημιουργούμε χρήσιμα σχόλια ή περιγραφές Αίτησης ή Σχολής Τραβήγματος.

The GitHub flavor of Markdown adds more things you can do beyond the basic Markdown syntax. These can all be really useful when creating useful Pull Request or Issue comments or descriptions.

====== Task Lists

Η πρώτη πραγματικά χρήσιμη λειτουργία GitHub ειδικά Markdown, ειδικά για χρήση σε Pull Requests, είναι η λίστα εργασιών. Μια λίστα εργασιών είναι μια λίστα των πλαισίων ελέγχου των πραγμάτων που θέλουμε να κάνουμε. Η τοποθέτησή τους σε μια ερώτηση ζήτησης ή τράβηγμα συνήθως υποδεικνύει τα πράγματα που θέλουμε να κάνουμε πριν να θεωρήσουμε ότι το στοιχείο ολοκληρώθηκε.


The first really useful GitHub specific Markdown feature, especially for use in Pull Requests, is the Task List. A task list is a list of checkboxes of things you want to get done. Putting them into an Issue or Pull Request normally indicates things that you want to get done before you consider the item complete.

Μπορούμε να δημιουργήσουμε μια λίστα εργασιών όπως αυτή:

[source]
----
- [X] Write the code
- [ ] Write all the tests
- [ ] Document the code
----

Αν συμπεριλάβουμε αυτό στην περιγραφή της Αίτησης ή του Τεύματος μας, θα το δούμε σαν <<_task_lists>>

If we include this in the description of our Pull Request or Issue, we'll see it rendered like <<_task_lists>>

[[_task_lists]]
.Task lists rendered in a Markdown comment.
image::images/markdown-02-tasks.png[Example Task List]

This is often used in Pull Requests to indicate what all you would like to get done on the branch before the Pull Request will be ready to merge. The really cool part is that you can simply click the checkboxes to update the comment -- you don't have to edit the Markdown directly to check tasks off.

Αυτό χρησιμοποιείται συχνά στα Pull Requests για να υποδείξουμε τι θα επιθυμούσατε να κάνουμε στο υποκατάστημα πριν από την ολοκλήρωση του Pull Request. Το πολύ δροσερό μέρος είναι ότι μπορούμε απλά να κάνουμε κλικ στα πλαίσια ελέγχου για να ενημερώσουμε το σχόλιο - δεν χρειάζεται να επεξεργαστούμε άμεσα το Markdown για να ελέγξουμε τις εργασίες εκτός λειτουργίας.

Επιπλέον, το GitHub θα ψάξει για λίστες εργασιών στα Θέματά σας και τα Τραβηκτικά αιτήματα και θα τα δείξει ως μεταδεδομένα στις σελίδες που τα απαριθμούν. Για παράδειγμα, εάν έχουμε μια Αίτηση Τραβήγματος με εργασίες και κοιτάζουμε τη σελίδα επισκόπησης όλων των Αγώνων Ανάληψης, μπορούμε να δούμε πόσο γίνεται. Αυτό βοηθά τους ανθρώπους να καταστρέψουν τα Pull Requests σε υποτμήματα και βοηθά τους άλλους να παρακολουθούν την πρόοδο του κλάδου. Μπορούμε να δούμε ένα παράδειγμα αυτού στο <<_task_list_progress>>.

What's more, GitHub will look for task lists in your Issues and Pull Requests and show them as metadata on the pages that list them out. For example, if you have a Pull Request with tasks and you look at the overview page of all Pull Requests, you can see how far done it is. This helps people break down Pull Requests into subtasks and helps other people track the progress of the branch. You can see an example of this in <<_task_list_progress>>.

[[_task_list_progress]]
.Task list summary in the Pull Request list.
image::images/markdown-03-task-summary.png[Example Task List]

Αυτά είναι εξαιρετικά χρήσιμα όταν ανοίγουμε εκ των προτέρων ένα Pull Request και το χρησιμοποιούμε για να παρακολουθούμε την πρόοδό σας μέσω της εφαρμογής του χαρακτηριστικού.

These are incredibly useful when you open a Pull Request early and use it to track your progress through the implementation of the feature.

====== Code Snippets

You can also add code snippets to comments. This is especially useful if you want to present something that you _could_ try to do before actually implementing it as a commit on your branch. This is also often used to add example code of what is not working or what this Pull Request could implement.

Μπορούμε επίσης να προσθέσουμε αποσπάσματα κώδικα σε σχόλια. Αυτό είναι ιδιαίτερα χρήσιμο εάν θέλουμε να παρουσιάσουμε κάτι που πρέπει να προσπαθήσουμε να κάνουμε, πριν να το υλοποιήσουμε ως δέσμευση στον κλάδο σας. Αυτό χρησιμοποιείται επίσης συχνά για να προσθέσουμε κώδικα παράδειγμα για το τι δεν λειτουργεί ή για το τι θα μπορούσε να εφαρμόσει αυτό το Αίτημα Pull.

Για να προσθέσουμε ένα κομμάτι κώδικα, πρέπει να το περικλείσουμε σε βαρείες.

[source]
----
```java
for(int i=0 ; i < 5 ; i++)
{
   System.out.println("i is : " + i);
}
```
----

Εάν προσθέσουμε ένα όνομα γλώσσας όπως κάναμε εκεί με το 'java', το GitHub θα προσπαθήσει επίσης να συντάξει το απόσπασμα. Στην περίπτωση του παραπάνω παραδείγματος, θα καταλήξει σαν <<_md_code>>.

If you add a language name like we did there with 'java', GitHub will also try to syntax highlight the snippet. In the case of the above example, it would end up rendering like <<_md_code>>.

[[_md_code]]
.Rendered fenced code example.
image::images/markdown-04-fenced-code.png[Rendered fenced code]

====== Quoting

Εάν απαντάτε σε ένα μικρό κομμάτι ενός μακρού σχολίου, μπορούμε να παραθέσουμε επιλεκτικά από το άλλο σχόλιο προβαίνοντας στις γραμμές με τον χαρακτήρα `>`. Στην πραγματικότητα, αυτό είναι τόσο κοινό και τόσο χρήσιμο ώστε να υπάρχει μια συντόμευση πληκτρολογίου για αυτό. Εάν επισημάνουμε κείμενο σε ένα σχόλιο στο οποίο θέλουμε να απαντήσουμε άμεσα και πατήσουμε το πλήκτρο `r`, θα παραθέσουμε αυτό το κείμενο στο πλαίσιο σχολίων για εσάς.

If you're responding to a small part of a long comment, you can selectively quote out of the other comment by preceding the lines with the `>` character. In fact, this is so common and so useful that there is a keyboard shortcut for it. If you highlight text in a comment that you want to directly reply to and hit the `r` key, it will quote that text in the comment box for you.

Τα αποσπάσματα μοιάζουν με αυτό:

The quotes look something like this:

[source]
----
> Whether 'tis Nobler in the mind to suffer
> The Slings and Arrows of outrageous Fortune,

How big are these slings and in particular, these arrows?
----

Μόλις παραδοθεί, το σχόλιο θα μοιάζει με <<_md_quote>>.

Once rendered, the comment will look like <<_md_quote>>.

[[_md_quote]]
.Rendered quoting example.
image::images/markdown-05-quote.png[Rendered quoting]

====== Emoji

Finally, you can also use emoji in your comments. This is actually used quite extensively in comments you see on many GitHub Issues and Pull Requests. There is even an emoji helper in GitHub. If you are typing a comment and you start with a `:` character, an autocompleter will help you find what you're looking for.

Τέλος, μπορούμε επίσης να χρησιμοποιήσουμε το emoji στα σχόλιά σας. Αυτό χρησιμοποιείται πραγματικά αρκετά εκτενώς στα σχόλια που βλέπουμε σε πολλά θέματα GitHub και τα αιτήματα τράβηξης. Υπάρχει ακόμα ένας βοηθός emoji στο GitHub. Αν πληκτρολογούμε ένα σχόλιο και ξεκινάτε με ένα χαρακτήρα `:`, ένας αυτόματος συμπυκνωτής θα σας βοηθήσει να βρούμε αυτό που ψάχνουμε.

[[_md_emoji_auto]]
.Emoji autocompleter in action.
image::images/markdown-06-emoji-complete.png[Emoji autocompleter]

Οι Emojis παίρνουν τη μορφή `: <name>:` οπουδήποτε στο σχόλιο. Για παράδειγμα, θα μπορούσατε να γράψουμε κάτι σαν αυτό:

Emojis take the form of `:<name>:` anywhere in the comment. For instance, you could write something like this:

[source]
----
I :eyes: that :bug: and I :cold_sweat:.

:trophy: for :microscope: it.

:+1: and :sparkles: on this :ship:, it's :fire::poop:!

:clap::tada::panda_face:
----

Όταν παρέχεται, θα φαίνεται σαν << _md_emoji>>.

When rendered, it would look something like <<_md_emoji>>.

[[_md_emoji]]
.Heavy emoji commenting.
image::images/markdown-07-emoji.png[Emoji]

Όχι ότι αυτό είναι απίστευτα χρήσιμο, αλλά προσθέτει ένα στοιχείο διασκέδασης και συγκίνησης σε ένα μέσο που κατά τα άλλα είναι δύσκολο να μεταδώσει το συναίσθημα.

Not that this is incredibly useful, but it does add an element of fun and emotion to a medium that is otherwise hard to convey emotion in.


[ΣΗΜΕΙΩΣΗ]
====
Υπάρχουν στην πραγματικότητα αρκετά πλήθος υπηρεσιών διαδικτύου που κάνουν χρήση των χαρακτήρων emoji αυτές τις μέρες. Ένα μεγάλο φύλλο εξαπατήσει για να ανακαλύψει emoji που εκφράζει αυτό που θέλουμε να πούμε μπορεί να βρεθεί στο:

[NOTE]
====
There are actually quite a number of web services that make use of emoji characters these days. A great cheat sheet to reference to find emoji that expresses what you want to say can be found at:

http://www.emoji-cheat-sheet.com
====

====== Εικόνες

Αυτό δεν είναι τεχνικά GitHub Flavored Markdown, αλλά είναι εξαιρετικά χρήσιμο. Εκτός από την προσθήκη συνδέσμων εικόνας Markdown σε σχόλια, για τα οποία μπορεί να είναι δύσκολο να βρεθούν και να ενσωματωθούν διευθύνσεις URL, το GitHub σάς επιτρέπει να μεταφέρουμε και μεταφέρουμε εικόνες σε περιοχές κειμένου για να τις ενσωματώσουμε.

This isn't technically GitHub Flavored Markdown, but it is incredibly useful. In addition to adding Markdown image links to comments, which can be difficult to find and embed URLs for, GitHub allows you to drag and drop images into text areas to embed them.

[[_md_drag]]
.Drag and drop images to upload them and auto-embed them.
image::images/markdown-08-drag-drop.png[Drag and drop images]

Αν κοιτάξουμε πίσω στο <<_pr_references>>, μπορούμε να δούμε μια μικρή συμβουλή `` Parsed as Markdown '' πάνω από την περιοχή κειμένου. Κάνοντας κλικ σε αυτό θα σας δοθεί ένα πλήρες φύλλο εξαπάτησης από ό, τι μπορούμε να κάνουμε με το Markdown στο GitHub.

If you look back at <<_pr_references>>, you can see a small ``Parsed as Markdown'' hint above the text area. Clicking on that will give you a full cheat sheet of everything you can do with Markdown on GitHub.
