=== Scripting GitHub

So now we've covered all of the major features and workflows of GitHub, but any large group or project will have customizations they may want to make or external services they may want to integrate.

Τώρα λοιπόν καλύψαμε όλες τις σημαντικές λειτουργίες και τις ροές εργασίας του GitHub, αλλά κάθε μεγάλη ομάδα ή έργο θα έχει προσαρμογές που μπορεί να θέλουν να κάνουν ή εξωτερικές υπηρεσίες που ενδεχομένως θα ήθελαν να ενσωματώσουν.

Ευτυχώς για εμάς, το GitHub είναι πραγματικά αρκετά απειλητικό με πολλούς τρόπους.
Σε αυτή την ενότητα θα περιγράψουμε πώς να χρησιμοποιήσουμε το σύστημα GitHub hooks και το API του ώστε να κάνει το GitHub να λειτουργεί όπως θέλουμε.

Luckily for us, GitHub is really quite hackable in many ways.
In this section we'll cover how to use the GitHub hooks system and its API to make GitHub work how we want it to.

==== Άγκιστρα

Το τμήμα Αγκίστρων και Υπηρεσιών της διαχείρισης του αποθετηρίου GitHub είναι ο ευκολότερος τρόπος να επικοινωνήσουμε με το GitHub με εξωτερικά συστήματα.

The Hooks and Services section of GitHub repository administration is the easiest way to have GitHub interact with external systems.

===== Υπηρεσίες

Πρώτα θα ρίξουμε μια ματιά στις Υπηρεσίες.
Τόσο οι ενσωματώσεις Αγκίστρων όσο και Υπηρεσιών βρίσκονται στην ενότητα ``Settings'' του αποθετηρίου, όπου προηγουμένως εξετάσαμε την προσθήκη Συνεργατών και την αλλαγή του προεπιλεγμένου κλάδου του έργου μας.
Στην καρτέλα ``Webhooks and Services'' θα δούμε κάτι σαν <<_services_hooks>>.

First we'll take a look at Services.
Both the Hooks and Services integrations can be found in the Settings section of your repository, where we previously looked at adding Collaborators and changing the default branch of your project.
Under the ``Webhooks and Services'' tab you will see something like <<_services_hooks>>.

[[_services_hooks]]
.Services and Hooks configuration section.
image::images/scripting-01-services.png[Services and hooks]

Υπάρχουν δεκάδες υπηρεσίες από τις οποίες μπορούμε να επιλέξουμε, οι περισσότερες από αυτές ενσωματώνονται σε άλλα εμπορικά και ανοιχτά συστήματα.
Τα περισσότερα από αυτά προορίζονται για υπηρεσίες Συνεχούς Ενσωμάτωσης, παρακολούθησης σφαλμάτων και προβλημάτων, συστήματα chat room και συστήματα τεκμηρίωσης.
Θα περπατήσουμε μέσα από τη δημιουργία ενός πολύ απλού, του γάντζου ηλεκτρονικού ταχυδρομείου.
Εάν επιλέξουμε ``email'' από την αναπτυσσόμενη λίστα ``Add Service'', θα πάρουμε μια οθόνη διαμόρφωσης όπως <<_service_config>>.

There are dozens of services you can choose from, most of them integrations into other commercial and open source systems.
Most of them are for Continuous Integration services, bug and issue trackers, chat room systems and documentation systems.
We'll walk through setting up a very simple one, the Email hook.
If you choose ``email'' from the ``Add Service'' dropdown, you'll get a configuration screen like <<_service_config>>.

[[_service_config]]
.Email service configuration.
image::images/scripting-02-email-service.png[Email service]

In this case, if we hit the ``Add service'' button, the email address we specified will get an email every time someone pushes to the repository.
Services can listen for lots of different types of events, but most only listen for push events and then do something with that data.

Σε αυτήν την περίπτωση, εάν πατήσουμε το κουμπί ``Προσθήκη υπηρεσίας'', η διεύθυνση ηλεκτρονικού ταχυδρομείου που καθορίσαμε θα λάβει ένα μήνυμα ηλεκτρονικού ταχυδρομείου κάθε φορά που κάποιος σπρώχνει στο αποθετήριο.
Οι υπηρεσίες μπορούν να ακούσουν πολλούς διαφορετικούς τύπους γεγονότων, αλλά οι περισσότεροι μόνο ακούν για συμβάντα push και στη συνέχεια κάνουν κάτι με αυτά τα δεδομένα.

Εάν υπάρχει ένα σύστημα που χρησιμοποιούμε ότι θέλουμε να ενσωματώσουμε με το GitHub, θα πρέπει να ελέγξουμε εδώ για να δούμε εάν υπάρχει μια υπάρχουσα ολοκλήρωση υπηρεσίας διαθέσιμη.
Για παράδειγμα, αν χρησιμοποιούμε Jenkins για να εκτελέσουμε δοκιμές στον κώδικα μας, μπορούμε να ενεργοποιήσουμε την ενσωμάτωση υπηρεσιών Jenkins ενσωματωμένη στην υπηρεσία για να ξεκινήσει μια δοκιμαστική λειτουργία κάθε φορά που κάποιος σπρώχνει στο αποθετήριο μας.

If there is a system you are using that you would like to integrate with GitHub, you should check here to see if there is an existing service integration available.
For example, if you're using Jenkins to run tests on your codebase, you can enable the Jenkins builtin service integration to kick off a test run every time someone pushes to your repository.

===== Άγκιστρα

Εάν χρειαζόμαστε κάτι πιο συγκεκριμένο ή θέλουμε να ενσωματώσουμε μια υπηρεσία ή έναν ιστότοπο που δεν περιλαμβάνεται σε αυτήν τη λίστα, μπορούμε αντ 'αυτού να χρησιμοποιήσουμε το πιο γενικό σύστημα γάντζων.
Οι γάντζοι αποθετηρίων GitHub είναι αρκετά απλοί.
Ορίζουμε μια διεύθυνση URL και το GitHub θα δημοσιεύσει ένα ωφέλιμο φορτίο HTTP σε αυτήν τη διεύθυνση URL σε οποιοδήποτε γεγονός θέλουμε.

If you need something more specific or you want to integrate with a service or site that is not included in this list, you can instead use the more generic hooks system.
GitHub repository hooks are pretty simple.
You specify a URL and GitHub will post an HTTP payload to that URL on any event you want.

Generally the way this works is you can setup a small web service to listen for a GitHub hook payload and then do something with the data when it is received.

Γενικά, ο τρόπος με τον οποίο λειτουργεί αυτό είναι ότι μπορούμε να εγκατασήσουμε μια μικρή υπηρεσία ιστού που να ακούει το φορτίο GitHub και στη συνέχεια να κάνουμε κάτι με τα δεδομένα όταν παραληφθεί.

Για να ενεργοποιήσουμε ένα άγκιστρο, κάνουμ κλικ στο κουμπί "Προσθήκη webhook" στο <<_services_hooks>>.
Αυτό θα μας φέρει σε μια σελίδα που μοιάζει με <<_web_hook>>.

To enable a hook, you click the ``Add webhook'' button in <<_services_hooks>>.
This will bring you to a page that looks like <<_web_hook>>.

[[_web_hook]]
.Web hook configuration.
image::images/scripting-03-webhook.png[Web hook]

Η διαμόρφωση για ένα γάντζο ιστού είναι αρκετά απλή.
Στις περισσότερες περιπτώσεις, απλά εισάγουμε μια διεύθυνση URL και ένα μυστικό κλειδί και κάνουμε κλικ στο ``Add webhook''.
Υπάρχουν μερικές επιλογές για τα γεγονότα στα οποία θέλουμε το GitHub να μας στείλει ένα ωφέλιμο φορτίο - η προεπιλογή είναι να πάρει μόνο ένα ωφέλιμο φορτίο για το συμβάν `push ', όταν κάποιος πιέσει νέο κώδικα σε οποιοδήποτε υποκατάστημα του αποθετηρίου μας.

The configuration for a web hook is pretty simple.
In most cases you simply enter a URL and a secret key and hit ``Add webhook''.
There are a few options for which events you want GitHub to send you a payload for -- the default is to only get a payload for the `push` event, when someone pushes new code to any branch of your repository.

Let's see a small example of a web service you may set up to handle a web hook.
We'll use the Ruby web framework Sinatra since it's fairly concise and you should be able to easily see what we're doing.

Ας δούμε ένα μικρό παράδειγμα μιας υπηρεσίας ιστού που μπορούμε να ρυθμίσουμε για να χειριστούμε ένα γάντζο ιστού.
Θα χρησιμοποιήσουμε το πλαίσιο ιστού Ruby Sinatra, αφού είναι αρκετά σύντομο και θα πρέπει να μπορούμε εύκολα να δούμε τι κάνουμε.

Ας υποθέσουμε ότι θέλουμε να λάβουμε ένα μήνυμα ηλεκτρονικού ταχυδρομείου αν ένα συγκεκριμένο άτομο σπρώξει σε ένα συγκεκριμένο τμήμα του έργου μας τροποποιώντας ένα συγκεκριμένο αρχείο.
Θα μπορούσαμε εύκολα να το κάνουμε με κώδικα όπως αυτό:

Let's say we want to get an email if a specific person pushes to a specific branch of our project modifying a specific file.
We could fairly easily do that with code like this:

[source,ruby]
----
require 'sinatra'
require 'json'
require 'mail'

post '/payload' do
  push = JSON.parse(request.body.read) # parse the JSON

  # gather the data we're looking for
  pusher = push["pusher"]["name"]
  branch = push["ref"]

  # get a list of all the files touched
  files = push["commits"].map do |commit|
    commit['added'] + commit['modified'] + commit['removed']
  end
  files = files.flatten.uniq

  # check for our criteria
  if pusher == 'schacon' &&
     branch == 'ref/heads/special-branch' &&
     files.include?('special-file.txt')

    Mail.deliver do
      from     'tchacon@example.com'
      to       'tchacon@example.com'
      subject  'Scott Changed the File'
      body     "ALARM"
    end
  end
end
----

Εδώ παίρνουμε το ωφέλιμο φορτίο JSON που μας παραδίδει το GitHub και ανατρέχοντας ποιος τον έσπρωξε, σε ποιο κλάδο τον έσπρωξαν και ποια αρχεία είχαν αγγιχτεί σε όλες τις υποβολές που προωθήθηκαν.
Στη συνέχεια, ελέγξουμε τα κριτήρια μας και στείλτε ένα μήνυμα ηλεκτρονικού ταχυδρομείου εάν ταιριάζει.

Here we're taking the JSON payload that GitHub delivers us and looking up who pushed it, what branch they pushed to and what files were touched in all the commits that were pushed.
Then we check that against our criteria and send an email if it matches.

Προκειμένου να αναπτυχθεί και να δοκιμάσει κάτι τέτοιο, έχουμε μια ωραία κονσόλα προγραμματιστή στην ίδια οθόνη όπου ρυθμίζουμε τον άγκιστρο.
Μπορούμε να δούμε τις τελευταίες παραδόσεις που προσπάθησε να κάνει το GitHub για αυτό το webhook.
Για κάθε άγκιστρο μπορούμε να ανακαλύψουμε πότε παραδόθηκε, εάν ήταν επιτυχής και το σώμα και οι κεφαλίδες τόσο για το αίτημα όσο και για την απάντηση.
Αυτό καθιστά απίστευτα εύκολο τον έλεγχο και τον εντοπισμό σφαλμάτων στους γάντζους μας.

In order to develop and test something like this, you have a nice developer console in the same screen where you set the hook up.
You can see the last few deliveries that GitHub has tried to make for that webhook.
For each hook you can dig down into when it was delivered, if it was successful and the body and headers for both the request and the response.
This makes it incredibly easy to test and debug your hooks.

[[_web_hook_debug]]
.Web hook debugging information.
image::images/scripting-04-webhook-debug.png[Webhook debug]

The other great feature of this is that you can redeliver any of the payloads to test your service easily.

Το άλλο μεγάλο χαρακτηριστικό του είναι ότι μπορούμε να επαναφέρουμε οποιοδήποτε από τα ωφέλιμα φορτία για να δοκιμάσουμε εύκολα την υπηρεσία μας.

Για περισσότερες πληροφορίες σχετικά με τον τρόπο εγγραφής των webhooks και όλων των διαφορετικών τύπων συμβάντων που μπορούμε να ακούσουμε, μεταβούμε στην τεκμηρίωση του GitHub Developer στη διεύθυνση: https://developer.github.com/webhooks/

For more information on how to write webhooks and all the different event types you can listen for, go to the GitHub Developer documentation at: https://developer.github.com/webhooks/

==== Το API του GitHub

(((GitHub, API)))
Services and hooks give you a way to receive push notifications about events that happen on your repositories, but what if you need more information about these events? What if you need to automate something like adding collaborators or labeling issues?

Οι υπηρεσίες και τα άγκιστρα μας δίνουν έναν τρόπο να λαμβάνουμε ειδοποιήσεις push για συμβάντα που συμβαίνουν στα αποθετήρια μας, αλλά τι γίνεται αν χρειαζόμαστε περισσότερες πληροφορίες σχετικά με αυτά τα συμβάντα; Τι γίνεται αν πρέπει να αυτοματοποιήσουμε κάτι σαν να προσθέτουμε συνεργάτες ή θέματα επισήμανσης;

Αυτό είναι όπου το GitHub API είναι χρήσιμο.
Το GitHub έχει τους τόνους των τελικών σημείων API για να κάνει σχεδόν ο,τιδήποτε μπορούμε να κάνουμε στον ιστότοπο με αυτοματοποιημένο τρόπο.
Σε αυτή την ενότητα θα μάθουμε πώς να επαληθεύουμε την ταυτότητα και να συνδεθούμε στο API, πώς να σχολιάζουμε ένα πρόβλημα και πώς να αλλάξουμε την κατάσταση ενός αιτήματος ελκυσμού μέσω του API.

This is where the GitHub API comes in handy.
GitHub has tons of API endpoints for doing nearly anything you can do on the website in an automated fashion.
In this section we'll learn how to authenticate and connect to the API, how to comment on an issue and how to change the status of a Pull Request through the API.

==== Στοιχειώδης χρήση

Το πιο βασικό πράγμα που μπορούμε να κάνουμε είναι ένα απλό αίτημα GET σε ένα τελικό σημείο που δεν απαιτεί έλεγχο ταυτότητας.
Αυτό θα μπορούσε να είναι ένας χρήστης ή πληροφορίες μόνο για ανάγνωση σε ένα έργο ανοιχτού κώδικα.
Για παράδειγμα, εάν θέλουμε να μάθουμε περισσότερα για έναν χρήστη που ονομάζεται ``schacon'', μπορούμε να τρέξουμε κάτι τέτοιο:

The most basic thing you can do is a simple GET request on an endpoint that doesn't require authentication.
This could be a user or read-only information on an open source project.
For example, if we want to know more about a user named ``schacon'', we can run something like this:

[source,javascript]
----
$ curl https://api.github.com/users/schacon
{
  "login": "schacon",
  "id": 70,
  "avatar_url": "https://avatars.githubusercontent.com/u/70",
# …
  "name": "Scott Chacon",
  "company": "GitHub",
  "following": 19,
  "created_at": "2008-01-27T17:19:28Z",
  "updated_at": "2014-06-10T02:37:23Z"
}
----

There are tons of endpoints like this to get information about organizations, projects, issues, commits -- just about anything you can publicly see on GitHub.
You can even use the API to render arbitrary Markdown or find a `.gitignore` template.

Υπάρχουν τόνοι τέτοιων τελικών σημείων για να λαμβάνουμε πληροφορίες σχετικά με οργανισμούς, έργα, θέματα, υποβολές --σχεδόν για ο,τιδήποτε μπορούμε να δούμε δημοσίως στο GitHub.
Μπορούμε ακόμη να χρησιμοποιήσουμε το API για να κάνουμε αυθαίρετη Markdown ή να βρούμε ένα πρότυπο `.gitignore`.

[source,javascript]
----
$ curl https://api.github.com/gitignore/templates/Java
{
  "name": "Java",
  "source": "*.class

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files #
*.jar
*.war
*.ear

# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
hs_err_pid*
"
}
----


==== Σχολιασμός θέματος

However, if you want to do an action on the website such as comment on an Issue or Pull Request or if you want to view or interact with private content, you'll need to authenticate.

Ωστόσο, αν θέλουμε να κάνουμε μια ενέργεια στον ιστότοπο, όπως σχόλια σχετικά με ένα ζήτημα ή αίτημα ελκυσμού ή αν θέλουμε να προβάλουμε ή να αλληλεπιδράσουμε με ιδιωτικό περιεχόμενο, θα χρειαστεί να επαληθεύσουμε την ταυτότητά μας.

Υπάρχουν πολλοί τρόποι για τον έλεγχο ταυτότητας.
Μπορούμε να χρησιμοποιήσουμε τον βασικό έλεγχο ταυτότητας μόνο με το όνομα χρήστη και τον κωδικό πρόσβασής μας, αλλά γενικά είναι καλύτερο να χρησιμοποιήσουμε ένα προσωπικό αναγνωριστικό πρόσβασης.
Μπορούμε να το δημιουργήσουμε από την καρτέλα "Εφαρμογές" της σελίδας ρυθμίσεων.

There are several ways to authenticate.
You can use basic authentication with just your username and password, but generally it's a better idea to use a personal access token.
You can generate this from the ``Applications'' tab of your settings page.

[[_access_token]]
.Generate your access token from the ``Applications'' tab of your settings page.
image::images/scripting-05-access-token.png[Access Token]

It will ask you which scopes you want for this token and a description.
Make sure to use a good description so you feel comfortable removing the token when your script or application is no longer used.

Θα μας ρωτήσει ποια πεδία θέλουμε για αυτό το διακριτικό και μια περιγραφή.
Βεβαιωθούμε ότι έχουμε χρησιμοποιήσει μια καλή περιγραφή ώστε να αισθανόμαστε άνετα την αφαίρεση του διακριτικού όταν το σενάριο ή η εφαρμογή μας δεν χρησιμοποιείται πλέον.

Το GitHub θα μας δείξει μόνο μία φορά το κουπόνι, οπότε φροντίζουμε να το αντιγράψουμε.
Τώρα μπορούμε να το χρησιμοποιήσουμε για να πιστοποιήσουμε την ταυτότητά μας στη δέσμη ενεργειών μας αντί να χρησιμοποιήσουμε ένα όνομα χρήστη και έναν κωδικό πρόσβασης.
Αυτό είναι ωραίο επειδή μπορούμε να περιορίσουμε το πεδίο εφαρμογής του τι θέλουμε να κάνουμε και το κουπόνι είναι ανακλητό.

GitHub will only show you the token once, so be sure to copy it.
You can now use this to authenticate in your script instead of using a username and password.
This is nice because you can limit the scope of what you want to do and the token is revocable.

This also has the added advantage of increasing your rate limit.
Without authenticating, you will be limited to 60 requests per hour.
If you authenticate you can make up to 5,000 requests per hour.

Αυτό έχει επίσης το πρόσθετο πλεονέκτημα της αύξησης του ορίου μας.
Χωρίς την επικύρωση, θα περιοριστούμε σε 60 αιτήματα ανά ώρα.
Εάν πιστοποιήσουμε την ταυτότητά μας, μπορούμε να κάνουμε έως και 5.000 αιτήματα ανά ώρα.

Ας το χρησιμοποιήσουμε για να σχολιάσουμε ένα από τα ζητήματά μας.
Ας υποθέσουμε ότι θέλουμε να αφήσουμε ένα σχόλιο σε ένα συγκεκριμένο θέμα, Τεύχος # 6.
Για να γίνει αυτό, πρέπει να κάνουμε ένα αίτημα HTTP POST σε `repos/<user>/<repo>/issues/<num>/comments` με το token που μόλις δημιουργήσαμε ως κεφαλίδα Authorization.

So let's use it to make a comment on one of our issues.
Let's say we want to leave a comment on a specific issue, Issue #6.
To do so we have to do an HTTP POST request to `repos/<user>/<repo>/issues/<num>/comments` with the token we just generated as an Authorization header.

[source,javascript]
----
$ curl -H "Content-Type: application/json" \
       -H "Authorization: token TOKEN" \
       --data '{"body":"A new comment, :+1:"}' \
       https://api.github.com/repos/schacon/blink/issues/6/comments
{
  "id": 58322100,
  "html_url": "https://github.com/schacon/blink/issues/6#issuecomment-58322100",
  ...
  "user": {
    "login": "tonychacon",
    "id": 7874698,
    "avatar_url": "https://avatars.githubusercontent.com/u/7874698?v=2",
    "type": "User",
  },
  "created_at": "2014-10-08T07:48:19Z",
  "updated_at": "2014-10-08T07:48:19Z",
  "body": "A new comment, :+1:"
}
----

Τώρα, αν πάμε σε αυτό το θέμα, μπορούμε να δούμε το σχόλιο που μόλις δημοσιεύσαμε όπως στο <<_api_comment>>.

[[_api_comment]]
.A comment posted from the GitHub API.
image::images/scripting-06-comment.png[API Comment]

Μπορούμε να χρησιμοποιήσουμε το API για να κάνουμε σχεδόν ο,τιδήποτε μπορούμε να κάνουμε στον ιστότοπο: δημιουργώντας και ορίζοντας ορόσημα, αναθέτοντας στους χρήστες θέματα και αιτήματα ελκυσμού, δημιουργώντας και αλλάζοντας ετικέτες, αποκτώντας δεδομένα commit, δημιουργώντας νέες υποβολές και κλάδους, ανοίγοντας, κλείνοντας ή τη συγχώνευση των αιτημάτων ελκυσμού, τη δημιουργία και την επεξεργασία ομάδων, την παραπομπή σε γραμμές κώδικα σε ένα αίτημα ελκυσμού, την αναζήτηση στο site και συνεχόμενα.

You can use the API to do just about anything you can do on the website -- creating and setting milestones, assigning people to Issues and Pull Requests, creating and changing labels, accessing commit data, creating new commits and branches, opening, closing or merging Pull Requests, creating and editing teams, commenting on lines of code in a Pull Request, searching the site and on and on.

==== Αλλαγή της κατάστασης ενός αιτήματος ελκυσμού

One final example we'll look at since it's really useful if you're working with Pull Requests.
Each commit can have one or more statuses associated with it and there is an API to add and query that status.

Ένα τελευταίο παράδειγμα θα εξετάσουμε, αφού είναι πραγματικά χρήσιμο, όταν εργαζόμαστε με αιτήματα ελκυσμού.
Κάθε υποβολή μπορεί να έχει μία ή περισσότερες καταστάσεις συνδεδεμένες με αυτήν και υπάρχει ένα API για να προσθέσουμε και να ζητήσουμε αυτήν την κατάσταση.

Οι περισσότερες από τις υπηρεσίες συνεχιζόμενης ενοποίησης και δοκιμών κάνουν χρήση αυτού του API για να αντιδράσουν σε σπρώχνει δοκιμάζοντας τον κώδικα που προωθήθηκε και στη συνέχεια να υποβάλει αναφορά αν αυτή η δέσμευση έχει περάσει όλες τις δοκιμές.
Θα μπορούσαμε επίσης να χρησιμοποιήσουμε αυτό για να ελέγξουμε αν το μήνυμα δέσμευσης είναι σωστά μορφοποιημένο, αν ο υποψήφιος ακολουθούσε όλες τις οδηγίες συμβολής μας, εάν η δέσμευση ήταν έγκυρα υπογεγραμμένη --οποιοδήποτε αριθμό πραγμάτων.

Most of the Continuous Integration and testing services make use of this API to react to pushes by testing the code that was pushed, and then report back if that commit has passed all the tests.
You could also use this to check if the commit message is properly formatted, if the submitter followed all your contribution guidelines, if the commit was validly signed -- any number of things.

Ας υποθέσουμε ότι έχουμε δημιουργήσει ένα webhook στο αποθετήριο μας που αγγίζει μια μικρή υπηρεσία web που ελέγχει για μια συμβολοσειρά `Signed-off` στο μήνυμα commit.

Let's say you set up a webhook on your repository that hits a small web service that checks for a `Signed-off-by` string in the commit message.

[source,ruby]
----
require 'httparty'
require 'sinatra'
require 'json'

post '/payload' do
  push = JSON.parse(request.body.read) # parse the JSON
  repo_name = push['repository']['full_name']

  # look through each commit message
  push["commits"].each do |commit|

    # look for a Signed-off-by string
    if /Signed-off-by/.match commit['message']
      state = 'success'
      description = 'Successfully signed off!'
    else
      state = 'failure'
      description = 'No signoff found.'
    end

    # post status to GitHub
    sha = commit["id"]
    status_url = "https://api.github.com/repos/#{repo_name}/statuses/#{sha}"

    status = {
      "state"       => state,
      "description" => description,
      "target_url"  => "http://example.com/how-to-signoff",
      "context"     => "validate/signoff"
    }
    HTTParty.post(status_url,
      :body => status.to_json,
      :headers => {
        'Content-Type'  => 'application/json',
        'User-Agent'    => 'tonychacon/signoff',
        'Authorization' => "token #{ENV['TOKEN']}" }
    )
  end
end
----

Ας ελπίσουμε ότι αυτό είναι αρκετά απλό να ακολουθηθεί.
Σε αυτόν τον χειριστή αγκίστρων διαδικτύου εξετάζουμε κάθε δέσμευση που μόλις ωθήσαμε, αναζητούμε τη συμβολοσειρά "Signed-off" στο μήνυμα commit και τέλος POST μέσω HTTP στο φάκελο `/ repos / <user> / <repo> / statuses / <commit_sha> `Παράμετρος API με την κατάσταση.

Hopefully this is fairly simple to follow.
In this web hook handler we look through each commit that was just pushed, we look for the string 'Signed-off-by' in the commit message and finally we POST via HTTP to the `/repos/<user>/<repo>/statuses/<commit_sha>` API endpoint with the status.

In this case you can send a state ('success', 'failure', 'error'), a description of what happened, a target URL the user can go to for more information and a ``context'' in case there are multiple statuses for a single commit.
For example, a testing service may provide a status and a validation service like this may also provide a status -- the ``context'' field is how they're differentiated.

Σε αυτή την περίπτωση μπορούμε να στείλουμε μια κατάσταση («επιτυχία», «αποτυχία», «σφάλμα»), μια περιγραφή του τι συνέβη, μια διεύθυνση URL προορισμού που μπορεί να μεταβεί ο χρήστης για περισσότερες πληροφορίες και ένα «περιβάλλον» σε περίπτωση που υπάρχουν πολλαπλές καταστάσεις για μία μόνο δέσμευση.
Για παράδειγμα, μια υπηρεσία δοκιμών μπορεί να παρέχει μια κατάσταση και μια υπηρεσία επικύρωσης όπως αυτή μπορεί επίσης να παρέχει μια κατάσταση - το πεδίο ``context'' είναι το πώς διαφοροποιούνται.

Εάν κάποιος ανοίξει ένα νέο αίτημα ρυμούλκησης στο GitHub και αυτός ο γάντζος έχει ρυθμιστεί, ίσως δούμε κάτι σαν <<_commit_status>>.

If someone opens a new Pull Request on GitHub and this hook is set up, you may see something like <<_commit_status>>.

[[_commit_status]]
.Commit status via the API.
image::images/scripting-07-status.png[Commit status]

Τώρα μπορούμε να δούμε ένα μικρό πράσινο σημάδι ελέγχου δίπλα στη δέσμευση που περιέχει μια συμβολοσειρά ``Signed-off'' στο μήνυμα και ένα κόκκινο σταυρό σε εκείνο που ο συγγραφέας ξεχάστηκε να υπογράψει.
Μπορούμε επίσης να δούμε ότι το Request Pull παίρνει την κατάσταση της τελευταίας δέσμευσης στο υποκατάστημα και μας προειδοποιεί εάν είναι αποτυχία.
Αυτό είναι πραγματικά χρήσιμο εάν χρησιμοποιούμε αυτό το API για τα αποτελέσματα των δοκιμών έτσι ώστε να μην συγχωνεύσουμε τυχαία κάτι όπου η τελευταία αποτυχία αποτυγχάνει σε δοκιμές.

You can now see a little green check mark next to the commit that has a ``Signed-off-by'' string in the message and a red cross through the one where the author forgot to sign off.
You can also see that the Pull Request takes the status of the last commit on the branch and warns you if it is a failure.
This is really useful if you're using this API for test results so you don't accidentally merge something where the last commit is failing tests.

==== Octokit

Though we've been doing nearly everything through `curl` and simple HTTP requests in these examples, several open-source libraries exist that make this API available in a more idiomatic way.
At the time of this writing, the supported languages include Go, Objective-C, Ruby, and .NET.
Check out http://github.com/octokit[] for more information on these, as they handle much of the HTTP for you.

Παρόλο που κάναμε σχεδόν τα πάντα μέσα από `curl` και απλά αιτήματα HTTP σε αυτά τα παραδείγματα, υπάρχουν αρκετές βιβλιοθήκες ανοιχτού κώδικα που κάνουν αυτό το API διαθέσιμο με πιο idiomatic τρόπο.
Τη στιγμή της γραφής, οι υποστηριζόμενες γλώσσες περιλαμβάνουν Go, Objective-C, Ruby και .NET.
Ανατρέξτε στο http://github.com/octokit [] για περισσότερες πληροφορίες σχετικά με αυτά, καθώς χειρίζονται μεγάλο μέρος του HTTP για εσάς.

Ας ελπίσουμε ότι αυτά τα εργαλεία θα μας βοηθήσουν να προσαρμόσουμε και να τροποποιήσουμε το GitHub ώστε να λειτουργεί καλύτερα για τις συγκεκριμένες ροές εργασίας μας.
Για πλήρη τεκμηρίωση σχετικά με ολόκληρο το API καθώς και οδηγούς για κοινές εργασίες, ανατρέξτε στο https://developer.github.com [].

Hopefully these tools can help you customize and modify GitHub to work better for your specific workflows.
For complete documentation on the entire API as well as guides for common tasks, check out https://developer.github.com[].
